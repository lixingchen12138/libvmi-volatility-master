<?xml version="1.0" encoding="UTF-8"?>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>libvirt: core interfaces for the libvirt library</title>
    <meta name="generator" content="Libvirt devhelp stylesheet"/>
    <link rel="start" href="index.html" title="libvirt Reference Manual"/>
    <link rel="up" href="general.html" title="API"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>
    <link rel="chapter" href="general.html" title="API"/>
  </head>
  <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
    <table class="navigation" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
      <tr valign="middle">
        <td>
          <a accesskey="u" href="general.html">
            <img src="up.png" width="24" height="24" border="0" alt="Up"/>
          </a>
        </td>
        <td>
          <a accesskey="h" href="index.html">
            <img src="home.png" width="24" height="24" border="0" alt="Home"/>
          </a>
        </td>
        <td>
          <a accesskey="n" href="libvirt-virterror.html">
            <img src="right.png" width="24" height="24" border="0" alt="Next"/>
          </a>
        </td>
        <th width="100%" align="center">libvirt Reference Manual</th>
      </tr>
    </table>
    <h2>
      <span class="refentrytitle">libvirt</span>
    </h2>
    <p>libvirt - core interfaces for the libvirt library</p>
    <p>Provides the interfaces of the libvirt library to handle virtualized domains  Copyright (C) 2005-2006, 2010-2013 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </p>
    <p>Author(s): Daniel Veillard &lt;veillard@redhat.com&gt; </p>
    <div class="refsynopsisdiv">
      <h2>Synopsis</h2>
      <pre class="synopsis">#define <a href="#LIBVIR_CHECK_VERSION">LIBVIR_CHECK_VERSION</a>(major, minor, micro);
#define <a href="#LIBVIR_VERSION_NUMBER">LIBVIR_VERSION_NUMBER</a>;
#define <a href="#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a>(cpumaps, maplen, vcpu, cpumap);
#define <a href="#VIR_CPU_MAPLEN">VIR_CPU_MAPLEN</a>(cpu);
#define <a href="#VIR_CPU_USABLE">VIR_CPU_USABLE</a>(cpumaps, maplen, vcpu, cpu);
#define <a href="#VIR_CPU_USED">VIR_CPU_USED</a>(cpumap, cpu);
#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_AVERAGE">VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_BURST">VIR_DOMAIN_BANDWIDTH_IN_BURST</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_PEAK">VIR_DOMAIN_BANDWIDTH_IN_PEAK</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE">VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_BURST">VIR_DOMAIN_BANDWIDTH_OUT_BURST</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_PEAK">VIR_DOMAIN_BANDWIDTH_OUT_PEAK</a>;
#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_WEIGHT">VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</a>;
#define <a href="#VIR_DOMAIN_BLKIO_FIELD_LENGTH">VIR_DOMAIN_BLKIO_FIELD_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLKIO_WEIGHT">VIR_DOMAIN_BLKIO_WEIGHT</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_ERRS">VIR_DOMAIN_BLOCK_STATS_ERRS</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH">VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ">VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_BYTES">VIR_DOMAIN_BLOCK_STATS_READ_BYTES</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_REQ">VIR_DOMAIN_BLOCK_STATS_READ_REQ</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES">VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_REQ">VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</a>;
#define <a href="#VIR_DOMAIN_CPU_STATS_CPUTIME">VIR_DOMAIN_CPU_STATS_CPUTIME</a>;
#define <a href="#VIR_DOMAIN_CPU_STATS_SYSTEMTIME">VIR_DOMAIN_CPU_STATS_SYSTEMTIME</a>;
#define <a href="#VIR_DOMAIN_CPU_STATS_USERTIME">VIR_DOMAIN_CPU_STATS_USERTIME</a>;
#define <a href="#VIR_DOMAIN_CPU_STATS_VCPUTIME">VIR_DOMAIN_CPU_STATS_VCPUTIME</a>;
#define <a href="#VIR_DOMAIN_EVENT_CALLBACK">VIR_DOMAIN_EVENT_CALLBACK</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_BYTES">VIR_DOMAIN_JOB_COMPRESSION_BYTES</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE">VIR_DOMAIN_JOB_COMPRESSION_CACHE</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES">VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW">VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_PAGES">VIR_DOMAIN_JOB_COMPRESSION_PAGES</a>;
#define <a href="#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a>;
#define <a href="#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a>;
#define <a href="#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a>;
#define <a href="#VIR_DOMAIN_JOB_DISK_PROCESSED">VIR_DOMAIN_JOB_DISK_PROCESSED</a>;
#define <a href="#VIR_DOMAIN_JOB_DISK_REMAINING">VIR_DOMAIN_JOB_DISK_REMAINING</a>;
#define <a href="#VIR_DOMAIN_JOB_DISK_TOTAL">VIR_DOMAIN_JOB_DISK_TOTAL</a>;
#define <a href="#VIR_DOMAIN_JOB_DOWNTIME">VIR_DOMAIN_JOB_DOWNTIME</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_CONSTANT">VIR_DOMAIN_JOB_MEMORY_CONSTANT</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL">VIR_DOMAIN_JOB_MEMORY_NORMAL</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES">VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_PROCESSED">VIR_DOMAIN_JOB_MEMORY_PROCESSED</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_REMAINING">VIR_DOMAIN_JOB_MEMORY_REMAINING</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_TOTAL">VIR_DOMAIN_JOB_MEMORY_TOTAL</a>;
#define <a href="#VIR_DOMAIN_JOB_TIME_ELAPSED">VIR_DOMAIN_JOB_TIME_ELAPSED</a>;
#define <a href="#VIR_DOMAIN_JOB_TIME_REMAINING">VIR_DOMAIN_JOB_TIME_REMAINING</a>;
#define <a href="#VIR_DOMAIN_MEMORY_FIELD_LENGTH">VIR_DOMAIN_MEMORY_FIELD_LENGTH</a>;
#define <a href="#VIR_DOMAIN_MEMORY_HARD_LIMIT">VIR_DOMAIN_MEMORY_HARD_LIMIT</a>;
#define <a href="#VIR_DOMAIN_MEMORY_MIN_GUARANTEE">VIR_DOMAIN_MEMORY_MIN_GUARANTEE</a>;
#define <a href="#VIR_DOMAIN_MEMORY_PARAM_UNLIMITED">VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</a>;
#define <a href="#VIR_DOMAIN_MEMORY_SOFT_LIMIT">VIR_DOMAIN_MEMORY_SOFT_LIMIT</a>;
#define <a href="#VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT">VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</a>;
#define <a href="#VIR_DOMAIN_NUMA_MODE">VIR_DOMAIN_NUMA_MODE</a>;
#define <a href="#VIR_DOMAIN_NUMA_NODESET">VIR_DOMAIN_NUMA_NODESET</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_CAP">VIR_DOMAIN_SCHEDULER_CAP</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_CPU_SHARES">VIR_DOMAIN_SCHEDULER_CPU_SHARES</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD">VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA">VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_LIMIT">VIR_DOMAIN_SCHEDULER_LIMIT</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_RESERVATION">VIR_DOMAIN_SCHEDULER_RESERVATION</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_SHARES">VIR_DOMAIN_SCHEDULER_SHARES</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_VCPU_PERIOD">VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_VCPU_QUOTA">VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_WEIGHT">VIR_DOMAIN_SCHEDULER_WEIGHT</a>;
#define <a href="#VIR_DOMAIN_SCHED_FIELD_LENGTH">VIR_DOMAIN_SCHED_FIELD_LENGTH</a>;
#define <a href="#VIR_DOMAIN_SEND_KEY_MAX_KEYS">VIR_DOMAIN_SEND_KEY_MAX_KEYS</a>;
#define <a href="#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a>(cpumaps, maplen, vcpu);
#define <a href="#VIR_MIGRATE_PARAM_BANDWIDTH">VIR_MIGRATE_PARAM_BANDWIDTH</a>;
#define <a href="#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a>;
#define <a href="#VIR_MIGRATE_PARAM_DEST_XML">VIR_MIGRATE_PARAM_DEST_XML</a>;
#define <a href="#VIR_MIGRATE_PARAM_GRAPHICS_URI">VIR_MIGRATE_PARAM_GRAPHICS_URI</a>;
#define <a href="#VIR_MIGRATE_PARAM_LISTEN_ADDRESS">VIR_MIGRATE_PARAM_LISTEN_ADDRESS</a>;
#define <a href="#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a>;
#define <a href="#VIR_NODEINFO_MAXCPUS">VIR_NODEINFO_MAXCPUS</a>(nodeinfo);
#define <a href="#VIR_NODE_CPU_STATS_FIELD_LENGTH">VIR_NODE_CPU_STATS_FIELD_LENGTH</a>;
#define <a href="#VIR_NODE_CPU_STATS_IDLE">VIR_NODE_CPU_STATS_IDLE</a>;
#define <a href="#VIR_NODE_CPU_STATS_IOWAIT">VIR_NODE_CPU_STATS_IOWAIT</a>;
#define <a href="#VIR_NODE_CPU_STATS_KERNEL">VIR_NODE_CPU_STATS_KERNEL</a>;
#define <a href="#VIR_NODE_CPU_STATS_USER">VIR_NODE_CPU_STATS_USER</a>;
#define <a href="#VIR_NODE_CPU_STATS_UTILIZATION">VIR_NODE_CPU_STATS_UTILIZATION</a>;
#define <a href="#VIR_NODE_MEMORY_STATS_BUFFERS">VIR_NODE_MEMORY_STATS_BUFFERS</a>;
#define <a href="#VIR_NODE_MEMORY_STATS_CACHED">VIR_NODE_MEMORY_STATS_CACHED</a>;
#define <a href="#VIR_NODE_MEMORY_STATS_FIELD_LENGTH">VIR_NODE_MEMORY_STATS_FIELD_LENGTH</a>;
#define <a href="#VIR_NODE_MEMORY_STATS_FREE">VIR_NODE_MEMORY_STATS_FREE</a>;
#define <a href="#VIR_NODE_MEMORY_STATS_TOTAL">VIR_NODE_MEMORY_STATS_TOTAL</a>;
#define <a href="#VIR_SECURITY_DOI_BUFLEN">VIR_SECURITY_DOI_BUFLEN</a>;
#define <a href="#VIR_SECURITY_LABEL_BUFLEN">VIR_SECURITY_LABEL_BUFLEN</a>;
#define <a href="#VIR_SECURITY_MODEL_BUFLEN">VIR_SECURITY_MODEL_BUFLEN</a>;
#define <a href="#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a>;
#define <a href="#VIR_UNUSE_CPU">VIR_UNUSE_CPU</a>(cpumap, cpu);
#define <a href="#VIR_USE_CPU">VIR_USE_CPU</a>(cpumap, cpu);
#define <a href="#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a>;
#define <a href="#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a>;
#define <a href="#_virBlkioParameter">_virBlkioParameter</a>;
#define <a href="#_virMemoryParameter">_virMemoryParameter</a>;
#define <a href="#_virSchedParameter">_virSchedParameter</a>;
typedef struct _virTypedParameter <a href="#virBlkioParameter">virBlkioParameter</a>;
typedef <a href="libvirt-libvirt.html#virBlkioParameter">virBlkioParameter</a> * <a href="#virBlkioParameterPtr">virBlkioParameterPtr</a>;
typedef enum <a href="#virBlkioParameterType">virBlkioParameterType</a>;
typedef enum <a href="#virCPUCompareResult">virCPUCompareResult</a>;
typedef struct _virConnect <a href="#virConnect">virConnect</a>;
typedef struct _virConnectAuth <a href="#virConnectAuth">virConnectAuth</a>;
typedef <a href="libvirt-libvirt.html#virConnectAuth">virConnectAuth</a> * <a href="#virConnectAuthPtr">virConnectAuthPtr</a>;
typedef enum <a href="#virConnectBaselineCPUFlags">virConnectBaselineCPUFlags</a>;
typedef enum <a href="#virConnectCloseReason">virConnectCloseReason</a>;
typedef struct _virConnectCredential <a href="#virConnectCredential">virConnectCredential</a>;
typedef <a href="libvirt-libvirt.html#virConnectCredential">virConnectCredential</a> * <a href="#virConnectCredentialPtr">virConnectCredentialPtr</a>;
typedef enum <a href="#virConnectCredentialType">virConnectCredentialType</a>;
typedef enum <a href="#virConnectDomainEventBlockJobStatus">virConnectDomainEventBlockJobStatus</a>;
typedef enum <a href="#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a>;
typedef enum <a href="#virConnectFlags">virConnectFlags</a>;
typedef enum <a href="#virConnectListAllDomainsFlags">virConnectListAllDomainsFlags</a>;
typedef enum <a href="#virConnectListAllInterfacesFlags">virConnectListAllInterfacesFlags</a>;
typedef enum <a href="#virConnectListAllNetworksFlags">virConnectListAllNetworksFlags</a>;
typedef enum <a href="#virConnectListAllNodeDeviceFlags">virConnectListAllNodeDeviceFlags</a>;
typedef enum <a href="#virConnectListAllSecretsFlags">virConnectListAllSecretsFlags</a>;
typedef enum <a href="#virConnectListAllStoragePoolsFlags">virConnectListAllStoragePoolsFlags</a>;
typedef <a href="libvirt-libvirt.html#virConnect">virConnect</a> * <a href="#virConnectPtr">virConnectPtr</a>;
typedef struct _virDomain <a href="#virDomain">virDomain</a>;
typedef enum <a href="#virDomainBlockCommitFlags">virDomainBlockCommitFlags</a>;
typedef struct _virDomainBlockInfo <a href="#virDomainBlockInfo">virDomainBlockInfo</a>;
typedef <a href="libvirt-libvirt.html#virDomainBlockInfo">virDomainBlockInfo</a> * <a href="#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a>;
typedef enum <a href="#virDomainBlockJobAbortFlags">virDomainBlockJobAbortFlags</a>;
typedef unsigned long long <a href="#virDomainBlockJobCursor">virDomainBlockJobCursor</a>;
typedef struct _virDomainBlockJobInfo <a href="#virDomainBlockJobInfo">virDomainBlockJobInfo</a>;
typedef <a href="libvirt-libvirt.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a> * <a href="#virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a>;
typedef enum <a href="#virDomainBlockJobType">virDomainBlockJobType</a>;
typedef enum <a href="#virDomainBlockRebaseFlags">virDomainBlockRebaseFlags</a>;
typedef enum <a href="#virDomainBlockResizeFlags">virDomainBlockResizeFlags</a>;
typedef <a href="libvirt-libvirt.html#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a> * <a href="#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a>;
typedef struct _virDomainBlockStats <a href="#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a>;
typedef enum <a href="#virDomainBlockedReason">virDomainBlockedReason</a>;
typedef enum <a href="#virDomainChannelFlags">virDomainChannelFlags</a>;
typedef enum <a href="#virDomainConsoleFlags">virDomainConsoleFlags</a>;
typedef struct _virDomainControlInfo <a href="#virDomainControlInfo">virDomainControlInfo</a>;
typedef <a href="libvirt-libvirt.html#virDomainControlInfo">virDomainControlInfo</a> * <a href="#virDomainControlInfoPtr">virDomainControlInfoPtr</a>;
typedef enum <a href="#virDomainControlState">virDomainControlState</a>;
typedef enum <a href="#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a>;
typedef enum <a href="#virDomainCrashedReason">virDomainCrashedReason</a>;
typedef enum <a href="#virDomainCreateFlags">virDomainCreateFlags</a>;
typedef enum <a href="#virDomainDestroyFlagsValues">virDomainDestroyFlagsValues</a>;
typedef enum <a href="#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a>;
typedef struct _virDomainDiskError <a href="#virDomainDiskError">virDomainDiskError</a>;
typedef enum <a href="#virDomainDiskErrorCode">virDomainDiskErrorCode</a>;
typedef <a href="libvirt-libvirt.html#virDomainDiskError">virDomainDiskError</a> * <a href="#virDomainDiskErrorPtr">virDomainDiskErrorPtr</a>;
typedef enum <a href="#virDomainEventCrashedDetailType">virDomainEventCrashedDetailType</a>;
typedef enum <a href="#virDomainEventDefinedDetailType">virDomainEventDefinedDetailType</a>;
typedef struct _virDomainEventGraphicsAddress <a href="#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a>;
typedef <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * <a href="#virDomainEventGraphicsAddressPtr">virDomainEventGraphicsAddressPtr</a>;
typedef enum <a href="#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a>;
typedef enum <a href="#virDomainEventGraphicsPhase">virDomainEventGraphicsPhase</a>;
typedef struct _virDomainEventGraphicsSubject <a href="#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a>;
typedef struct _virDomainEventGraphicsSubjectIdentity <a href="#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a>;
typedef <a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a> * <a href="#virDomainEventGraphicsSubjectIdentityPtr">virDomainEventGraphicsSubjectIdentityPtr</a>;
typedef <a href="libvirt-libvirt.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * <a href="#virDomainEventGraphicsSubjectPtr">virDomainEventGraphicsSubjectPtr</a>;
typedef enum <a href="#virDomainEventID">virDomainEventID</a>;
typedef enum <a href="#virDomainEventIOErrorAction">virDomainEventIOErrorAction</a>;
typedef enum <a href="#virDomainEventPMSuspendedDetailType">virDomainEventPMSuspendedDetailType</a>;
typedef enum <a href="#virDomainEventResumedDetailType">virDomainEventResumedDetailType</a>;
typedef enum <a href="#virDomainEventShutdownDetailType">virDomainEventShutdownDetailType</a>;
typedef enum <a href="#virDomainEventStartedDetailType">virDomainEventStartedDetailType</a>;
typedef enum <a href="#virDomainEventStoppedDetailType">virDomainEventStoppedDetailType</a>;
typedef enum <a href="#virDomainEventSuspendedDetailType">virDomainEventSuspendedDetailType</a>;
typedef enum <a href="#virDomainEventTrayChangeReason">virDomainEventTrayChangeReason</a>;
typedef enum <a href="#virDomainEventType">virDomainEventType</a>;
typedef enum <a href="#virDomainEventUndefinedDetailType">virDomainEventUndefinedDetailType</a>;
typedef enum <a href="#virDomainEventWatchdogAction">virDomainEventWatchdogAction</a>;
typedef struct _virDomainInfo <a href="#virDomainInfo">virDomainInfo</a>;
typedef <a href="libvirt-libvirt.html#virDomainInfo">virDomainInfo</a> * <a href="#virDomainInfoPtr">virDomainInfoPtr</a>;
typedef <a href="libvirt-libvirt.html#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a> * <a href="#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a>;
typedef struct _virDomainInterfaceStats <a href="#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a>;
typedef struct _virDomainJobInfo <a href="#virDomainJobInfo">virDomainJobInfo</a>;
typedef <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a> * <a href="#virDomainJobInfoPtr">virDomainJobInfoPtr</a>;
typedef enum <a href="#virDomainJobType">virDomainJobType</a>;
typedef enum <a href="#virDomainMemoryFlags">virDomainMemoryFlags</a>;
typedef enum <a href="#virDomainMemoryModFlags">virDomainMemoryModFlags</a>;
typedef <a href="libvirt-libvirt.html#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a> * <a href="#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a>;
typedef struct _virDomainMemoryStat <a href="#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a>;
typedef enum <a href="#virDomainMemoryStatTags">virDomainMemoryStatTags</a>;
typedef enum <a href="#virDomainMetadataType">virDomainMetadataType</a>;
typedef enum <a href="#virDomainMigrateFlags">virDomainMigrateFlags</a>;
typedef enum <a href="#virDomainModificationImpact">virDomainModificationImpact</a>;
typedef enum <a href="#virDomainNostateReason">virDomainNostateReason</a>;
typedef enum <a href="#virDomainNumatuneMemMode">virDomainNumatuneMemMode</a>;
typedef enum <a href="#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a>;
typedef enum <a href="#virDomainPMSuspendedDiskReason">virDomainPMSuspendedDiskReason</a>;
typedef enum <a href="#virDomainPMSuspendedReason">virDomainPMSuspendedReason</a>;
typedef enum <a href="#virDomainPausedReason">virDomainPausedReason</a>;
typedef enum <a href="#virDomainProcessSignal">virDomainProcessSignal</a>;
typedef <a href="libvirt-libvirt.html#virDomain">virDomain</a> * <a href="#virDomainPtr">virDomainPtr</a>;
typedef enum <a href="#virDomainRebootFlagValues">virDomainRebootFlagValues</a>;
typedef enum <a href="#virDomainRunningReason">virDomainRunningReason</a>;
typedef enum <a href="#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a>;
typedef enum <a href="#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a>;
typedef enum <a href="#virDomainShutdownReason">virDomainShutdownReason</a>;
typedef enum <a href="#virDomainShutoffReason">virDomainShutoffReason</a>;
typedef struct _virDomainSnapshot <a href="#virDomainSnapshot">virDomainSnapshot</a>;
typedef enum <a href="#virDomainSnapshotCreateFlags">virDomainSnapshotCreateFlags</a>;
typedef enum <a href="#virDomainSnapshotDeleteFlags">virDomainSnapshotDeleteFlags</a>;
typedef enum <a href="#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a>;
typedef <a href="libvirt-libvirt.html#virDomainSnapshot">virDomainSnapshot</a> * <a href="#virDomainSnapshotPtr">virDomainSnapshotPtr</a>;
typedef enum <a href="#virDomainSnapshotRevertFlags">virDomainSnapshotRevertFlags</a>;
typedef enum <a href="#virDomainState">virDomainState</a>;
typedef enum <a href="#virDomainUndefineFlagsValues">virDomainUndefineFlagsValues</a>;
typedef enum <a href="#virDomainVcpuFlags">virDomainVcpuFlags</a>;
typedef enum <a href="#virDomainXMLFlags">virDomainXMLFlags</a>;
typedef enum <a href="#virEventHandleType">virEventHandleType</a>;
typedef struct _virInterface <a href="#virInterface">virInterface</a>;
typedef <a href="libvirt-libvirt.html#virInterface">virInterface</a> * <a href="#virInterfacePtr">virInterfacePtr</a>;
typedef enum <a href="#virInterfaceXMLFlags">virInterfaceXMLFlags</a>;
typedef enum <a href="#virKeycodeSet">virKeycodeSet</a>;
typedef struct _virTypedParameter <a href="#virMemoryParameter">virMemoryParameter</a>;
typedef <a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a> * <a href="#virMemoryParameterPtr">virMemoryParameterPtr</a>;
typedef enum <a href="#virMemoryParameterType">virMemoryParameterType</a>;
typedef struct _virNWFilter <a href="#virNWFilter">virNWFilter</a>;
typedef <a href="libvirt-libvirt.html#virNWFilter">virNWFilter</a> * <a href="#virNWFilterPtr">virNWFilterPtr</a>;
typedef struct _virNetwork <a href="#virNetwork">virNetwork</a>;
typedef <a href="libvirt-libvirt.html#virNetwork">virNetwork</a> * <a href="#virNetworkPtr">virNetworkPtr</a>;
typedef enum <a href="#virNetworkUpdateCommand">virNetworkUpdateCommand</a>;
typedef enum <a href="#virNetworkUpdateFlags">virNetworkUpdateFlags</a>;
typedef enum <a href="#virNetworkUpdateSection">virNetworkUpdateSection</a>;
typedef enum <a href="#virNetworkXMLFlags">virNetworkXMLFlags</a>;
typedef struct _virNodeCPUStats <a href="#virNodeCPUStats">virNodeCPUStats</a>;
typedef <a href="libvirt-libvirt.html#virNodeCPUStats">virNodeCPUStats</a> * <a href="#virNodeCPUStatsPtr">virNodeCPUStatsPtr</a>;
typedef struct _virNodeDevice <a href="#virNodeDevice">virNodeDevice</a>;
typedef <a href="libvirt-libvirt.html#virNodeDevice">virNodeDevice</a> * <a href="#virNodeDevicePtr">virNodeDevicePtr</a>;
typedef enum <a href="#virNodeGetCPUStatsAllCPUs">virNodeGetCPUStatsAllCPUs</a>;
typedef enum <a href="#virNodeGetMemoryStatsAllCells">virNodeGetMemoryStatsAllCells</a>;
typedef struct _virNodeInfo <a href="#virNodeInfo">virNodeInfo</a>;
typedef <a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> * <a href="#virNodeInfoPtr">virNodeInfoPtr</a>;
typedef struct _virNodeMemoryStats <a href="#virNodeMemoryStats">virNodeMemoryStats</a>;
typedef <a href="libvirt-libvirt.html#virNodeMemoryStats">virNodeMemoryStats</a> * <a href="#virNodeMemoryStatsPtr">virNodeMemoryStatsPtr</a>;
typedef enum <a href="#virNodeSuspendTarget">virNodeSuspendTarget</a>;
typedef struct _virTypedParameter <a href="#virSchedParameter">virSchedParameter</a>;
typedef <a href="libvirt-libvirt.html#virSchedParameter">virSchedParameter</a> * <a href="#virSchedParameterPtr">virSchedParameterPtr</a>;
typedef enum <a href="#virSchedParameterType">virSchedParameterType</a>;
typedef struct _virSecret <a href="#virSecret">virSecret</a>;
typedef <a href="libvirt-libvirt.html#virSecret">virSecret</a> * <a href="#virSecretPtr">virSecretPtr</a>;
typedef enum <a href="#virSecretUsageType">virSecretUsageType</a>;
typedef struct _virSecurityLabel <a href="#virSecurityLabel">virSecurityLabel</a>;
typedef <a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> * <a href="#virSecurityLabelPtr">virSecurityLabelPtr</a>;
typedef struct _virSecurityModel <a href="#virSecurityModel">virSecurityModel</a>;
typedef <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> * <a href="#virSecurityModelPtr">virSecurityModelPtr</a>;
typedef struct _virStoragePool <a href="#virStoragePool">virStoragePool</a>;
typedef enum <a href="#virStoragePoolBuildFlags">virStoragePoolBuildFlags</a>;
typedef enum <a href="#virStoragePoolDeleteFlags">virStoragePoolDeleteFlags</a>;
typedef struct _virStoragePoolInfo <a href="#virStoragePoolInfo">virStoragePoolInfo</a>;
typedef <a href="libvirt-libvirt.html#virStoragePoolInfo">virStoragePoolInfo</a> * <a href="#virStoragePoolInfoPtr">virStoragePoolInfoPtr</a>;
typedef <a href="libvirt-libvirt.html#virStoragePool">virStoragePool</a> * <a href="#virStoragePoolPtr">virStoragePoolPtr</a>;
typedef enum <a href="#virStoragePoolState">virStoragePoolState</a>;
typedef struct _virStorageVol <a href="#virStorageVol">virStorageVol</a>;
typedef enum <a href="#virStorageVolCreateFlags">virStorageVolCreateFlags</a>;
typedef enum <a href="#virStorageVolDeleteFlags">virStorageVolDeleteFlags</a>;
typedef struct _virStorageVolInfo <a href="#virStorageVolInfo">virStorageVolInfo</a>;
typedef <a href="libvirt-libvirt.html#virStorageVolInfo">virStorageVolInfo</a> * <a href="#virStorageVolInfoPtr">virStorageVolInfoPtr</a>;
typedef <a href="libvirt-libvirt.html#virStorageVol">virStorageVol</a> * <a href="#virStorageVolPtr">virStorageVolPtr</a>;
typedef enum <a href="#virStorageVolResizeFlags">virStorageVolResizeFlags</a>;
typedef enum <a href="#virStorageVolType">virStorageVolType</a>;
typedef enum <a href="#virStorageVolWipeAlgorithm">virStorageVolWipeAlgorithm</a>;
typedef enum <a href="#virStorageXMLFlags">virStorageXMLFlags</a>;
typedef struct _virStream <a href="#virStream">virStream</a>;
typedef enum <a href="#virStreamEventType">virStreamEventType</a>;
typedef enum <a href="#virStreamFlags">virStreamFlags</a>;
typedef <a href="libvirt-libvirt.html#virStream">virStream</a> * <a href="#virStreamPtr">virStreamPtr</a>;
typedef struct _virTypedParameter <a href="#virTypedParameter">virTypedParameter</a>;
typedef enum <a href="#virTypedParameterFlags">virTypedParameterFlags</a>;
typedef <a href="libvirt-libvirt.html#virTypedParameter">virTypedParameter</a> * <a href="#virTypedParameterPtr">virTypedParameterPtr</a>;
typedef enum <a href="#virTypedParameterType">virTypedParameterType</a>;
typedef struct _virVcpuInfo <a href="#virVcpuInfo">virVcpuInfo</a>;
typedef <a href="libvirt-libvirt.html#virVcpuInfo">virVcpuInfo</a> * <a href="#virVcpuInfoPtr">virVcpuInfoPtr</a>;
typedef enum <a href="#virVcpuState">virVcpuState</a>;
typedef int <a href="#virConnectAuthCallbackPtr">virConnectAuthCallbackPtr</a>	(<a href="libvirt-libvirt.html#virConnectCredentialPtr">virConnectCredentialPtr</a> cred, <br/>					 unsigned int ncred, <br/>					 void * cbdata);
char *	<a href="#virConnectBaselineCPU">virConnectBaselineCPU</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char ** xmlCPUs, <br/>					 unsigned int ncpus, <br/>					 unsigned int flags);
int	<a href="#virConnectClose">virConnectClose</a>			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
typedef void <a href="#virConnectCloseFunc">virConnectCloseFunc</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int reason, <br/>					 void * opaque);
int	<a href="#virConnectCompareCPU">virConnectCompareCPU</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags);
typedef void <a href="#virConnectDomainEventBalloonChangeCallback">virConnectDomainEventBalloonChangeCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 unsigned long long actual, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventBlockJobCallback">virConnectDomainEventBlockJobCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * disk, <br/>						 int type, <br/>						 int status, <br/>						 void * opaque);
typedef int <a href="#virConnectDomainEventCallback">virConnectDomainEventCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 int event, <br/>					 int detail, <br/>					 void * opaque);
int	<a href="#virConnectDomainEventDeregister">virConnectDomainEventDeregister</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb);
int	<a href="#virConnectDomainEventDeregisterAny">virConnectDomainEventDeregisterAny</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 int callbackID);
typedef void <a href="#virConnectDomainEventDeviceRemovedCallback">virConnectDomainEventDeviceRemovedCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * devAlias, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventDiskChangeCallback">virConnectDomainEventDiskChangeCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * oldSrcPath, <br/>						 const char * newSrcPath, <br/>						 const char * devAlias, <br/>						 int reason, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventGraphicsCallback">virConnectDomainEventGraphicsCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int phase, <br/>						 const <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * local, <br/>						 const <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * remote, <br/>						 const char * authScheme, <br/>						 const <a href="libvirt-libvirt.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * subject, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventIOErrorCallback">virConnectDomainEventIOErrorCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * srcPath, <br/>						 const char * devAlias, <br/>						 int action, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventIOErrorReasonCallback">virConnectDomainEventIOErrorReasonCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * srcPath, <br/>							 const char * devAlias, <br/>							 int action, <br/>							 const char * reason, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventPMSuspendCallback">virConnectDomainEventPMSuspendCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int reason, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventPMSuspendDiskCallback">virConnectDomainEventPMSuspendDiskCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int reason, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventPMWakeupCallback">virConnectDomainEventPMWakeupCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int reason, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventRTCChangeCallback">virConnectDomainEventRTCChangeCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 long long utcoffset, <br/>						 void * opaque);
int	<a href="#virConnectDomainEventRegister">virConnectDomainEventRegister</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb);
int	<a href="#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int eventID, <br/>						 <a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a> cb, <br/>						 void * opaque, <br/>						 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb);
typedef void <a href="#virConnectDomainEventTrayChangeCallback">virConnectDomainEventTrayChangeCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * devAlias, <br/>						 int reason, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventWatchdogCallback">virConnectDomainEventWatchdogCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int action, <br/>						 void * opaque);
char *	<a href="#virConnectDomainXMLFromNative">virConnectDomainXMLFromNative</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * nativeFormat, <br/>					 const char * nativeConfig, <br/>					 unsigned int flags);
char *	<a href="#virConnectDomainXMLToNative">virConnectDomainXMLToNative</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * nativeFormat, <br/>					 const char * domainXml, <br/>					 unsigned int flags);
char *	<a href="#virConnectFindStoragePoolSources">virConnectFindStoragePoolSources</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * type, <br/>						 const char * srcSpec, <br/>						 unsigned int flags);
int	<a href="#virConnectGetCPUModelNames">virConnectGetCPUModelNames</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * arch, <br/>					 char ** * models, <br/>					 unsigned int flags);
char *	<a href="#virConnectGetCapabilities">virConnectGetCapabilities</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
char *	<a href="#virConnectGetHostname">virConnectGetHostname</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectGetLibVersion">virConnectGetLibVersion</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned long * libVer);
int	<a href="#virConnectGetMaxVcpus">virConnectGetMaxVcpus</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * type);
char *	<a href="#virConnectGetSysinfo">virConnectGetSysinfo</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags);
const char *	<a href="#virConnectGetType">virConnectGetType</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
char *	<a href="#virConnectGetURI">virConnectGetURI</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectGetVersion">virConnectGetVersion</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned long * hvVer);
int	<a href="#virConnectIsAlive">virConnectIsAlive</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectIsEncrypted">virConnectIsEncrypted</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectIsSecure">virConnectIsSecure</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectListAllDomains">virConnectListAllDomains</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> ** domains, <br/>					 unsigned int flags);
int	<a href="#virConnectListAllInterfaces">virConnectListAllInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> ** ifaces, <br/>					 unsigned int flags);
int	<a href="#virConnectListAllNWFilters">virConnectListAllNWFilters</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> ** filters, <br/>					 unsigned int flags);
int	<a href="#virConnectListAllNetworks">virConnectListAllNetworks</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> ** nets, <br/>					 unsigned int flags);
int	<a href="#virConnectListAllNodeDevices">virConnectListAllNodeDevices</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> ** devices, <br/>					 unsigned int flags);
int	<a href="#virConnectListAllSecrets">virConnectListAllSecrets</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> ** secrets, <br/>					 unsigned int flags);
int	<a href="#virConnectListAllStoragePools">virConnectListAllStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> ** pools, <br/>					 unsigned int flags);
int	<a href="#virConnectListDefinedDomains">virConnectListDefinedDomains</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames);
int	<a href="#virConnectListDefinedInterfaces">virConnectListDefinedInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames);
int	<a href="#virConnectListDefinedNetworks">virConnectListDefinedNetworks</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames);
int	<a href="#virConnectListDefinedStoragePools">virConnectListDefinedStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 char ** const names, <br/>						 int maxnames);
int	<a href="#virConnectListDomains">virConnectListDomains</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int * ids, <br/>					 int maxids);
int	<a href="#virConnectListInterfaces">virConnectListInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames);
int	<a href="#virConnectListNWFilters">virConnectListNWFilters</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames);
int	<a href="#virConnectListNetworks">virConnectListNetworks</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames);
int	<a href="#virConnectListSecrets">virConnectListSecrets</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** uuids, <br/>					 int maxuuids);
int	<a href="#virConnectListStoragePools">virConnectListStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames);
int	<a href="#virConnectNumOfDefinedDomains">virConnectNumOfDefinedDomains</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfDefinedInterfaces">virConnectNumOfDefinedInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfDefinedNetworks">virConnectNumOfDefinedNetworks</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfDefinedStoragePools">virConnectNumOfDefinedStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfDomains">virConnectNumOfDomains</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfInterfaces">virConnectNumOfInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfNWFilters">virConnectNumOfNWFilters</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfNetworks">virConnectNumOfNetworks</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfSecrets">virConnectNumOfSecrets</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfStoragePools">virConnectNumOfStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virConnectOpen">virConnectOpen</a>		(const char * name);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virConnectOpenAuth">virConnectOpenAuth</a>	(const char * name, <br/>					 <a href="libvirt-libvirt.html#virConnectAuthPtr">virConnectAuthPtr</a> auth, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virConnectOpenReadOnly">virConnectOpenReadOnly</a>	(const char * name);
int	<a href="#virConnectRef">virConnectRef</a>			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectRegisterCloseCallback">virConnectRegisterCloseCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virConnectCloseFunc">virConnectCloseFunc</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb);
int	<a href="#virConnectSetKeepAlive">virConnectSetKeepAlive</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int interval, <br/>					 unsigned int count);
int	<a href="#virConnectUnregisterCloseCallback">virConnectUnregisterCloseCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virConnectCloseFunc">virConnectCloseFunc</a> cb);
int	<a href="#virDomainAbortJob">virDomainAbortJob</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainAttachDevice">virDomainAttachDevice</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml);
int	<a href="#virDomainAttachDeviceFlags">virDomainAttachDeviceFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockCommit">virDomainBlockCommit</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * base, <br/>					 const char * top, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockJobAbort">virDomainBlockJobAbort</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockJobSetSpeed">virDomainBlockJobSetSpeed</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockPeek">virDomainBlockPeek</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long long offset, <br/>					 size_t size, <br/>					 void * buffer, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockPull">virDomainBlockPull</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockRebase">virDomainBlockRebase</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * base, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockResize">virDomainBlockResize</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long long size, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockStats">virDomainBlockStats</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a> stats, <br/>					 size_t size);
int	<a href="#virDomainBlockStatsFlags">virDomainBlockStatsFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainCoreDump">virDomainCoreDump</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 unsigned int flags);
int	<a href="#virDomainCreate">virDomainCreate</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainCreateLinux">virDomainCreateLinux</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags);
int	<a href="#virDomainCreateWithFiles">virDomainCreateWithFiles</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nfiles, <br/>					 int * files, <br/>					 unsigned int flags);
int	<a href="#virDomainCreateWithFlags">virDomainCreateWithFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainCreateXML">virDomainCreateXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainCreateXMLWithFiles">virDomainCreateXMLWithFiles</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int nfiles, <br/>						 int * files, <br/>						 unsigned int flags);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainDefineXML">virDomainDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml);
int	<a href="#virDomainDestroy">virDomainDestroy</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainDestroyFlags">virDomainDestroyFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainDetachDevice">virDomainDetachDevice</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml);
int	<a href="#virDomainDetachDeviceFlags">virDomainDetachDeviceFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags);
int	<a href="#virDomainFSTrim">virDomainFSTrim</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * mountPoint, <br/>					 unsigned long long minimum, <br/>					 unsigned int flags);
int	<a href="#virDomainFree">virDomainFree</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetAutostart">virDomainGetAutostart</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * autostart);
int	<a href="#virDomainGetBlkioParameters">virDomainGetBlkioParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainGetBlockInfo">virDomainGetBlockInfo</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a> info, <br/>					 unsigned int flags);
int	<a href="#virDomainGetBlockIoTune">virDomainGetBlockIoTune</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainGetBlockJobInfo">virDomainGetBlockJobInfo</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a> info, <br/>					 unsigned int flags);
int	<a href="#virDomainGetCPUStats">virDomainGetCPUStats</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 int start_cpu, <br/>					 unsigned int ncpus, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virDomainGetConnect">virDomainGetConnect</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom);
int	<a href="#virDomainGetControlInfo">virDomainGetControlInfo</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virDomainControlInfoPtr">virDomainControlInfoPtr</a> info, <br/>					 unsigned int flags);
int	<a href="#virDomainGetDiskErrors">virDomainGetDiskErrors</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt.html#virDomainDiskErrorPtr">virDomainDiskErrorPtr</a> errors, <br/>					 unsigned int maxerrors, <br/>					 unsigned int flags);
int	<a href="#virDomainGetEmulatorPinInfo">virDomainGetEmulatorPinInfo</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags);
char *	<a href="#virDomainGetHostname">virDomainGetHostname</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
unsigned int	<a href="#virDomainGetID">virDomainGetID</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetInfo">virDomainGetInfo</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virDomainInfoPtr">virDomainInfoPtr</a> info);
int	<a href="#virDomainGetInterfaceParameters">virDomainGetInterfaceParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainGetJobInfo">virDomainGetJobInfo</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virDomainJobInfoPtr">virDomainJobInfoPtr</a> info);
int	<a href="#virDomainGetJobStats">virDomainGetJobStats</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * type, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 unsigned int flags);
unsigned long	<a href="#virDomainGetMaxMemory">virDomainGetMaxMemory</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetMaxVcpus">virDomainGetMaxVcpus</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
char *	<a href="#virDomainGetMetadata">virDomainGetMetadata</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int type, <br/>					 const char * uri, <br/>					 unsigned int flags);
const char *	<a href="#virDomainGetName">virDomainGetName</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetNumaParameters">virDomainGetNumaParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
char *	<a href="#virDomainGetOSType">virDomainGetOSType</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetSchedulerParameters">virDomainGetSchedulerParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams);
int	<a href="#virDomainGetSchedulerParametersFlags">virDomainGetSchedulerParametersFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int * nparams, <br/>						 unsigned int flags);
char *	<a href="#virDomainGetSchedulerType">virDomainGetSchedulerType</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * nparams);
int	<a href="#virDomainGetSecurityLabel">virDomainGetSecurityLabel</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> seclabel);
int	<a href="#virDomainGetSecurityLabelList">virDomainGetSecurityLabelList</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> * seclabels);
int	<a href="#virDomainGetState">virDomainGetState</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * state, <br/>					 int * reason, <br/>					 unsigned int flags);
int	<a href="#virDomainGetUUID">virDomainGetUUID</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * uuid);
int	<a href="#virDomainGetUUIDString">virDomainGetUUIDString</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 char * buf);
int	<a href="#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int ncpumaps, <br/>					 unsigned char * cpumaps, <br/>					 int maplen, <br/>					 unsigned int flags);
int	<a href="#virDomainGetVcpus">virDomainGetVcpus</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virVcpuInfoPtr">virVcpuInfoPtr</a> info, <br/>					 int maxinfo, <br/>					 unsigned char * cpumaps, <br/>					 int maplen);
int	<a href="#virDomainGetVcpusFlags">virDomainGetVcpusFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
char *	<a href="#virDomainGetXMLDesc">virDomainGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainHasCurrentSnapshot">virDomainHasCurrentSnapshot</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainHasManagedSaveImage">virDomainHasManagedSaveImage</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags);
int	<a href="#virDomainInjectNMI">virDomainInjectNMI</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainInterfaceStats">virDomainInterfaceStats</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * path, <br/>					 <a href="libvirt-libvirt.html#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a> stats, <br/>					 size_t size);
int	<a href="#virDomainIsActive">virDomainIsActive</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom);
int	<a href="#virDomainIsPersistent">virDomainIsPersistent</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom);
int	<a href="#virDomainIsUpdated">virDomainIsUpdated</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom);
int	<a href="#virDomainListAllSnapshots">virDomainListAllSnapshots</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> ** snaps, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByID">virDomainLookupByID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int id);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByName">virDomainLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * name);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByUUID">virDomainLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByUUIDString">virDomainLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr);
int	<a href="#virDomainManagedSave">virDomainManagedSave</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags);
int	<a href="#virDomainManagedSaveRemove">virDomainManagedSaveRemove</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags);
int	<a href="#virDomainMemoryPeek">virDomainMemoryPeek</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned long long start, <br/>					 size_t size, <br/>					 void * buffer, <br/>					 unsigned int flags);
int	<a href="#virDomainMemoryStats">virDomainMemoryStats</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt.html#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a> stats, <br/>					 unsigned int nr_stats, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainMigrate">virDomainMigrate</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 const char * uri, <br/>					 unsigned long bandwidth);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainMigrate2">virDomainMigrate2</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 const char * dxml, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 const char * uri, <br/>					 unsigned long bandwidth);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainMigrate3">virDomainMigrate3</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateGetCompressionCache">virDomainMigrateGetCompressionCache</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 unsigned long long * cacheSize, <br/>						 unsigned int flags);
int	<a href="#virDomainMigrateGetMaxSpeed">virDomainMigrateGetMaxSpeed</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long * bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateSetCompressionCache">virDomainMigrateSetCompressionCache</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 unsigned long long cacheSize, <br/>						 unsigned int flags);
int	<a href="#virDomainMigrateSetMaxDowntime">virDomainMigrateSetMaxDowntime</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long long downtime, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateSetMaxSpeed">virDomainMigrateSetMaxSpeed</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateToURI">virDomainMigrateToURI</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * duri, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 unsigned long bandwidth);
int	<a href="#virDomainMigrateToURI2">virDomainMigrateToURI2</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dconnuri, <br/>					 const char * miguri, <br/>					 const char * dxml, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 unsigned long bandwidth);
int	<a href="#virDomainMigrateToURI3">virDomainMigrateToURI3</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dconnuri, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainOpenChannel">virDomainOpenChannel</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * name, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br/>					 unsigned int flags);
int	<a href="#virDomainOpenConsole">virDomainOpenConsole</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * dev_name, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br/>					 unsigned int flags);
int	<a href="#virDomainOpenGraphics">virDomainOpenGraphics</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int idx, <br/>					 int fd, <br/>					 unsigned int flags);
int	<a href="#virDomainPMSuspendForDuration">virDomainPMSuspendForDuration</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int target, <br/>					 unsigned long long duration, <br/>					 unsigned int flags);
int	<a href="#virDomainPMWakeup">virDomainPMWakeup</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags);
int	<a href="#virDomainPinEmulator">virDomainPinEmulator</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags);
int	<a href="#virDomainPinVcpu">virDomainPinVcpu</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int vcpu, <br/>					 unsigned char * cpumap, <br/>					 int maplen);
int	<a href="#virDomainPinVcpuFlags">virDomainPinVcpuFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int vcpu, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags);
int	<a href="#virDomainReboot">virDomainReboot</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainRef">virDomainRef</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainReset">virDomainReset</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainRestore">virDomainRestore</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * from);
int	<a href="#virDomainRestoreFlags">virDomainRestoreFlags</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * from, <br/>					 const char * dxml, <br/>					 unsigned int flags);
int	<a href="#virDomainResume">virDomainResume</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainRevertToSnapshot">virDomainRevertToSnapshot</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags);
int	<a href="#virDomainSave">virDomainSave</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to);
int	<a href="#virDomainSaveFlags">virDomainSaveFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 const char * dxml, <br/>					 unsigned int flags);
int	<a href="#virDomainSaveImageDefineXML">virDomainSaveImageDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * file, <br/>					 const char * dxml, <br/>					 unsigned int flags);
char *	<a href="#virDomainSaveImageGetXMLDesc">virDomainSaveImageGetXMLDesc</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * file, <br/>					 unsigned int flags);
char *	<a href="#virDomainScreenshot">virDomainScreenshot</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 unsigned int screen, <br/>					 unsigned int flags);
int	<a href="#virDomainSendKey">virDomainSendKey</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int codeset, <br/>					 unsigned int holdtime, <br/>					 unsigned int * keycodes, <br/>					 int nkeycodes, <br/>					 unsigned int flags);
int	<a href="#virDomainSendProcessSignal">virDomainSendProcessSignal</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 long long pid_value, <br/>					 unsigned int signum, <br/>					 unsigned int flags);
int	<a href="#virDomainSetAutostart">virDomainSetAutostart</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int autostart);
int	<a href="#virDomainSetBlkioParameters">virDomainSetBlkioParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetBlockIoTune">virDomainSetBlockIoTune</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetInterfaceParameters">virDomainSetInterfaceParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetMaxMemory">virDomainSetMaxMemory</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory);
int	<a href="#virDomainSetMemory">virDomainSetMemory</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory);
int	<a href="#virDomainSetMemoryFlags">virDomainSetMemoryFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory, <br/>					 unsigned int flags);
int	<a href="#virDomainSetMemoryParameters">virDomainSetMemoryParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetMemoryStatsPeriod">virDomainSetMemoryStatsPeriod</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int period, <br/>					 unsigned int flags);
int	<a href="#virDomainSetMetadata">virDomainSetMetadata</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int type, <br/>					 const char * metadata, <br/>					 const char * key, <br/>					 const char * uri, <br/>					 unsigned int flags);
int	<a href="#virDomainSetNumaParameters">virDomainSetNumaParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetSchedulerParameters">virDomainSetSchedulerParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams);
int	<a href="#virDomainSetSchedulerParametersFlags">virDomainSetSchedulerParametersFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int nparams, <br/>						 unsigned int flags);
int	<a href="#virDomainSetVcpus">virDomainSetVcpus</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nvcpus);
int	<a href="#virDomainSetVcpusFlags">virDomainSetVcpusFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nvcpus, <br/>					 unsigned int flags);
int	<a href="#virDomainShutdown">virDomainShutdown</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainShutdownFlags">virDomainShutdownFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	<a href="#virDomainSnapshotCreateXML">virDomainSnapshotCreateXML</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>							 const char * xmlDesc, <br/>							 unsigned int flags);
<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	<a href="#virDomainSnapshotCurrent">virDomainSnapshotCurrent</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>							 unsigned int flags);
int	<a href="#virDomainSnapshotDelete">virDomainSnapshotDelete</a>		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags);
int	<a href="#virDomainSnapshotFree">virDomainSnapshotFree</a>		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virDomainSnapshotGetConnect">virDomainSnapshotGetConnect</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot);
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainSnapshotGetDomain">virDomainSnapshotGetDomain</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot);
const char *	<a href="#virDomainSnapshotGetName">virDomainSnapshotGetName</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot);
<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	<a href="#virDomainSnapshotGetParent">virDomainSnapshotGetParent</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>							 unsigned int flags);
char *	<a href="#virDomainSnapshotGetXMLDesc">virDomainSnapshotGetXMLDesc</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags);
int	<a href="#virDomainSnapshotHasMetadata">virDomainSnapshotHasMetadata</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags);
int	<a href="#virDomainSnapshotIsCurrent">virDomainSnapshotIsCurrent</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags);
int	<a href="#virDomainSnapshotListAllChildren">virDomainSnapshotListAllChildren</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>						 <a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> ** snaps, <br/>						 unsigned int flags);
int	<a href="#virDomainSnapshotListChildrenNames">virDomainSnapshotListChildrenNames</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>						 char ** names, <br/>						 int nameslen, <br/>						 unsigned int flags);
int	<a href="#virDomainSnapshotListNames">virDomainSnapshotListNames</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 char ** names, <br/>					 int nameslen, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	<a href="#virDomainSnapshotLookupByName">virDomainSnapshotLookupByName</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>							 const char * name, <br/>							 unsigned int flags);
int	<a href="#virDomainSnapshotNum">virDomainSnapshotNum</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainSnapshotNumChildren">virDomainSnapshotNumChildren</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags);
int	<a href="#virDomainSnapshotRef">virDomainSnapshotRef</a>		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot);
int	<a href="#virDomainSuspend">virDomainSuspend</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainUndefine">virDomainUndefine</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainUndefineFlags">virDomainUndefineFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainUpdateDeviceFlags">virDomainUpdateDeviceFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags);
int	<a href="#virEventAddHandle">virEventAddHandle</a>		(int fd, <br/>					 int events, <br/>					 <a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff);
typedef int <a href="#virEventAddHandleFunc">virEventAddHandleFunc</a>		(int fd, <br/>					 int event, <br/>					 <a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff);
int	<a href="#virEventAddTimeout">virEventAddTimeout</a>		(int timeout, <br/>					 <a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff);
typedef int <a href="#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a>		(int timeout, <br/>					 <a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff);
typedef void <a href="#virEventHandleCallback">virEventHandleCallback</a>		(int watch, <br/>					 int fd, <br/>					 int events, <br/>					 void * opaque);
int	<a href="#virEventRegisterDefaultImpl">virEventRegisterDefaultImpl</a>	(void);
void	<a href="#virEventRegisterImpl">virEventRegisterImpl</a>		(<a href="libvirt-libvirt.html#virEventAddHandleFunc">virEventAddHandleFunc</a> addHandle, <br/>					 <a href="libvirt-libvirt.html#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a> updateHandle, <br/>					 <a href="libvirt-libvirt.html#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a> removeHandle, <br/>					 <a href="libvirt-libvirt.html#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a> addTimeout, <br/>					 <a href="libvirt-libvirt.html#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a> updateTimeout, <br/>					 <a href="libvirt-libvirt.html#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a> removeTimeout);
int	<a href="#virEventRemoveHandle">virEventRemoveHandle</a>		(int watch);
typedef int <a href="#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a>	(int watch);
int	<a href="#virEventRemoveTimeout">virEventRemoveTimeout</a>		(int timer);
typedef int <a href="#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a>	(int timer);
int	<a href="#virEventRunDefaultImpl">virEventRunDefaultImpl</a>		(void);
typedef void <a href="#virEventTimeoutCallback">virEventTimeoutCallback</a>		(int timer, <br/>					 void * opaque);
void	<a href="#virEventUpdateHandle">virEventUpdateHandle</a>		(int watch, <br/>					 int events);
typedef void <a href="#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a>	(int watch, <br/>					 int event);
void	<a href="#virEventUpdateTimeout">virEventUpdateTimeout</a>		(int timer, <br/>					 int timeout);
typedef void <a href="#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a>	(int timer, <br/>					 int timeout);
typedef void <a href="#virFreeCallback">virFreeCallback</a>			(void * opaque);
int	<a href="#virGetVersion">virGetVersion</a>			(unsigned long * libVer, <br/>					 const char * type, <br/>					 unsigned long * typeVer);
int	<a href="#virInitialize">virInitialize</a>			(void);
int	<a href="#virInterfaceChangeBegin">virInterfaceChangeBegin</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags);
int	<a href="#virInterfaceChangeCommit">virInterfaceChangeCommit</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags);
int	<a href="#virInterfaceChangeRollback">virInterfaceChangeRollback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags);
int	<a href="#virInterfaceCreate">virInterfaceCreate</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	<a href="#virInterfaceDefineXML">virInterfaceDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml, <br/>					 unsigned int flags);
int	<a href="#virInterfaceDestroy">virInterfaceDestroy</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br/>					 unsigned int flags);
int	<a href="#virInterfaceFree">virInterfaceFree</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virInterfaceGetConnect">virInterfaceGetConnect</a>	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface);
const char *	<a href="#virInterfaceGetMACString">virInterfaceGetMACString</a>	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface);
const char *	<a href="#virInterfaceGetName">virInterfaceGetName</a>	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface);
char *	<a href="#virInterfaceGetXMLDesc">virInterfaceGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br/>					 unsigned int flags);
int	<a href="#virInterfaceIsActive">virInterfaceIsActive</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface);
<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	<a href="#virInterfaceLookupByMACString">virInterfaceLookupByMACString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * macstr);
<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	<a href="#virInterfaceLookupByName">virInterfaceLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * name);
int	<a href="#virInterfaceRef">virInterfaceRef</a>			(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface);
int	<a href="#virInterfaceUndefine">virInterfaceUndefine</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface);
<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	<a href="#virNWFilterDefineXML">virNWFilterDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc);
int	<a href="#virNWFilterFree">virNWFilterFree</a>			(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter);
const char *	<a href="#virNWFilterGetName">virNWFilterGetName</a>	(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter);
int	<a href="#virNWFilterGetUUID">virNWFilterGetUUID</a>		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br/>					 unsigned char * uuid);
int	<a href="#virNWFilterGetUUIDString">virNWFilterGetUUIDString</a>	(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br/>					 char * buf);
char *	<a href="#virNWFilterGetXMLDesc">virNWFilterGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	<a href="#virNWFilterLookupByName">virNWFilterLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * name);
<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	<a href="#virNWFilterLookupByUUID">virNWFilterLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid);
<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	<a href="#virNWFilterLookupByUUIDString">virNWFilterLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr);
int	<a href="#virNWFilterRef">virNWFilterRef</a>			(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter);
int	<a href="#virNWFilterUndefine">virNWFilterUndefine</a>		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter);
int	<a href="#virNetworkCreate">virNetworkCreate</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network);
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkCreateXML">virNetworkCreateXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc);
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkDefineXML">virNetworkDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml);
int	<a href="#virNetworkDestroy">virNetworkDestroy</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network);
int	<a href="#virNetworkFree">virNetworkFree</a>			(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network);
int	<a href="#virNetworkGetAutostart">virNetworkGetAutostart</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 int * autostart);
char *	<a href="#virNetworkGetBridgeName">virNetworkGetBridgeName</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virNetworkGetConnect">virNetworkGetConnect</a>	(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net);
const char *	<a href="#virNetworkGetName">virNetworkGetName</a>	(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network);
int	<a href="#virNetworkGetUUID">virNetworkGetUUID</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 unsigned char * uuid);
int	<a href="#virNetworkGetUUIDString">virNetworkGetUUIDString</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 char * buf);
char *	<a href="#virNetworkGetXMLDesc">virNetworkGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 unsigned int flags);
int	<a href="#virNetworkIsActive">virNetworkIsActive</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net);
int	<a href="#virNetworkIsPersistent">virNetworkIsPersistent</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net);
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkLookupByName">virNetworkLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * name);
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkLookupByUUID">virNetworkLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid);
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkLookupByUUIDString">virNetworkLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr);
int	<a href="#virNetworkRef">virNetworkRef</a>			(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network);
int	<a href="#virNetworkSetAutostart">virNetworkSetAutostart</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 int autostart);
int	<a href="#virNetworkUndefine">virNetworkUndefine</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network);
int	<a href="#virNetworkUpdate">virNetworkUpdate</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 unsigned int command, <br/>					 unsigned int section, <br/>					 int parentIndex, <br/>					 const char * xml, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	<a href="#virNodeDeviceCreateXML">virNodeDeviceCreateXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int flags);
int	<a href="#virNodeDeviceDestroy">virNodeDeviceDestroy</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceDetachFlags">virNodeDeviceDetachFlags</a>	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 const char * driverName, <br/>					 unsigned int flags);
int	<a href="#virNodeDeviceDettach">virNodeDeviceDettach</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceFree">virNodeDeviceFree</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
const char *	<a href="#virNodeDeviceGetName">virNodeDeviceGetName</a>	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
const char *	<a href="#virNodeDeviceGetParent">virNodeDeviceGetParent</a>	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
char *	<a href="#virNodeDeviceGetXMLDesc">virNodeDeviceGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 unsigned int flags);
int	<a href="#virNodeDeviceListCaps">virNodeDeviceListCaps</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 char ** const names, <br/>					 int maxnames);
<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	<a href="#virNodeDeviceLookupByName">virNodeDeviceLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * name);
<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	<a href="#virNodeDeviceLookupSCSIHostByWWN">virNodeDeviceLookupSCSIHostByWWN</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * wwnn, <br/>							 const char * wwpn, <br/>							 unsigned int flags);
int	<a href="#virNodeDeviceNumOfCaps">virNodeDeviceNumOfCaps</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceReAttach">virNodeDeviceReAttach</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceRef">virNodeDeviceRef</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceReset">virNodeDeviceReset</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeGetCPUMap">virNodeGetCPUMap</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned char ** cpumap, <br/>					 unsigned int * online, <br/>					 unsigned int flags);
int	<a href="#virNodeGetCPUStats">virNodeGetCPUStats</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int cpuNum, <br/>					 <a href="libvirt-libvirt.html#virNodeCPUStatsPtr">virNodeCPUStatsPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virNodeGetCellsFreeMemory">virNodeGetCellsFreeMemory</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned long long * freeMems, <br/>					 int startCell, <br/>					 int maxCells);
unsigned long long	<a href="#virNodeGetFreeMemory">virNodeGetFreeMemory</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virNodeGetInfo">virNodeGetInfo</a>			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virNodeInfoPtr">virNodeInfoPtr</a> info);
int	<a href="#virNodeGetMemoryParameters">virNodeGetMemoryParameters</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virNodeGetMemoryStats">virNodeGetMemoryStats</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int cellNum, <br/>					 <a href="libvirt-libvirt.html#virNodeMemoryStatsPtr">virNodeMemoryStatsPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virNodeGetSecurityModel">virNodeGetSecurityModel</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virSecurityModelPtr">virSecurityModelPtr</a> secmodel);
int	<a href="#virNodeListDevices">virNodeListDevices</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * cap, <br/>					 char ** const names, <br/>					 int maxnames, <br/>					 unsigned int flags);
int	<a href="#virNodeNumOfDevices">virNodeNumOfDevices</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * cap, <br/>					 unsigned int flags);
int	<a href="#virNodeSetMemoryParameters">virNodeSetMemoryParameters</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virNodeSuspendForDuration">virNodeSuspendForDuration</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int target, <br/>					 unsigned long long duration, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	<a href="#virSecretDefineXML">virSecretDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml, <br/>					 unsigned int flags);
int	<a href="#virSecretFree">virSecretFree</a>			(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virSecretGetConnect">virSecretGetConnect</a>	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret);
int	<a href="#virSecretGetUUID">virSecretGetUUID</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 unsigned char * uuid);
int	<a href="#virSecretGetUUIDString">virSecretGetUUIDString</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 char * buf);
const char *	<a href="#virSecretGetUsageID">virSecretGetUsageID</a>	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret);
int	<a href="#virSecretGetUsageType">virSecretGetUsageType</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret);
unsigned char *	<a href="#virSecretGetValue">virSecretGetValue</a>	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 size_t * value_size, <br/>					 unsigned int flags);
char *	<a href="#virSecretGetXMLDesc">virSecretGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	<a href="#virSecretLookupByUUID">virSecretLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid);
<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	<a href="#virSecretLookupByUUIDString">virSecretLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr);
<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	<a href="#virSecretLookupByUsage">virSecretLookupByUsage</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int usageType, <br/>					 const char * usageID);
int	<a href="#virSecretRef">virSecretRef</a>			(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret);
int	<a href="#virSecretSetValue">virSecretSetValue</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 const unsigned char * value, <br/>					 size_t value_size, <br/>					 unsigned int flags);
int	<a href="#virSecretUndefine">virSecretUndefine</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret);
int	<a href="#virStoragePoolBuild">virStoragePoolBuild</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags);
int	<a href="#virStoragePoolCreate">virStoragePoolCreate</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolCreateXML">virStoragePoolCreateXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int flags);
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolDefineXML">virStoragePoolDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xml, <br/>						 unsigned int flags);
int	<a href="#virStoragePoolDelete">virStoragePoolDelete</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags);
int	<a href="#virStoragePoolDestroy">virStoragePoolDestroy</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
int	<a href="#virStoragePoolFree">virStoragePoolFree</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
int	<a href="#virStoragePoolGetAutostart">virStoragePoolGetAutostart</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 int * autostart);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virStoragePoolGetConnect">virStoragePoolGetConnect</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
int	<a href="#virStoragePoolGetInfo">virStoragePoolGetInfo</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 <a href="libvirt-libvirt.html#virStoragePoolInfoPtr">virStoragePoolInfoPtr</a> info);
const char *	<a href="#virStoragePoolGetName">virStoragePoolGetName</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
int	<a href="#virStoragePoolGetUUID">virStoragePoolGetUUID</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned char * uuid);
int	<a href="#virStoragePoolGetUUIDString">virStoragePoolGetUUIDString</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 char * buf);
char *	<a href="#virStoragePoolGetXMLDesc">virStoragePoolGetXMLDesc</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags);
int	<a href="#virStoragePoolIsActive">virStoragePoolIsActive</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
int	<a href="#virStoragePoolIsPersistent">virStoragePoolIsPersistent</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
int	<a href="#virStoragePoolListAllVolumes">virStoragePoolListAllVolumes</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 <a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> ** vols, <br/>					 unsigned int flags);
int	<a href="#virStoragePoolListVolumes">virStoragePoolListVolumes</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 char ** const names, <br/>					 int maxnames);
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolLookupByName">virStoragePoolLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * name);
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolLookupByUUID">virStoragePoolLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const unsigned char * uuid);
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolLookupByUUIDString">virStoragePoolLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * uuidstr);
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolLookupByVolume">virStoragePoolLookupByVolume</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol);
int	<a href="#virStoragePoolNumOfVolumes">virStoragePoolNumOfVolumes</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
int	<a href="#virStoragePoolRef">virStoragePoolRef</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
int	<a href="#virStoragePoolRefresh">virStoragePoolRefresh</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags);
int	<a href="#virStoragePoolSetAutostart">virStoragePoolSetAutostart</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 int autostart);
int	<a href="#virStoragePoolUndefine">virStoragePoolUndefine</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool);
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolCreateXML">virStorageVolCreateXML</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>						 const char * xmlDesc, <br/>						 unsigned int flags);
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolCreateXMLFrom">virStorageVolCreateXMLFrom</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>							 const char * xmlDesc, <br/>							 <a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> clonevol, <br/>							 unsigned int flags);
int	<a href="#virStorageVolDelete">virStorageVolDelete</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned int flags);
int	<a href="#virStorageVolDownload">virStorageVolDownload</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 unsigned long long offset, <br/>					 unsigned long long length, <br/>					 unsigned int flags);
int	<a href="#virStorageVolFree">virStorageVolFree</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol);
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virStorageVolGetConnect">virStorageVolGetConnect</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol);
int	<a href="#virStorageVolGetInfo">virStorageVolGetInfo</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 <a href="libvirt-libvirt.html#virStorageVolInfoPtr">virStorageVolInfoPtr</a> info);
const char *	<a href="#virStorageVolGetKey">virStorageVolGetKey</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol);
const char *	<a href="#virStorageVolGetName">virStorageVolGetName</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol);
char *	<a href="#virStorageVolGetPath">virStorageVolGetPath</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol);
char *	<a href="#virStorageVolGetXMLDesc">virStorageVolGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned int flags);
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolLookupByKey">virStorageVolLookupByKey</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * key);
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolLookupByName">virStorageVolLookupByName</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>							 const char * name);
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolLookupByPath">virStorageVolLookupByPath</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * path);
int	<a href="#virStorageVolRef">virStorageVolRef</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol);
int	<a href="#virStorageVolResize">virStorageVolResize</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned long long capacity, <br/>					 unsigned int flags);
int	<a href="#virStorageVolUpload">virStorageVolUpload</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 unsigned long long offset, <br/>					 unsigned long long length, <br/>					 unsigned int flags);
int	<a href="#virStorageVolWipe">virStorageVolWipe</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned int flags);
int	<a href="#virStorageVolWipePattern">virStorageVolWipePattern</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned int algorithm, <br/>					 unsigned int flags);
int	<a href="#virStreamAbort">virStreamAbort</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream);
int	<a href="#virStreamEventAddCallback">virStreamEventAddCallback</a>	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events, <br/>					 <a href="libvirt-libvirt.html#virStreamEventCallback">virStreamEventCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff);
typedef void <a href="#virStreamEventCallback">virStreamEventCallback</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events, <br/>					 void * opaque);
int	<a href="#virStreamEventRemoveCallback">virStreamEventRemoveCallback</a>	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream);
int	<a href="#virStreamEventUpdateCallback">virStreamEventUpdateCallback</a>	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events);
int	<a href="#virStreamFinish">virStreamFinish</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream);
int	<a href="#virStreamFree">virStreamFree</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream);
<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a>	<a href="#virStreamNew">virStreamNew</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags);
int	<a href="#virStreamRecv">virStreamRecv</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 char * data, <br/>					 size_t nbytes);
int	<a href="#virStreamRecvAll">virStreamRecvAll</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a> handler, <br/>					 void * opaque);
int	<a href="#virStreamRef">virStreamRef</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream);
int	<a href="#virStreamSend">virStreamSend</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 const char * data, <br/>					 size_t nbytes);
int	<a href="#virStreamSendAll">virStreamSendAll</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a> handler, <br/>					 void * opaque);
typedef int <a href="#virStreamSinkFunc">virStreamSinkFunc</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br/>					 const char * data, <br/>					 size_t nbytes, <br/>					 void * opaque);
typedef int <a href="#virStreamSourceFunc">virStreamSourceFunc</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br/>					 char * data, <br/>					 size_t nbytes, <br/>					 void * opaque);
int	<a href="#virTypedParamsAddBoolean">virTypedParamsAddBoolean</a>	(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 int value);
int	<a href="#virTypedParamsAddDouble">virTypedParamsAddDouble</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 double value);
int	<a href="#virTypedParamsAddFromString">virTypedParamsAddFromString</a>	(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 int type, <br/>					 const char * value);
int	<a href="#virTypedParamsAddInt">virTypedParamsAddInt</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 int value);
int	<a href="#virTypedParamsAddLLong">virTypedParamsAddLLong</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 long long value);
int	<a href="#virTypedParamsAddString">virTypedParamsAddString</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 const char * value);
int	<a href="#virTypedParamsAddUInt">virTypedParamsAddUInt</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 unsigned int value);
int	<a href="#virTypedParamsAddULLong">virTypedParamsAddULLong</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 unsigned long long value);
void	<a href="#virTypedParamsClear">virTypedParamsClear</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams);
void	<a href="#virTypedParamsFree">virTypedParamsFree</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams);
<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a>	<a href="#virTypedParamsGet">virTypedParamsGet</a>	(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int nparams, <br/>						 const char * name);
int	<a href="#virTypedParamsGetBoolean">virTypedParamsGetBoolean</a>	(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 int * value);
int	<a href="#virTypedParamsGetDouble">virTypedParamsGetDouble</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 double * value);
int	<a href="#virTypedParamsGetInt">virTypedParamsGetInt</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 int * value);
int	<a href="#virTypedParamsGetLLong">virTypedParamsGetLLong</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 long long * value);
int	<a href="#virTypedParamsGetString">virTypedParamsGetString</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 const char ** value);
int	<a href="#virTypedParamsGetUInt">virTypedParamsGetUInt</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 unsigned int * value);
int	<a href="#virTypedParamsGetULLong">virTypedParamsGetULLong</a>		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 unsigned long long * value);
</pre>
    </div>
    <div class="refsect1" lang="en">
      <h2>Description</h2>
    </div>
    <div class="refsect1" lang="en">
      <h2>Details</h2>
      <div class="refsect2" lang="en">
        <div class="refsect2" lang="en"><h3><a name="LIBVIR_CHECK_VERSION">Macro </a>LIBVIR_CHECK_VERSION</h3><pre class="programlisting">#define <a href="#LIBVIR_CHECK_VERSION">LIBVIR_CHECK_VERSION</a>(major, minor, micro);
</pre><p>Macro for developers to easily check what version of the library their code is compiling against. e.g. #if LIBVIR_CHECK_VERSION(1,1,3) // some code that only works in 1.1.3 and newer #endif</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>major</tt></i>:</span></td><td>major component of the version number</td></tr><tr><td><span class="term"><i><tt>minor</tt></i>:</span></td><td>minor component of the version number</td></tr><tr><td><span class="term"><i><tt>micro</tt></i>:</span></td><td>micro component of the version number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="LIBVIR_VERSION_NUMBER">Macro </a>LIBVIR_VERSION_NUMBER</h3><pre class="programlisting">#define <a href="#LIBVIR_VERSION_NUMBER">LIBVIR_VERSION_NUMBER</a>;
</pre><p>Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_COPY_CPUMAP">Macro </a>VIR_COPY_CPUMAP</h3><pre class="programlisting">#define <a href="#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a>(cpumaps, maplen, vcpu, cpumap);
</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. <a href="libvirt-libvirt.html#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a> macro extracts the cpumap of the specified vcpu from cpumaps array and copies it into cpumap to be used later by virDomainPinVcpu() API.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to an array of cpumap (in 8-bit bytes) (IN)</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the length (in bytes) of one cpumap</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>the virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a cpumap (in 8-bit bytes) (OUT) This cpumap must be previously allocated by the caller (ie: malloc(maplen))</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_CPU_MAPLEN">Macro </a>VIR_CPU_MAPLEN</h3><pre class="programlisting">#define <a href="#VIR_CPU_MAPLEN">VIR_CPU_MAPLEN</a>(cpu);
</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual &amp; all physical CPUs of a domain.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>number of physical CPUs</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_CPU_USABLE">Macro </a>VIR_CPU_USABLE</h3><pre class="programlisting">#define <a href="#VIR_CPU_USABLE">VIR_CPU_USABLE</a>(cpumaps, maplen, vcpu, cpu);
</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() API. <a href="libvirt-libvirt.html#VIR_CPU_USABLE">VIR_CPU_USABLE</a> macro returns a non-zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to an array of cpumap (in 8-bit bytes) (IN)</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the length (in bytes) of one cpumap</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>the virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>the physical CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_CPU_USED">Macro </a>VIR_CPU_USED</h3><pre class="programlisting">#define <a href="#VIR_CPU_USED">VIR_CPU_USED</a>(cpumap, cpu);
</pre><p>This macro can be used in conjunction with virNodeGetCPUMap() API. It returns non-zero if the bit of the related CPU is set.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN)</td></tr><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>the physical CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_AVERAGE">Macro </a>VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_AVERAGE">VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</a>;
</pre><p>Macro represents the inbound average of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_BURST">Macro </a>VIR_DOMAIN_BANDWIDTH_IN_BURST</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_BURST">VIR_DOMAIN_BANDWIDTH_IN_BURST</a>;
</pre><p>Macro represents the inbound burst of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_PEAK">Macro </a>VIR_DOMAIN_BANDWIDTH_IN_PEAK</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_PEAK">VIR_DOMAIN_BANDWIDTH_IN_PEAK</a>;
</pre><p>Macro represents the inbound peak of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE">Macro </a>VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE">VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</a>;
</pre><p>Macro represents the outbound average of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_BURST">Macro </a>VIR_DOMAIN_BANDWIDTH_OUT_BURST</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_BURST">VIR_DOMAIN_BANDWIDTH_OUT_BURST</a>;
</pre><p>Macro represents the outbound burst of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_PEAK">Macro </a>VIR_DOMAIN_BANDWIDTH_OUT_PEAK</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_PEAK">VIR_DOMAIN_BANDWIDTH_OUT_PEAK</a>;
</pre><p>Macro represents the outbound peak of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_DEVICE_WEIGHT">Macro </a>VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_WEIGHT">VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</a>;
</pre><p>Macro for the blkio tunable weight_device: it represents the per-device weight, as a string. The string is parsed as a series of /path/to/device,weight elements, separated by ','.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_FIELD_LENGTH">Macro </a>VIR_DOMAIN_BLKIO_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_FIELD_LENGTH">VIR_DOMAIN_BLKIO_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of virBlkioParameter. Provided for backwards compatibility; <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_WEIGHT">Macro </a>VIR_DOMAIN_BLKIO_WEIGHT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_WEIGHT">VIR_DOMAIN_BLKIO_WEIGHT</a>;
</pre><p>Macro for the Blkio tunable weight: it represents the io weight the guest can use, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the read bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the read I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the total bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the total I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the write bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the write I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_ERRS">Macro </a>VIR_DOMAIN_BLOCK_STATS_ERRS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_ERRS">VIR_DOMAIN_BLOCK_STATS_ERRS</a>;
</pre><p>In Xen this returns the mysterious 'oo_req', as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH">Macro </a>VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH">VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of parameter names when using virDomainBlockStatsFlags().</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ">Macro </a>VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ">VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</a>;
</pre><p>Macro represents the total flush requests of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES">Macro </a>VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</a>;
</pre><p>Macro represents the total time spend on cache flushing in nano-seconds of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_BYTES">Macro </a>VIR_DOMAIN_BLOCK_STATS_READ_BYTES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_BYTES">VIR_DOMAIN_BLOCK_STATS_READ_BYTES</a>;
</pre><p>Macro represents the total number of read bytes of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_REQ">Macro </a>VIR_DOMAIN_BLOCK_STATS_READ_REQ</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_REQ">VIR_DOMAIN_BLOCK_STATS_READ_REQ</a>;
</pre><p>Macro represents the total read requests of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES">Macro </a>VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</a>;
</pre><p>Macro represents the total time spend on cache reads in nano-seconds of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES">Macro </a>VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES">VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</a>;
</pre><p>Macro represents the total number of write bytes of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_REQ">Macro </a>VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_REQ">VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</a>;
</pre><p>Macro represents the total write requests of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES">Macro </a>VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</a>;
</pre><p>Macro represents the total time spend on cache writes in nano-seconds of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_CPU_STATS_CPUTIME">Macro </a>VIR_DOMAIN_CPU_STATS_CPUTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_CPU_STATS_CPUTIME">VIR_DOMAIN_CPU_STATS_CPUTIME</a>;
</pre><p>cpu usage (sum of both vcpu and hypervisor usage) in nanoseconds, as a ullong</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_CPU_STATS_SYSTEMTIME">Macro </a>VIR_DOMAIN_CPU_STATS_SYSTEMTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_CPU_STATS_SYSTEMTIME">VIR_DOMAIN_CPU_STATS_SYSTEMTIME</a>;
</pre><p>cpu time charged to system instructions in nanoseconds, as a ullong</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_CPU_STATS_USERTIME">Macro </a>VIR_DOMAIN_CPU_STATS_USERTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_CPU_STATS_USERTIME">VIR_DOMAIN_CPU_STATS_USERTIME</a>;
</pre><p>cpu time charged to user instructions in nanoseconds, as a ullong</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_CPU_STATS_VCPUTIME">Macro </a>VIR_DOMAIN_CPU_STATS_VCPUTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_CPU_STATS_VCPUTIME">VIR_DOMAIN_CPU_STATS_VCPUTIME</a>;
</pre><p>vcpu usage in nanoseconds (cpu_time excluding hypervisor time), as a ullong</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_EVENT_CALLBACK">Macro </a>VIR_DOMAIN_EVENT_CALLBACK</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_EVENT_CALLBACK">VIR_DOMAIN_EVENT_CALLBACK</a>;
</pre><p>Used to cast the event specific callback into the generic one for use for virDomainEventRegister</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_BYTES">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_BYTES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_BYTES">VIR_DOMAIN_JOB_COMPRESSION_BYTES</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of compressed bytes transferred since the beginning of migration, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_CACHE">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_CACHE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE">VIR_DOMAIN_JOB_COMPRESSION_CACHE</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: size of the cache (in bytes) used for compressing repeatedly transferred memory pages during live migration, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES">VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of repeatedly changing pages that were not found in compression cache and thus could not be compressed, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW">VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of repeatedly changing pages that were found in compression cache but were sent uncompressed because the result of compression was larger than the original page as a whole, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_PAGES">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_PAGES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_PAGES">VIR_DOMAIN_JOB_COMPRESSION_PAGES</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of compressed pages transferred since the beginning of migration, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DATA_PROCESSED">Macro </a>VIR_DOMAIN_JOB_DATA_PROCESSED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes transferred from the beginning of the job, as VIR_TYPED_PARAM_ULLONG. This field corresponds to dataProcessed field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DATA_REMAINING">Macro </a>VIR_DOMAIN_JOB_DATA_REMAINING</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes that still need to be transferred, as VIR_TYPED_PARAM_ULLONG. This field corresponds to dataRemaining field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DATA_TOTAL">Macro </a>VIR_DOMAIN_JOB_DATA_TOTAL</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: total number of bytes supposed to be transferred, as VIR_TYPED_PARAM_ULLONG. For <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_UNBOUNDED">VIR_DOMAIN_JOB_UNBOUNDED</a> jobs, this may be less than the sum of <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> in the event that the hypervisor has to repeat some data, e.g., due to dirtied pages during migration. For <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> jobs, <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> shall always equal <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> + VIR_DOMAIN_JOB_DATA_REMAINING. This field corresponds to dataTotal field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DISK_PROCESSED">Macro </a>VIR_DOMAIN_JOB_DISK_PROCESSED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DISK_PROCESSED">VIR_DOMAIN_JOB_DISK_PROCESSED</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to fileProcessed field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DISK_REMAINING">Macro </a>VIR_DOMAIN_JOB_DISK_REMAINING</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DISK_REMAINING">VIR_DOMAIN_JOB_DISK_REMAINING</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to fileRemaining field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DISK_TOTAL">Macro </a>VIR_DOMAIN_JOB_DISK_TOTAL</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DISK_TOTAL">VIR_DOMAIN_JOB_DISK_TOTAL</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to fileTotal field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DOWNTIME">Macro </a>VIR_DOMAIN_JOB_DOWNTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DOWNTIME">VIR_DOMAIN_JOB_DOWNTIME</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: downtime (ms) that is expected to happen during migration, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_CONSTANT">Macro </a>VIR_DOMAIN_JOB_MEMORY_CONSTANT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_CONSTANT">VIR_DOMAIN_JOB_MEMORY_CONSTANT</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of pages filled with a constant byte (all bytes in a single page are identical) transferred since the beginning of the migration job, as VIR_TYPED_PARAM_ULLONG. The most common example of such pages are zero pages, i.e., pages filled with zero bytes.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_NORMAL">Macro </a>VIR_DOMAIN_JOB_MEMORY_NORMAL</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL">VIR_DOMAIN_JOB_MEMORY_NORMAL</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of pages that were transferred without any kind of compression (i.e., pages which were not filled with a constant byte and which could not be compressed) transferred since the beginning of the migration job, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES">Macro </a>VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES">VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes transferred as normal pages, as VIR_TYPED_PARAM_ULLONG. See <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_MEMORY_NORMAL">VIR_DOMAIN_JOB_MEMORY_NORMAL</a> for more details.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_PROCESSED">Macro </a>VIR_DOMAIN_JOB_MEMORY_PROCESSED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_PROCESSED">VIR_DOMAIN_JOB_MEMORY_PROCESSED</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to memProcessed field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_REMAINING">Macro </a>VIR_DOMAIN_JOB_MEMORY_REMAINING</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_REMAINING">VIR_DOMAIN_JOB_MEMORY_REMAINING</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to memRemaining field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_TOTAL">Macro </a>VIR_DOMAIN_JOB_MEMORY_TOTAL</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_TOTAL">VIR_DOMAIN_JOB_MEMORY_TOTAL</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to memTotal field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_TIME_ELAPSED">Macro </a>VIR_DOMAIN_JOB_TIME_ELAPSED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_TIME_ELAPSED">VIR_DOMAIN_JOB_TIME_ELAPSED</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: time (ms) since the beginning of the job, as VIR_TYPED_PARAM_ULLONG. This field corresponds to timeElapsed field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_TIME_REMAINING">Macro </a>VIR_DOMAIN_JOB_TIME_REMAINING</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_TIME_REMAINING">VIR_DOMAIN_JOB_TIME_REMAINING</a>;
</pre><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: remaining time (ms) for <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> jobs, as VIR_TYPED_PARAM_ULLONG. This field corresponds to timeRemaining field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_FIELD_LENGTH">Macro </a>VIR_DOMAIN_MEMORY_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_FIELD_LENGTH">VIR_DOMAIN_MEMORY_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of virMemoryParameter. Provided for backwards compatibility; <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_HARD_LIMIT">Macro </a>VIR_DOMAIN_MEMORY_HARD_LIMIT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_HARD_LIMIT">VIR_DOMAIN_MEMORY_HARD_LIMIT</a>;
</pre><p>Macro for the memory tunable hard_limit: it represents the maximum memory the guest can use, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_MIN_GUARANTEE">Macro </a>VIR_DOMAIN_MEMORY_MIN_GUARANTEE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_MIN_GUARANTEE">VIR_DOMAIN_MEMORY_MIN_GUARANTEE</a>;
</pre><p>Macro for the memory tunable min_guarantee: it represents the minimum memory guaranteed to be reserved for the guest, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_PARAM_UNLIMITED">Macro </a>VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_PARAM_UNLIMITED">VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</a>;
</pre><p>Macro providing the <a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a> value that indicates "unlimited"</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_SOFT_LIMIT">Macro </a>VIR_DOMAIN_MEMORY_SOFT_LIMIT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_SOFT_LIMIT">VIR_DOMAIN_MEMORY_SOFT_LIMIT</a>;
</pre><p>Macro for the memory tunable soft_limit: it represents the memory upper limit enforced during memory contention, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT">Macro </a>VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT">VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</a>;
</pre><p>Macro for the swap tunable swap_hard_limit: it represents the maximum swap plus memory the guest can use, as a ullong. This limit has to be more than VIR_DOMAIN_MEMORY_HARD_LIMIT.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_NUMA_MODE">Macro </a>VIR_DOMAIN_NUMA_MODE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_NUMA_MODE">VIR_DOMAIN_NUMA_MODE</a>;
</pre><p>Macro for typed parameter name that lists the numa mode of a domain, as an int containing a <a href="libvirt-libvirt.html#virDomainNumatuneMemMode">virDomainNumatuneMemMode</a> value.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_NUMA_NODESET">Macro </a>VIR_DOMAIN_NUMA_NODESET</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_NUMA_NODESET">VIR_DOMAIN_NUMA_NODESET</a>;
</pre><p>Macro for typed parameter name that lists the numa nodeset of a domain, as a string.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_CAP">Macro </a>VIR_DOMAIN_SCHEDULER_CAP</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_CAP">VIR_DOMAIN_SCHEDULER_CAP</a>;
</pre><p>Macro represents the maximum scheduler cap, when using the credit scheduler, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_CPU_SHARES">Macro </a>VIR_DOMAIN_SCHEDULER_CPU_SHARES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_CPU_SHARES">VIR_DOMAIN_SCHEDULER_CPU_SHARES</a>;
</pre><p>Macro represents proportional weight of the scheduler used on the host cpu, when using the posix scheduler, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD">Macro </a>VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD">VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota in microseconds, when using the posix scheduler, for all emulator activity not tied to vcpus, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA">Macro </a>VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA">VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for all emulator activity not tied to vcpus, when using the posix scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_LIMIT">Macro </a>VIR_DOMAIN_SCHEDULER_LIMIT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_LIMIT">VIR_DOMAIN_SCHEDULER_LIMIT</a>;
</pre><p>Macro represents the scheduler limit value, when using the allocation scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_RESERVATION">Macro </a>VIR_DOMAIN_SCHEDULER_RESERVATION</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_RESERVATION">VIR_DOMAIN_SCHEDULER_RESERVATION</a>;
</pre><p>Macro represents the scheduler reservation value, when using the allocation scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_SHARES">Macro </a>VIR_DOMAIN_SCHEDULER_SHARES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_SHARES">VIR_DOMAIN_SCHEDULER_SHARES</a>;
</pre><p>Macro represents the scheduler shares value, when using the allocation scheduler, as an int.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_VCPU_PERIOD">Macro </a>VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_VCPU_PERIOD">VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota, in microseconds, for vcpus only, when using the posix scheduler, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_VCPU_QUOTA">Macro </a>VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_VCPU_QUOTA">VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for vcpus only, when using the posix scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_WEIGHT">Macro </a>VIR_DOMAIN_SCHEDULER_WEIGHT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_WEIGHT">VIR_DOMAIN_SCHEDULER_WEIGHT</a>;
</pre><p>Macro represents the relative weight, when using the credit scheduler, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHED_FIELD_LENGTH">Macro </a>VIR_DOMAIN_SCHED_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHED_FIELD_LENGTH">VIR_DOMAIN_SCHED_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of virSchedParameter. Provided for backwards compatibility; <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SEND_KEY_MAX_KEYS">Macro </a>VIR_DOMAIN_SEND_KEY_MAX_KEYS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SEND_KEY_MAX_KEYS">VIR_DOMAIN_SEND_KEY_MAX_KEYS</a>;
</pre><p>Maximum number of keycodes that can be sent in one virDomainSendKey() call.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_GET_CPUMAP">Macro </a>VIR_GET_CPUMAP</h3><pre class="programlisting">#define <a href="#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a>(cpumaps, maplen, vcpu);
</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. <a href="libvirt-libvirt.html#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a> macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to an array of cpumap (in 8-bit bytes) (IN)</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the length (in bytes) of one cpumap</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>the virtual CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_BANDWIDTH">Macro </a>VIR_MIGRATE_PARAM_BANDWIDTH</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_BANDWIDTH">VIR_MIGRATE_PARAM_BANDWIDTH</a>;
</pre><p>virDomainMigrate* params field: the maximum bandwidth (in MiB/s) that will be used for migration as VIR_TYPED_PARAM_ULLONG. If set to 0 or omitted, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if this field is used and is not 0.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_DEST_NAME">Macro </a>VIR_MIGRATE_PARAM_DEST_NAME</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a>;
</pre><p>virDomainMigrate* params field: the name to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. Omitting this parameter keeps the domain name the same. This field is only allowed to be used with hypervisors that support domain renaming during migration.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_DEST_XML">Macro </a>VIR_MIGRATE_PARAM_DEST_XML</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_DEST_XML">VIR_MIGRATE_PARAM_DEST_XML</a>;
</pre><p>virDomainMigrate* params field: the new configuration to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. The configuration must include an identical set of virtual devices, to ensure a stable guest ABI across migration. Only parameters related to host side configuration can be changed in the XML. Hypervisors which support this field will forbid migration if the provided XML would cause a change in the guest ABI. This field cannot be used to rename the domain during migration (use <a href="libvirt-libvirt.html#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a> field for that purpose). Domain name in the destination XML must match the original domain name. Omitting this parameter keeps the original domain configuration. Using this field with hypervisors that do not support changing domain configuration during migration will result in a failure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_GRAPHICS_URI">Macro </a>VIR_MIGRATE_PARAM_GRAPHICS_URI</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_GRAPHICS_URI">VIR_MIGRATE_PARAM_GRAPHICS_URI</a>;
</pre><p>virDomainMigrate* params field: URI to use for migrating client's connection to domain's graphical console as VIR_TYPED_PARAM_STRING. If specified, the client will be asked to automatically reconnect using these parameters instead of the automatically computed ones. This can be useful if, e.g., the client does not have a direct access to the network virtualization hosts are connected to and needs to connect through a proxy. The URI is formed as follows: protocol://hostname[:port]/[?parameters] where protocol is either "spice" or "vnc" and parameters is a list of protocol specific parameters separated by '&amp;'. Currently recognized parameters are "tlsPort" and "tlsSubject". For example, spice://target.host.com:1234/?tlsPort=4567</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_LISTEN_ADDRESS">Macro </a>VIR_MIGRATE_PARAM_LISTEN_ADDRESS</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_LISTEN_ADDRESS">VIR_MIGRATE_PARAM_LISTEN_ADDRESS</a>;
</pre><p>virDomainMigrate* params field: The listen address that hypervisor on the destination side should bind to for incoming migration. Both IPv4 and IPv6 addresses are accepted as well as hostnames (the resolving is done on destination). Some hypervisors do not support this feature and will return an error if this field is used.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_URI">Macro </a>VIR_MIGRATE_PARAM_URI</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a>;
</pre><p>virDomainMigrate* params field: URI to use for initiating domain migration as VIR_TYPED_PARAM_STRING. It takes a hypervisor specific format. The uri_transports element of the hypervisor capabilities XML includes details of the supported URI schemes. When omitted libvirt will auto-generate suitable default URI. It is typically only necessary to specify this URI if the destination host has multiple interfaces and a specific interface is required to transmit migration data. This filed may not be used when <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> flag is set.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODEINFO_MAXCPUS">Macro </a>VIR_NODEINFO_MAXCPUS</h3><pre class="programlisting">#define <a href="#VIR_NODEINFO_MAXCPUS">VIR_NODEINFO_MAXCPUS</a>(nodeinfo);
</pre><p>This macro is to calculate the total number of CPUs supported but not necessary active in the host.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>nodeinfo</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> instance</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_CPU_STATS_FIELD_LENGTH">Macro </a>VIR_NODE_CPU_STATS_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_NODE_CPU_STATS_FIELD_LENGTH">VIR_NODE_CPU_STATS_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of <a href="libvirt-libvirt.html#virNodeCPUStats">virNodeCPUStats</a></p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_CPU_STATS_IDLE">Macro </a>VIR_NODE_CPU_STATS_IDLE</h3><pre class="programlisting">#define <a href="#VIR_NODE_CPU_STATS_IDLE">VIR_NODE_CPU_STATS_IDLE</a>;
</pre><p>The cumulative idle CPU time, since the node booting up (in nanoseconds).</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_CPU_STATS_IOWAIT">Macro </a>VIR_NODE_CPU_STATS_IOWAIT</h3><pre class="programlisting">#define <a href="#VIR_NODE_CPU_STATS_IOWAIT">VIR_NODE_CPU_STATS_IOWAIT</a>;
</pre><p>The cumulative I/O wait CPU time, since the node booting up (in nanoseconds).</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_CPU_STATS_KERNEL">Macro </a>VIR_NODE_CPU_STATS_KERNEL</h3><pre class="programlisting">#define <a href="#VIR_NODE_CPU_STATS_KERNEL">VIR_NODE_CPU_STATS_KERNEL</a>;
</pre><p>Macro for the cumulative CPU time which was spent by the kernel, since the node booting up (in nanoseconds).</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_CPU_STATS_USER">Macro </a>VIR_NODE_CPU_STATS_USER</h3><pre class="programlisting">#define <a href="#VIR_NODE_CPU_STATS_USER">VIR_NODE_CPU_STATS_USER</a>;
</pre><p>The cumulative CPU time which was spent by user processes, since the node booting up (in nanoseconds).</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_CPU_STATS_UTILIZATION">Macro </a>VIR_NODE_CPU_STATS_UTILIZATION</h3><pre class="programlisting">#define <a href="#VIR_NODE_CPU_STATS_UTILIZATION">VIR_NODE_CPU_STATS_UTILIZATION</a>;
</pre><p>The CPU utilization of a node. The usage value is in percent and 100% represents all CPUs of the node.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_MEMORY_STATS_BUFFERS">Macro </a>VIR_NODE_MEMORY_STATS_BUFFERS</h3><pre class="programlisting">#define <a href="#VIR_NODE_MEMORY_STATS_BUFFERS">VIR_NODE_MEMORY_STATS_BUFFERS</a>;
</pre><p>Macro for the buffer memory: On Linux, it is only returned in case of VIR_NODE_MEMORY_STATS_ALL_CELLS.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_MEMORY_STATS_CACHED">Macro </a>VIR_NODE_MEMORY_STATS_CACHED</h3><pre class="programlisting">#define <a href="#VIR_NODE_MEMORY_STATS_CACHED">VIR_NODE_MEMORY_STATS_CACHED</a>;
</pre><p>Macro for the cached memory: On Linux, it is only returned in case of VIR_NODE_MEMORY_STATS_ALL_CELLS.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_MEMORY_STATS_FIELD_LENGTH">Macro </a>VIR_NODE_MEMORY_STATS_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_NODE_MEMORY_STATS_FIELD_LENGTH">VIR_NODE_MEMORY_STATS_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of <a href="libvirt-libvirt.html#virNodeMemoryStats">virNodeMemoryStats</a></p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_MEMORY_STATS_FREE">Macro </a>VIR_NODE_MEMORY_STATS_FREE</h3><pre class="programlisting">#define <a href="#VIR_NODE_MEMORY_STATS_FREE">VIR_NODE_MEMORY_STATS_FREE</a>;
</pre><p>Macro for the free memory of specified cell: On Linux, it includes buffer and cached memory, in case of VIR_NODE_MEMORY_STATS_ALL_CELLS.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_MEMORY_STATS_TOTAL">Macro </a>VIR_NODE_MEMORY_STATS_TOTAL</h3><pre class="programlisting">#define <a href="#VIR_NODE_MEMORY_STATS_TOTAL">VIR_NODE_MEMORY_STATS_TOTAL</a>;
</pre><p>Macro for the total memory of specified cell: it represents the maximum memory.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_SECURITY_DOI_BUFLEN">Macro </a>VIR_SECURITY_DOI_BUFLEN</h3><pre class="programlisting">#define <a href="#VIR_SECURITY_DOI_BUFLEN">VIR_SECURITY_DOI_BUFLEN</a>;
</pre><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> doi string.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_SECURITY_LABEL_BUFLEN">Macro </a>VIR_SECURITY_LABEL_BUFLEN</h3><pre class="programlisting">#define <a href="#VIR_SECURITY_LABEL_BUFLEN">VIR_SECURITY_LABEL_BUFLEN</a>;
</pre><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> label string. Note that this value is based on that used by Labeled NFS.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_SECURITY_MODEL_BUFLEN">Macro </a>VIR_SECURITY_MODEL_BUFLEN</h3><pre class="programlisting">#define <a href="#VIR_SECURITY_MODEL_BUFLEN">VIR_SECURITY_MODEL_BUFLEN</a>;
</pre><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> model string.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_TYPED_PARAM_FIELD_LENGTH">Macro </a>VIR_TYPED_PARAM_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of <a href="libvirt-libvirt.html#virTypedParameter">virTypedParameter</a> name</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_UNUSE_CPU">Macro </a>VIR_UNUSE_CPU</h3><pre class="programlisting">#define <a href="#VIR_UNUSE_CPU">VIR_UNUSE_CPU</a>(cpumap, cpu);
</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. It resets the bit (CPU not usable) of the related cpu in cpumap.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)</td></tr><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>the physical CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_USE_CPU">Macro </a>VIR_USE_CPU</h3><pre class="programlisting">#define <a href="#VIR_USE_CPU">VIR_USE_CPU</a>(cpumap, cpu);
</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. It sets the bit (CPU usable) of the related cpu in cpumap.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)</td></tr><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>the physical CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_UUID_BUFLEN">Macro </a>VIR_UUID_BUFLEN</h3><pre class="programlisting">#define <a href="#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a>;
</pre><p>This macro provides the length of the buffer required for virDomainGetUUID()</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_UUID_STRING_BUFLEN">Macro </a>VIR_UUID_STRING_BUFLEN</h3><pre class="programlisting">#define <a href="#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a>;
</pre><p>This macro provides the length of the buffer required for virDomainGetUUIDString()</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="_virBlkioParameter">Macro </a>_virBlkioParameter</h3><pre class="programlisting">#define <a href="#_virBlkioParameter">_virBlkioParameter</a>;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="_virMemoryParameter">Macro </a>_virMemoryParameter</h3><pre class="programlisting">#define <a href="#_virMemoryParameter">_virMemoryParameter</a>;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="_virSchedParameter">Macro </a>_virSchedParameter</h3><pre class="programlisting">#define <a href="#_virSchedParameter">_virSchedParameter</a>;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virBlkioParameter">Structure </a>virBlkioParameter</h3><pre class="programlisting">struct _virTypedParameter {
    char field[VIR_TYPED_PARAM_FIELD_LENGTH]	field	: parameter name
    int	type	: parameter type, <a href="libvirt-libvirt.html#virTypedParameterType">virTypedParameterType</a>
    union	value	: parameter value
} virBlkioParameter;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virBlkioParameterPtr">Typedef </a>virBlkioParameterPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virBlkioParameter">virBlkioParameter</a> * virBlkioParameterPtr;
</pre><p>a <a href="libvirt-libvirt.html#virBlkioParameterPtr">virBlkioParameterPtr</a> is a pointer to a <a href="libvirt-libvirt.html#virBlkioParameter">virBlkioParameter</a> structure. Provided for backwards compatibility; <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> is the preferred alias since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virBlkioParameterType">Enum </a>virBlkioParameterType</h3><pre class="programlisting">enum <a href="#virBlkioParameterType">virBlkioParameterType</a> {
    <a name="VIR_DOMAIN_BLKIO_PARAM_BOOLEAN">VIR_DOMAIN_BLKIO_PARAM_BOOLEAN</a> = VIR_TYPED_PARAM_BOOLEAN
    <a name="VIR_DOMAIN_BLKIO_PARAM_DOUBLE">VIR_DOMAIN_BLKIO_PARAM_DOUBLE</a> = VIR_TYPED_PARAM_DOUBLE
    <a name="VIR_DOMAIN_BLKIO_PARAM_INT">VIR_DOMAIN_BLKIO_PARAM_INT</a> = VIR_TYPED_PARAM_INT
    <a name="VIR_DOMAIN_BLKIO_PARAM_LLONG">VIR_DOMAIN_BLKIO_PARAM_LLONG</a> = VIR_TYPED_PARAM_LLONG
    <a name="VIR_DOMAIN_BLKIO_PARAM_UINT">VIR_DOMAIN_BLKIO_PARAM_UINT</a> = VIR_TYPED_PARAM_UINT
    <a name="VIR_DOMAIN_BLKIO_PARAM_ULLONG">VIR_DOMAIN_BLKIO_PARAM_ULLONG</a> = VIR_TYPED_PARAM_ULLONG
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virCPUCompareResult">Enum </a>virCPUCompareResult</h3><pre class="programlisting">enum <a href="#virCPUCompareResult">virCPUCompareResult</a> {
    <a name="VIR_CPU_COMPARE_ERROR">VIR_CPU_COMPARE_ERROR</a> = -1
    <a name="VIR_CPU_COMPARE_INCOMPATIBLE">VIR_CPU_COMPARE_INCOMPATIBLE</a> = 0
    <a name="VIR_CPU_COMPARE_IDENTICAL">VIR_CPU_COMPARE_IDENTICAL</a> = 1
    <a name="VIR_CPU_COMPARE_SUPERSET">VIR_CPU_COMPARE_SUPERSET</a> = 2
    <a name="VIR_CPU_COMPARE_LAST">VIR_CPU_COMPARE_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnect">Structure </a>virConnect</h3><pre class="programlisting">struct _virConnect {
The content of this structure is not made public by the API.
} virConnect;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectAuth">Structure </a>virConnectAuth</h3><pre class="programlisting">struct _virConnectAuth {
    int *	credtype	: List of supported <a href="libvirt-libvirt.html#virConnectCredentialType">virConnectCredentialType</a> values
    unsigned int	ncredtype
    <a href="libvirt-libvirt.html#virConnectAuthCallbackPtr">virConnectAuthCallbackPtr</a>	cb	: Callback used to collect credentials
    void *	cbdata
} virConnectAuth;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectAuthPtr">Typedef </a>virConnectAuthPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectAuth">virConnectAuth</a> * virConnectAuthPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectBaselineCPUFlags">Enum </a>virConnectBaselineCPUFlags</h3><pre class="programlisting">enum <a href="#virConnectBaselineCPUFlags">virConnectBaselineCPUFlags</a> {
    <a name="VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES">VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES</a> = 1 /* show all features */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectCloseReason">Enum </a>virConnectCloseReason</h3><pre class="programlisting">enum <a href="#virConnectCloseReason">virConnectCloseReason</a> {
    <a name="VIR_CONNECT_CLOSE_REASON_ERROR">VIR_CONNECT_CLOSE_REASON_ERROR</a> = 0 /* Misc I/O error */
    <a name="VIR_CONNECT_CLOSE_REASON_EOF">VIR_CONNECT_CLOSE_REASON_EOF</a> = 1 /* End-of-file from server */
    <a name="VIR_CONNECT_CLOSE_REASON_KEEPALIVE">VIR_CONNECT_CLOSE_REASON_KEEPALIVE</a> = 2 /* Keepalive timer triggered */
    <a name="VIR_CONNECT_CLOSE_REASON_CLIENT">VIR_CONNECT_CLOSE_REASON_CLIENT</a> = 3 /* Client requested it */
    <a name="VIR_CONNECT_CLOSE_REASON_LAST">VIR_CONNECT_CLOSE_REASON_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectCredential">Structure </a>virConnectCredential</h3><pre class="programlisting">struct _virConnectCredential {
    int	type	: One of <a href="libvirt-libvirt.html#virConnectCredentialType">virConnectCredentialType</a> constants
    const char *	prompt	: Prompt to show to user
    const char *	challenge	: Additional challenge to show
    const char *	defresult	: Optional default result
    char *	result	: Result to be filled with user response (or defresult)
    unsigned int	resultlen	: Length of the result
} virConnectCredential;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectCredentialPtr">Typedef </a>virConnectCredentialPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectCredential">virConnectCredential</a> * virConnectCredentialPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectCredentialType">Enum </a>virConnectCredentialType</h3><pre class="programlisting">enum <a href="#virConnectCredentialType">virConnectCredentialType</a> {
    <a name="VIR_CRED_USERNAME">VIR_CRED_USERNAME</a> = 1 /* Identity to act as */
    <a name="VIR_CRED_AUTHNAME">VIR_CRED_AUTHNAME</a> = 2 /* Identify to authorize as */
    <a name="VIR_CRED_LANGUAGE">VIR_CRED_LANGUAGE</a> = 3 /* RFC 1766 languages, comma separated */
    <a name="VIR_CRED_CNONCE">VIR_CRED_CNONCE</a> = 4 /* client supplies a nonce */
    <a name="VIR_CRED_PASSPHRASE">VIR_CRED_PASSPHRASE</a> = 5 /* Passphrase secret */
    <a name="VIR_CRED_ECHOPROMPT">VIR_CRED_ECHOPROMPT</a> = 6 /* Challenge response */
    <a name="VIR_CRED_NOECHOPROMPT">VIR_CRED_NOECHOPROMPT</a> = 7 /* Challenge response */
    <a name="VIR_CRED_REALM">VIR_CRED_REALM</a> = 8 /* Authentication realm */
    <a name="VIR_CRED_EXTERNAL">VIR_CRED_EXTERNAL</a> = 9 /* Externally managed credential */
    <a name="VIR_CRED_LAST">VIR_CRED_LAST</a> = 10 /* More may be added - expect the unexpected */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventBlockJobStatus">Enum </a>virConnectDomainEventBlockJobStatus</h3><pre class="programlisting">enum <a href="#virConnectDomainEventBlockJobStatus">virConnectDomainEventBlockJobStatus</a> {
    <a name="VIR_DOMAIN_BLOCK_JOB_COMPLETED">VIR_DOMAIN_BLOCK_JOB_COMPLETED</a> = 0
    <a name="VIR_DOMAIN_BLOCK_JOB_FAILED">VIR_DOMAIN_BLOCK_JOB_FAILED</a> = 1
    <a name="VIR_DOMAIN_BLOCK_JOB_CANCELED">VIR_DOMAIN_BLOCK_JOB_CANCELED</a> = 2
    <a name="VIR_DOMAIN_BLOCK_JOB_READY">VIR_DOMAIN_BLOCK_JOB_READY</a> = 3
    <a name="VIR_DOMAIN_BLOCK_JOB_LAST">VIR_DOMAIN_BLOCK_JOB_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDiskChangeReason">Enum </a>virConnectDomainEventDiskChangeReason</h3><pre class="programlisting">enum <a href="#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a> {
    <a name="VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START">VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START</a> = 0 /* oldSrcPath is set */
    <a name="VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START">VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START</a> = 1
    <a name="VIR_DOMAIN_EVENT_DISK_CHANGE_LAST">VIR_DOMAIN_EVENT_DISK_CHANGE_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectFlags">Enum </a>virConnectFlags</h3><pre class="programlisting">enum <a href="#virConnectFlags">virConnectFlags</a> {
    <a name="VIR_CONNECT_RO">VIR_CONNECT_RO</a> = 1 /* A readonly connection */
    <a name="VIR_CONNECT_NO_ALIASES">VIR_CONNECT_NO_ALIASES</a> = 2 /* Don't try to resolve URI aliases */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllDomainsFlags">Enum </a>virConnectListAllDomainsFlags</h3><pre class="programlisting">enum <a href="#virConnectListAllDomainsFlags">virConnectListAllDomainsFlags</a> {
    <a name="VIR_CONNECT_LIST_DOMAINS_ACTIVE">VIR_CONNECT_LIST_DOMAINS_ACTIVE</a> = 1
    <a name="VIR_CONNECT_LIST_DOMAINS_INACTIVE">VIR_CONNECT_LIST_DOMAINS_INACTIVE</a> = 2
    <a name="VIR_CONNECT_LIST_DOMAINS_PERSISTENT">VIR_CONNECT_LIST_DOMAINS_PERSISTENT</a> = 4
    <a name="VIR_CONNECT_LIST_DOMAINS_TRANSIENT">VIR_CONNECT_LIST_DOMAINS_TRANSIENT</a> = 8
    <a name="VIR_CONNECT_LIST_DOMAINS_RUNNING">VIR_CONNECT_LIST_DOMAINS_RUNNING</a> = 16
    <a name="VIR_CONNECT_LIST_DOMAINS_PAUSED">VIR_CONNECT_LIST_DOMAINS_PAUSED</a> = 32
    <a name="VIR_CONNECT_LIST_DOMAINS_SHUTOFF">VIR_CONNECT_LIST_DOMAINS_SHUTOFF</a> = 64
    <a name="VIR_CONNECT_LIST_DOMAINS_OTHER">VIR_CONNECT_LIST_DOMAINS_OTHER</a> = 128
    <a name="VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE</a> = 256
    <a name="VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE</a> = 512
    <a name="VIR_CONNECT_LIST_DOMAINS_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_AUTOSTART</a> = 1024
    <a name="VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART</a> = 2048
    <a name="VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT">VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT</a> = 4096
    <a name="VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT">VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT</a> = 8192
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllInterfacesFlags">Enum </a>virConnectListAllInterfacesFlags</h3><pre class="programlisting">enum <a href="#virConnectListAllInterfacesFlags">virConnectListAllInterfacesFlags</a> {
    <a name="VIR_CONNECT_LIST_INTERFACES_INACTIVE">VIR_CONNECT_LIST_INTERFACES_INACTIVE</a> = 1
    <a name="VIR_CONNECT_LIST_INTERFACES_ACTIVE">VIR_CONNECT_LIST_INTERFACES_ACTIVE</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllNetworksFlags">Enum </a>virConnectListAllNetworksFlags</h3><pre class="programlisting">enum <a href="#virConnectListAllNetworksFlags">virConnectListAllNetworksFlags</a> {
    <a name="VIR_CONNECT_LIST_NETWORKS_INACTIVE">VIR_CONNECT_LIST_NETWORKS_INACTIVE</a> = 1
    <a name="VIR_CONNECT_LIST_NETWORKS_ACTIVE">VIR_CONNECT_LIST_NETWORKS_ACTIVE</a> = 2
    <a name="VIR_CONNECT_LIST_NETWORKS_PERSISTENT">VIR_CONNECT_LIST_NETWORKS_PERSISTENT</a> = 4
    <a name="VIR_CONNECT_LIST_NETWORKS_TRANSIENT">VIR_CONNECT_LIST_NETWORKS_TRANSIENT</a> = 8
    <a name="VIR_CONNECT_LIST_NETWORKS_AUTOSTART">VIR_CONNECT_LIST_NETWORKS_AUTOSTART</a> = 16
    <a name="VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART">VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART</a> = 32
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllNodeDeviceFlags">Enum </a>virConnectListAllNodeDeviceFlags</h3><pre class="programlisting">enum <a href="#virConnectListAllNodeDeviceFlags">virConnectListAllNodeDeviceFlags</a> {
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM</a> = 1 /* System capability */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV</a> = 2 /* PCI device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV</a> = 4 /* USB device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE">VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE</a> = 8 /* USB interface */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET">VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET</a> = 16 /* Network device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST</a> = 32 /* SCSI Host Bus Adapter */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET</a> = 64 /* SCSI Target */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI</a> = 128 /* SCSI device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE">VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE</a> = 256 /* Storage device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST">VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST</a> = 512 /* FC Host Bus Adapter */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS">VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS</a> = 1024 /* Capable of vport */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC</a> = 2048 /* Capable of scsi_generic */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllSecretsFlags">Enum </a>virConnectListAllSecretsFlags</h3><pre class="programlisting">enum <a href="#virConnectListAllSecretsFlags">virConnectListAllSecretsFlags</a> {
    <a name="VIR_CONNECT_LIST_SECRETS_EPHEMERAL">VIR_CONNECT_LIST_SECRETS_EPHEMERAL</a> = 1 /* kept in memory, never stored persistently */
    <a name="VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL">VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL</a> = 2
    <a name="VIR_CONNECT_LIST_SECRETS_PRIVATE">VIR_CONNECT_LIST_SECRETS_PRIVATE</a> = 4 /* not revealed to any caller of libvirt, nor to any other node */
    <a name="VIR_CONNECT_LIST_SECRETS_NO_PRIVATE">VIR_CONNECT_LIST_SECRETS_NO_PRIVATE</a> = 8
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllStoragePoolsFlags">Enum </a>virConnectListAllStoragePoolsFlags</h3><pre class="programlisting">enum <a href="#virConnectListAllStoragePoolsFlags">virConnectListAllStoragePoolsFlags</a> {
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE">VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE</a> = 1
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE">VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE</a> = 2
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT">VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT</a> = 4
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT">VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT</a> = 8
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART">VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART</a> = 16
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART">VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART</a> = 32 /* List pools by type */
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_DIR">VIR_CONNECT_LIST_STORAGE_POOLS_DIR</a> = 64
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_FS">VIR_CONNECT_LIST_STORAGE_POOLS_FS</a> = 128
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_NETFS">VIR_CONNECT_LIST_STORAGE_POOLS_NETFS</a> = 256
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL">VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL</a> = 512
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_DISK">VIR_CONNECT_LIST_STORAGE_POOLS_DISK</a> = 1024
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI">VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI</a> = 2048
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_SCSI">VIR_CONNECT_LIST_STORAGE_POOLS_SCSI</a> = 4096
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_MPATH">VIR_CONNECT_LIST_STORAGE_POOLS_MPATH</a> = 8192
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_RBD">VIR_CONNECT_LIST_STORAGE_POOLS_RBD</a> = 16384
    <a name="VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG">VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG</a> = 32768
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectPtr">Typedef </a>virConnectPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnect">virConnect</a> * virConnectPtr;
</pre><p>a <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> is pointer to a <a href="libvirt-libvirt.html#virConnect">virConnect</a> private structure, this is the type used to reference a connection to the Hypervisor in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomain">Structure </a>virDomain</h3><pre class="programlisting">struct _virDomain {
The content of this structure is not made public by the API.
} virDomain;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockCommitFlags">Enum </a>virDomainBlockCommitFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockCommitFlags">virDomainBlockCommitFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_COMMIT_SHALLOW">VIR_DOMAIN_BLOCK_COMMIT_SHALLOW</a> = 1 /* NULL base means next backing file, not whole chain */
    <a name="VIR_DOMAIN_BLOCK_COMMIT_DELETE">VIR_DOMAIN_BLOCK_COMMIT_DELETE</a> = 2 /* Delete any files that are now invalid after their contents have been committed */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockInfo">Structure </a>virDomainBlockInfo</h3><pre class="programlisting">struct _virDomainBlockInfo {
    unsigned long long	capacity	: logical size in bytes of the block device backing image
    unsigned long long	allocation	: highest allocated extent in bytes of the block device backing image
    unsigned long long	physical	: physical size in bytes of the container of the backing image
} virDomainBlockInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockInfoPtr">Typedef </a>virDomainBlockInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainBlockInfo">virDomainBlockInfo</a> * virDomainBlockInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobAbortFlags">Enum </a>virDomainBlockJobAbortFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockJobAbortFlags">virDomainBlockJobAbortFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC">VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC</a> = 1
    <a name="VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT">VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobCursor">Typedef </a>virDomainBlockJobCursor</h3><pre class="programlisting">unsigned long long virDomainBlockJobCursor;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobInfo">Structure </a>virDomainBlockJobInfo</h3><pre class="programlisting">struct _virDomainBlockJobInfo {
    <a href="libvirt-libvirt.html#virDomainBlockJobType">virDomainBlockJobType</a>	type
    unsigned long	bandwidth	: The following fields provide an indication of block job progress. @cu
    <a href="libvirt-libvirt.html#virDomainBlockJobCursor">virDomainBlockJobCursor</a>	cur
    <a href="libvirt-libvirt.html#virDomainBlockJobCursor">virDomainBlockJobCursor</a>	end
} virDomainBlockJobInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobInfoPtr">Typedef </a>virDomainBlockJobInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a> * virDomainBlockJobInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobType">Enum </a>virDomainBlockJobType</h3><pre class="programlisting">enum <a href="#virDomainBlockJobType">virDomainBlockJobType</a> {
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN">VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_PULL">VIR_DOMAIN_BLOCK_JOB_TYPE_PULL</a> = 1
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_COPY">VIR_DOMAIN_BLOCK_JOB_TYPE_COPY</a> = 2
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT">VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT</a> = 3
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_LAST">VIR_DOMAIN_BLOCK_JOB_TYPE_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockRebaseFlags">Enum </a>virDomainBlockRebaseFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockRebaseFlags">virDomainBlockRebaseFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_REBASE_SHALLOW">VIR_DOMAIN_BLOCK_REBASE_SHALLOW</a> = 1 /* Limit copy to top of source backing chain */
    <a name="VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT">VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT</a> = 2 /* Reuse existing external file for a copy */
    <a name="VIR_DOMAIN_BLOCK_REBASE_COPY_RAW">VIR_DOMAIN_BLOCK_REBASE_COPY_RAW</a> = 4 /* Make destination file raw */
    <a name="VIR_DOMAIN_BLOCK_REBASE_COPY">VIR_DOMAIN_BLOCK_REBASE_COPY</a> = 8 /* Start a copy job */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockResizeFlags">Enum </a>virDomainBlockResizeFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockResizeFlags">virDomainBlockResizeFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_RESIZE_BYTES">VIR_DOMAIN_BLOCK_RESIZE_BYTES</a> = 1 /* size in bytes instead of KiB */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockStatsPtr">Typedef </a>virDomainBlockStatsPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a> * virDomainBlockStatsPtr;
</pre><p>A pointer to a <a href="libvirt-libvirt.html#virDomainBlockStats">virDomainBlockStats</a> structure</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockStatsStruct">Structure </a>virDomainBlockStatsStruct</h3><pre class="programlisting">struct _virDomainBlockStats {
    long long	rd_req	: number of read requests
    long long	rd_bytes	: number of read bytes
    long long	wr_req	: number of write requests
    long long	wr_bytes	: number of written bytes
    long long	errs	: In Xen this returns the mysterious 'oo_req'.
} virDomainBlockStatsStruct;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockedReason">Enum </a>virDomainBlockedReason</h3><pre class="programlisting">enum <a href="#virDomainBlockedReason">virDomainBlockedReason</a> {
    <a name="VIR_DOMAIN_BLOCKED_UNKNOWN">VIR_DOMAIN_BLOCKED_UNKNOWN</a> = 0 /* the reason is unknown */
    <a name="VIR_DOMAIN_BLOCKED_LAST">VIR_DOMAIN_BLOCKED_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainChannelFlags">Enum </a>virDomainChannelFlags</h3><pre class="programlisting">enum <a href="#virDomainChannelFlags">virDomainChannelFlags</a> {
    <a name="VIR_DOMAIN_CHANNEL_FORCE">VIR_DOMAIN_CHANNEL_FORCE</a> = 1 /* abort a (possibly) active channel connection to force a new connection */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainConsoleFlags">Enum </a>virDomainConsoleFlags</h3><pre class="programlisting">enum <a href="#virDomainConsoleFlags">virDomainConsoleFlags</a> {
    <a name="VIR_DOMAIN_CONSOLE_FORCE">VIR_DOMAIN_CONSOLE_FORCE</a> = 1 /* abort a (possibly) active console connection to force a new connection */
    <a name="VIR_DOMAIN_CONSOLE_SAFE">VIR_DOMAIN_CONSOLE_SAFE</a> = 2 /* check if the console driver supports safe console operations */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainControlInfo">Structure </a>virDomainControlInfo</h3><pre class="programlisting">struct _virDomainControlInfo {
    unsigned int	state	: control state, one of <a href="libvirt-libvirt.html#virDomainControlState">virDomainControlState</a>
    unsigned int	details	: state details, currently 0
    unsigned long long	stateTime	: for how long (in msec) control interface has been in current state (ex
} virDomainControlInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainControlInfoPtr">Typedef </a>virDomainControlInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainControlInfo">virDomainControlInfo</a> * virDomainControlInfoPtr;
</pre><p>Pointer to <a href="libvirt-libvirt.html#virDomainControlInfo">virDomainControlInfo</a> structure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainControlState">Enum </a>virDomainControlState</h3><pre class="programlisting">enum <a href="#virDomainControlState">virDomainControlState</a> {
    <a name="VIR_DOMAIN_CONTROL_OK">VIR_DOMAIN_CONTROL_OK</a> = 0 /* operational, ready to accept commands */
    <a name="VIR_DOMAIN_CONTROL_JOB">VIR_DOMAIN_CONTROL_JOB</a> = 1 /* background job is running (can be monitored by virDomainGetJobInfo); only limited set of commands may be allowed */
    <a name="VIR_DOMAIN_CONTROL_OCCUPIED">VIR_DOMAIN_CONTROL_OCCUPIED</a> = 2 /* occupied by a running command */
    <a name="VIR_DOMAIN_CONTROL_ERROR">VIR_DOMAIN_CONTROL_ERROR</a> = 3 /* unusable, domain cannot be fully operated */
    <a name="VIR_DOMAIN_CONTROL_LAST">VIR_DOMAIN_CONTROL_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCoreDumpFlags">Enum </a>virDomainCoreDumpFlags</h3><pre class="programlisting">enum <a href="#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a> {
    <a name="VIR_DUMP_CRASH">VIR_DUMP_CRASH</a> = 1 /* crash after dump */
    <a name="VIR_DUMP_LIVE">VIR_DUMP_LIVE</a> = 2 /* live dump */
    <a name="VIR_DUMP_BYPASS_CACHE">VIR_DUMP_BYPASS_CACHE</a> = 4 /* avoid file system cache pollution */
    <a name="VIR_DUMP_RESET">VIR_DUMP_RESET</a> = 8 /* reset domain after dump finishes */
    <a name="VIR_DUMP_MEMORY_ONLY">VIR_DUMP_MEMORY_ONLY</a> = 16 /* use dump-guest-memory */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCrashedReason">Enum </a>virDomainCrashedReason</h3><pre class="programlisting">enum <a href="#virDomainCrashedReason">virDomainCrashedReason</a> {
    <a name="VIR_DOMAIN_CRASHED_UNKNOWN">VIR_DOMAIN_CRASHED_UNKNOWN</a> = 0 /* crashed for unknown reason */
    <a name="VIR_DOMAIN_CRASHED_PANICKED">VIR_DOMAIN_CRASHED_PANICKED</a> = 1 /* domain panicked */
    <a name="VIR_DOMAIN_CRASHED_LAST">VIR_DOMAIN_CRASHED_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateFlags">Enum </a>virDomainCreateFlags</h3><pre class="programlisting">enum <a href="#virDomainCreateFlags">virDomainCreateFlags</a> {
    <a name="VIR_DOMAIN_NONE">VIR_DOMAIN_NONE</a> = 0 /* Default behavior */
    <a name="VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> = 1 /* Launch guest in paused state */
    <a name="VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> = 2 /* Automatically kill guest when virConnectPtr is closed */
    <a name="VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a> = 4 /* Avoid file system cache pollution */
    <a name="VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a> = 8 /* Boot, discarding any managed save */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDestroyFlagsValues">Enum </a>virDomainDestroyFlagsValues</h3><pre class="programlisting">enum <a href="#virDomainDestroyFlagsValues">virDomainDestroyFlagsValues</a> {
    <a name="VIR_DOMAIN_DESTROY_DEFAULT">VIR_DOMAIN_DESTROY_DEFAULT</a> = 0 /* Default behavior - could lead to data loss!! */
    <a name="VIR_DOMAIN_DESTROY_GRACEFUL">VIR_DOMAIN_DESTROY_GRACEFUL</a> = 1 /* only SIGTERM, no SIGKILL */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDeviceModifyFlags">Enum </a>virDomainDeviceModifyFlags</h3><pre class="programlisting">enum <a href="#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a> {
    <a name="VIR_DOMAIN_DEVICE_MODIFY_CONFIG">VIR_DOMAIN_DEVICE_MODIFY_CONFIG</a> = VIR_DOMAIN_AFFECT_CONFIG /* Additionally, these flags may be bitwise-OR'd in. */
    <a name="VIR_DOMAIN_DEVICE_MODIFY_CURRENT">VIR_DOMAIN_DEVICE_MODIFY_CURRENT</a> = VIR_DOMAIN_AFFECT_CURRENT
    <a name="VIR_DOMAIN_DEVICE_MODIFY_LIVE">VIR_DOMAIN_DEVICE_MODIFY_LIVE</a> = VIR_DOMAIN_AFFECT_LIVE
    <a name="VIR_DOMAIN_DEVICE_MODIFY_FORCE">VIR_DOMAIN_DEVICE_MODIFY_FORCE</a> = 4 /* Forcibly modify device (ex. force eject a cdrom) */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDiskError">Structure </a>virDomainDiskError</h3><pre class="programlisting">struct _virDomainDiskError {
    char *	disk	: disk target
    int	error	: <a href="libvirt-libvirt.html#virDomainDiskErrorCode">virDomainDiskErrorCode</a>
} virDomainDiskError;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDiskErrorCode">Enum </a>virDomainDiskErrorCode</h3><pre class="programlisting">enum <a href="#virDomainDiskErrorCode">virDomainDiskErrorCode</a> {
    <a name="VIR_DOMAIN_DISK_ERROR_NONE">VIR_DOMAIN_DISK_ERROR_NONE</a> = 0 /* no error */
    <a name="VIR_DOMAIN_DISK_ERROR_UNSPEC">VIR_DOMAIN_DISK_ERROR_UNSPEC</a> = 1 /* unspecified I/O error */
    <a name="VIR_DOMAIN_DISK_ERROR_NO_SPACE">VIR_DOMAIN_DISK_ERROR_NO_SPACE</a> = 2 /* no space left on the device */
    <a name="VIR_DOMAIN_DISK_ERROR_LAST">VIR_DOMAIN_DISK_ERROR_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDiskErrorPtr">Typedef </a>virDomainDiskErrorPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainDiskError">virDomainDiskError</a> * virDomainDiskErrorPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventCrashedDetailType">Enum </a>virDomainEventCrashedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventCrashedDetailType">virDomainEventCrashedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_CRASHED_PANICKED">VIR_DOMAIN_EVENT_CRASHED_PANICKED</a> = 0 /* Guest was panicked */
    <a name="VIR_DOMAIN_EVENT_CRASHED_LAST">VIR_DOMAIN_EVENT_CRASHED_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventDefinedDetailType">Enum </a>virDomainEventDefinedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventDefinedDetailType">virDomainEventDefinedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_DEFINED_ADDED">VIR_DOMAIN_EVENT_DEFINED_ADDED</a> = 0 /* Newly created config file */
    <a name="VIR_DOMAIN_EVENT_DEFINED_UPDATED">VIR_DOMAIN_EVENT_DEFINED_UPDATED</a> = 1 /* Changed config file */
    <a name="VIR_DOMAIN_EVENT_DEFINED_LAST">VIR_DOMAIN_EVENT_DEFINED_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsAddress">Structure </a>virDomainEventGraphicsAddress</h3><pre class="programlisting">struct _virDomainEventGraphicsAddress {
    int	family	: Address family, <a href="libvirt-libvirt.html#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a>
    char *	node	: Address of node (eg IP address, or UNIX path)
    char *	service	: Service name/number (eg TCP port, or NULL)
} virDomainEventGraphicsAddress;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsAddressPtr">Typedef </a>virDomainEventGraphicsAddressPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * virDomainEventGraphicsAddressPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsAddressType">Enum </a>virDomainEventGraphicsAddressType</h3><pre class="programlisting">enum <a href="#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a> {
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4</a> = 1 /* IPv4 address */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6</a> = 2 /* IPv6 address */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX</a> = 3 /* UNIX socket path */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsPhase">Enum </a>virDomainEventGraphicsPhase</h3><pre class="programlisting">enum <a href="#virDomainEventGraphicsPhase">virDomainEventGraphicsPhase</a> {
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_CONNECT">VIR_DOMAIN_EVENT_GRAPHICS_CONNECT</a> = 0 /* Initial socket connection established */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE">VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE</a> = 1 /* Authentication &amp; setup completed */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT">VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT</a> = 2 /* Final socket disconnection */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_LAST">VIR_DOMAIN_EVENT_GRAPHICS_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsSubject">Structure </a>virDomainEventGraphicsSubject</h3><pre class="programlisting">struct _virDomainEventGraphicsSubject {
    int	nidentity	: Number of identities in arra
    <a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectIdentityPtr">virDomainEventGraphicsSubjectIdentityPtr</a>	identities	: Array of identities for subject
} virDomainEventGraphicsSubject;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsSubjectIdentity">Structure </a>virDomainEventGraphicsSubjectIdentity</h3><pre class="programlisting">struct _virDomainEventGraphicsSubjectIdentity {
    char *	type	: Type of identity
    char *	name	: Identity value
} virDomainEventGraphicsSubjectIdentity;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsSubjectIdentityPtr">Typedef </a>virDomainEventGraphicsSubjectIdentityPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a> * virDomainEventGraphicsSubjectIdentityPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsSubjectPtr">Typedef </a>virDomainEventGraphicsSubjectPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * virDomainEventGraphicsSubjectPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventID">Enum </a>virDomainEventID</h3><pre class="programlisting">enum <a href="#virDomainEventID">virDomainEventID</a> {
    <a name="VIR_DOMAIN_EVENT_ID_LIFECYCLE">VIR_DOMAIN_EVENT_ID_LIFECYCLE</a> = 0 /* virConnectDomainEventCallback */
    <a name="VIR_DOMAIN_EVENT_ID_REBOOT">VIR_DOMAIN_EVENT_ID_REBOOT</a> = 1 /* virConnectDomainEventGenericCallback */
    <a name="VIR_DOMAIN_EVENT_ID_RTC_CHANGE">VIR_DOMAIN_EVENT_ID_RTC_CHANGE</a> = 2 /* virConnectDomainEventRTCChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_WATCHDOG">VIR_DOMAIN_EVENT_ID_WATCHDOG</a> = 3 /* virConnectDomainEventWatchdogCallback */
    <a name="VIR_DOMAIN_EVENT_ID_IO_ERROR">VIR_DOMAIN_EVENT_ID_IO_ERROR</a> = 4 /* virConnectDomainEventIOErrorCallback */
    <a name="VIR_DOMAIN_EVENT_ID_GRAPHICS">VIR_DOMAIN_EVENT_ID_GRAPHICS</a> = 5 /* virConnectDomainEventGraphicsCallback */
    <a name="VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON">VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON</a> = 6 /* virConnectDomainEventIOErrorReasonCallback */
    <a name="VIR_DOMAIN_EVENT_ID_CONTROL_ERROR">VIR_DOMAIN_EVENT_ID_CONTROL_ERROR</a> = 7 /* virConnectDomainEventGenericCallback */
    <a name="VIR_DOMAIN_EVENT_ID_BLOCK_JOB">VIR_DOMAIN_EVENT_ID_BLOCK_JOB</a> = 8 /* virConnectDomainEventBlockJobCallback */
    <a name="VIR_DOMAIN_EVENT_ID_DISK_CHANGE">VIR_DOMAIN_EVENT_ID_DISK_CHANGE</a> = 9 /* virConnectDomainEventDiskChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_TRAY_CHANGE">VIR_DOMAIN_EVENT_ID_TRAY_CHANGE</a> = 10 /* virConnectDomainEventTrayChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_PMWAKEUP">VIR_DOMAIN_EVENT_ID_PMWAKEUP</a> = 11 /* virConnectDomainEventPMWakeupCallback */
    <a name="VIR_DOMAIN_EVENT_ID_PMSUSPEND">VIR_DOMAIN_EVENT_ID_PMSUSPEND</a> = 12 /* virConnectDomainEventPMSuspendCallback */
    <a name="VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE">VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE</a> = 13 /* virConnectDomainEventBalloonChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK">VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK</a> = 14 /* virConnectDomainEventPMSuspendDiskCallback */
    <a name="VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED">VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED</a> = 15 /* virConnectDomainEventDeviceRemovedCallback */
    <a name="VIR_DOMAIN_EVENT_ID_LAST">VIR_DOMAIN_EVENT_ID_LAST</a> = 16 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last event ID supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventIOErrorAction">Enum </a>virDomainEventIOErrorAction</h3><pre class="programlisting">enum <a href="#virDomainEventIOErrorAction">virDomainEventIOErrorAction</a> {
    <a name="VIR_DOMAIN_EVENT_IO_ERROR_NONE">VIR_DOMAIN_EVENT_IO_ERROR_NONE</a> = 0 /* No action, IO error ignored */
    <a name="VIR_DOMAIN_EVENT_IO_ERROR_PAUSE">VIR_DOMAIN_EVENT_IO_ERROR_PAUSE</a> = 1 /* Guest CPUs are pausde */
    <a name="VIR_DOMAIN_EVENT_IO_ERROR_REPORT">VIR_DOMAIN_EVENT_IO_ERROR_REPORT</a> = 2 /* IO error reported to guest OS */
    <a name="VIR_DOMAIN_EVENT_IO_ERROR_LAST">VIR_DOMAIN_EVENT_IO_ERROR_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventPMSuspendedDetailType">Enum </a>virDomainEventPMSuspendedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventPMSuspendedDetailType">virDomainEventPMSuspendedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY">VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY</a> = 0 /* Guest was PM suspended to memory */
    <a name="VIR_DOMAIN_EVENT_PMSUSPENDED_DISK">VIR_DOMAIN_EVENT_PMSUSPENDED_DISK</a> = 1 /* Guest was PM suspended to disk */
    <a name="VIR_DOMAIN_EVENT_PMSUSPENDED_LAST">VIR_DOMAIN_EVENT_PMSUSPENDED_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventResumedDetailType">Enum </a>virDomainEventResumedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventResumedDetailType">virDomainEventResumedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_RESUMED_UNPAUSED">VIR_DOMAIN_EVENT_RESUMED_UNPAUSED</a> = 0 /* Normal resume due to admin unpause */
    <a name="VIR_DOMAIN_EVENT_RESUMED_MIGRATED">VIR_DOMAIN_EVENT_RESUMED_MIGRATED</a> = 1 /* Resumed for completion of migration */
    <a name="VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT</a> = 2 /* Resumed from snapshot */
    <a name="VIR_DOMAIN_EVENT_RESUMED_LAST">VIR_DOMAIN_EVENT_RESUMED_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventShutdownDetailType">Enum </a>virDomainEventShutdownDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventShutdownDetailType">virDomainEventShutdownDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED">VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED</a> = 0 /* Guest finished shutdown sequence */
    <a name="VIR_DOMAIN_EVENT_SHUTDOWN_LAST">VIR_DOMAIN_EVENT_SHUTDOWN_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventStartedDetailType">Enum </a>virDomainEventStartedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventStartedDetailType">virDomainEventStartedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_STARTED_BOOTED">VIR_DOMAIN_EVENT_STARTED_BOOTED</a> = 0 /* Normal startup from boot */
    <a name="VIR_DOMAIN_EVENT_STARTED_MIGRATED">VIR_DOMAIN_EVENT_STARTED_MIGRATED</a> = 1 /* Incoming migration from another host */
    <a name="VIR_DOMAIN_EVENT_STARTED_RESTORED">VIR_DOMAIN_EVENT_STARTED_RESTORED</a> = 2 /* Restored from a state file */
    <a name="VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT</a> = 3 /* Restored from snapshot */
    <a name="VIR_DOMAIN_EVENT_STARTED_WAKEUP">VIR_DOMAIN_EVENT_STARTED_WAKEUP</a> = 4 /* Started due to wakeup event */
    <a name="VIR_DOMAIN_EVENT_STARTED_LAST">VIR_DOMAIN_EVENT_STARTED_LAST</a> = 5
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventStoppedDetailType">Enum </a>virDomainEventStoppedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventStoppedDetailType">virDomainEventStoppedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN">VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN</a> = 0 /* Normal shutdown */
    <a name="VIR_DOMAIN_EVENT_STOPPED_DESTROYED">VIR_DOMAIN_EVENT_STOPPED_DESTROYED</a> = 1 /* Forced poweroff from host */
    <a name="VIR_DOMAIN_EVENT_STOPPED_CRASHED">VIR_DOMAIN_EVENT_STOPPED_CRASHED</a> = 2 /* Guest crashed */
    <a name="VIR_DOMAIN_EVENT_STOPPED_MIGRATED">VIR_DOMAIN_EVENT_STOPPED_MIGRATED</a> = 3 /* Migrated off to another host */
    <a name="VIR_DOMAIN_EVENT_STOPPED_SAVED">VIR_DOMAIN_EVENT_STOPPED_SAVED</a> = 4 /* Saved to a state file */
    <a name="VIR_DOMAIN_EVENT_STOPPED_FAILED">VIR_DOMAIN_EVENT_STOPPED_FAILED</a> = 5 /* Host emulator/mgmt failed */
    <a name="VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT</a> = 6 /* offline snapshot loaded */
    <a name="VIR_DOMAIN_EVENT_STOPPED_LAST">VIR_DOMAIN_EVENT_STOPPED_LAST</a> = 7
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventSuspendedDetailType">Enum </a>virDomainEventSuspendedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventSuspendedDetailType">virDomainEventSuspendedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_PAUSED">VIR_DOMAIN_EVENT_SUSPENDED_PAUSED</a> = 0 /* Normal suspend due to admin pause */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED">VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED</a> = 1 /* Suspended for offline migration */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_IOERROR">VIR_DOMAIN_EVENT_SUSPENDED_IOERROR</a> = 2 /* Suspended due to a disk I/O error */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG">VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG</a> = 3 /* Suspended due to a watchdog firing */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_RESTORED">VIR_DOMAIN_EVENT_SUSPENDED_RESTORED</a> = 4 /* Restored from paused state file */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT</a> = 5 /* Restored from paused snapshot */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR">VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR</a> = 6 /* suspended after failure during libvirt API call */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_LAST">VIR_DOMAIN_EVENT_SUSPENDED_LAST</a> = 7
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventTrayChangeReason">Enum </a>virDomainEventTrayChangeReason</h3><pre class="programlisting">enum <a href="#virDomainEventTrayChangeReason">virDomainEventTrayChangeReason</a> {
    <a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN">VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN</a> = 0
    <a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE">VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE</a> = 1
    <a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST">VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventType">Enum </a>virDomainEventType</h3><pre class="programlisting">enum <a href="#virDomainEventType">virDomainEventType</a> {
    <a name="VIR_DOMAIN_EVENT_DEFINED">VIR_DOMAIN_EVENT_DEFINED</a> = 0
    <a name="VIR_DOMAIN_EVENT_UNDEFINED">VIR_DOMAIN_EVENT_UNDEFINED</a> = 1
    <a name="VIR_DOMAIN_EVENT_STARTED">VIR_DOMAIN_EVENT_STARTED</a> = 2
    <a name="VIR_DOMAIN_EVENT_SUSPENDED">VIR_DOMAIN_EVENT_SUSPENDED</a> = 3
    <a name="VIR_DOMAIN_EVENT_RESUMED">VIR_DOMAIN_EVENT_RESUMED</a> = 4
    <a name="VIR_DOMAIN_EVENT_STOPPED">VIR_DOMAIN_EVENT_STOPPED</a> = 5
    <a name="VIR_DOMAIN_EVENT_SHUTDOWN">VIR_DOMAIN_EVENT_SHUTDOWN</a> = 6
    <a name="VIR_DOMAIN_EVENT_PMSUSPENDED">VIR_DOMAIN_EVENT_PMSUSPENDED</a> = 7
    <a name="VIR_DOMAIN_EVENT_CRASHED">VIR_DOMAIN_EVENT_CRASHED</a> = 8
    <a name="VIR_DOMAIN_EVENT_LAST">VIR_DOMAIN_EVENT_LAST</a> = 9
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventUndefinedDetailType">Enum </a>virDomainEventUndefinedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventUndefinedDetailType">virDomainEventUndefinedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_UNDEFINED_REMOVED">VIR_DOMAIN_EVENT_UNDEFINED_REMOVED</a> = 0 /* Deleted the config file */
    <a name="VIR_DOMAIN_EVENT_UNDEFINED_LAST">VIR_DOMAIN_EVENT_UNDEFINED_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventWatchdogAction">Enum </a>virDomainEventWatchdogAction</h3><pre class="programlisting">enum <a href="#virDomainEventWatchdogAction">virDomainEventWatchdogAction</a> {
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_NONE">VIR_DOMAIN_EVENT_WATCHDOG_NONE</a> = 0 /* No action, watchdog ignored */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_PAUSE">VIR_DOMAIN_EVENT_WATCHDOG_PAUSE</a> = 1 /* Guest CPUs are paused */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_RESET">VIR_DOMAIN_EVENT_WATCHDOG_RESET</a> = 2 /* Guest CPUs are reset */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF">VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF</a> = 3 /* Guest is forcably powered off */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN">VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN</a> = 4 /* Guest is requested to gracefully shutdown */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_DEBUG">VIR_DOMAIN_EVENT_WATCHDOG_DEBUG</a> = 5 /* No action, a debug message logged */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_LAST">VIR_DOMAIN_EVENT_WATCHDOG_LAST</a> = 6
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInfo">Structure </a>virDomainInfo</h3><pre class="programlisting">struct _virDomainInfo {
    unsigned char	state	: the running state, one of <a href="libvirt-libvirt.html#virDomainState">virDomainState</a>
    unsigned long	maxMem	: the maximum memory in KBytes allowed
    unsigned long	memory	: the memory in KBytes used by the domain
    unsigned short	nrVirtCpu	: the number of virtual CPUs for the domain
    unsigned long long	cpuTime	: the CPU time used in nanoseconds
} virDomainInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInfoPtr">Typedef </a>virDomainInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainInfo">virDomainInfo</a> * virDomainInfoPtr;
</pre><p>a <a href="libvirt-libvirt.html#virDomainInfoPtr">virDomainInfoPtr</a> is a pointer to a <a href="libvirt-libvirt.html#virDomainInfo">virDomainInfo</a> structure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceStatsPtr">Typedef </a>virDomainInterfaceStatsPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a> * virDomainInterfaceStatsPtr;
</pre><p>A pointer to a <a href="libvirt-libvirt.html#virDomainInterfaceStats">virDomainInterfaceStats</a> structure</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceStatsStruct">Structure </a>virDomainInterfaceStatsStruct</h3><pre class="programlisting">struct _virDomainInterfaceStats {
    long long	rx_bytes
    long long	rx_packets
    long long	rx_errs
    long long	rx_drop
    long long	tx_bytes
    long long	tx_packets
    long long	tx_errs
    long long	tx_drop
} virDomainInterfaceStatsStruct;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainJobInfo">Structure </a>virDomainJobInfo</h3><pre class="programlisting">struct _virDomainJobInfo {
    int	type	: Time is measured in milliseconds
    unsigned long long	timeElapsed	: Always set
    unsigned long long	timeRemaining	: Only for <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> Data is measured in bytes unless other
    unsigned long long	dataTotal
    unsigned long long	dataProcessed
    unsigned long long	dataRemaining	: As above, but only tracking guest memory progress
    unsigned long long	memTotal
    unsigned long long	memProcessed
    unsigned long long	memRemaining	: As above, but only tracking guest disk file progress
    unsigned long long	fileTotal
    unsigned long long	fileProcessed
    unsigned long long	fileRemaining
} virDomainJobInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainJobInfoPtr">Typedef </a>virDomainJobInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a> * virDomainJobInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainJobType">Enum </a>virDomainJobType</h3><pre class="programlisting">enum <a href="#virDomainJobType">virDomainJobType</a> {
    <a name="VIR_DOMAIN_JOB_NONE">VIR_DOMAIN_JOB_NONE</a> = 0 /* No job is active */
    <a name="VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> = 1 /* Job with a finite completion time */
    <a name="VIR_DOMAIN_JOB_UNBOUNDED">VIR_DOMAIN_JOB_UNBOUNDED</a> = 2 /* Job without a finite completion time */
    <a name="VIR_DOMAIN_JOB_COMPLETED">VIR_DOMAIN_JOB_COMPLETED</a> = 3 /* Job has finished, but isn't cleaned up */
    <a name="VIR_DOMAIN_JOB_FAILED">VIR_DOMAIN_JOB_FAILED</a> = 4 /* Job hit error, but isn't cleaned up */
    <a name="VIR_DOMAIN_JOB_CANCELLED">VIR_DOMAIN_JOB_CANCELLED</a> = 5 /* Job was aborted, but isn't cleaned up */
    <a name="VIR_DOMAIN_JOB_LAST">VIR_DOMAIN_JOB_LAST</a> = 6
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryFlags">Enum </a>virDomainMemoryFlags</h3><pre class="programlisting">enum <a href="#virDomainMemoryFlags">virDomainMemoryFlags</a> {
    <a name="VIR_MEMORY_VIRTUAL">VIR_MEMORY_VIRTUAL</a> = 1 /* addresses are virtual addresses */
    <a name="VIR_MEMORY_PHYSICAL">VIR_MEMORY_PHYSICAL</a> = 2 /* addresses are physical addresses */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryModFlags">Enum </a>virDomainMemoryModFlags</h3><pre class="programlisting">enum <a href="#virDomainMemoryModFlags">virDomainMemoryModFlags</a> {
    <a name="VIR_DOMAIN_MEM_CONFIG">VIR_DOMAIN_MEM_CONFIG</a> = VIR_DOMAIN_AFFECT_CONFIG /* Additionally, these flags may be bitwise-OR'd in. */
    <a name="VIR_DOMAIN_MEM_CURRENT">VIR_DOMAIN_MEM_CURRENT</a> = VIR_DOMAIN_AFFECT_CURRENT
    <a name="VIR_DOMAIN_MEM_LIVE">VIR_DOMAIN_MEM_LIVE</a> = VIR_DOMAIN_AFFECT_LIVE
    <a name="VIR_DOMAIN_MEM_MAXIMUM">VIR_DOMAIN_MEM_MAXIMUM</a> = 4 /* affect Max rather than current */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryStatPtr">Typedef </a>virDomainMemoryStatPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a> * virDomainMemoryStatPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryStatStruct">Structure </a>virDomainMemoryStatStruct</h3><pre class="programlisting">struct _virDomainMemoryStat {
    int	tag
    unsigned long long	val
} virDomainMemoryStatStruct;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryStatTags">Enum </a>virDomainMemoryStatTags</h3><pre class="programlisting">enum <a href="#virDomainMemoryStatTags">virDomainMemoryStatTags</a> {
    <a name="VIR_DOMAIN_MEMORY_STAT_LAST">VIR_DOMAIN_MEMORY_STAT_LAST</a> = VIR_DOMAIN_MEMORY_STAT_NR
    <a name="VIR_DOMAIN_MEMORY_STAT_SWAP_IN">VIR_DOMAIN_MEMORY_STAT_SWAP_IN</a> = 0 /* The total amount of memory written out to swap space (in kB). */
    <a name="VIR_DOMAIN_MEMORY_STAT_SWAP_OUT">VIR_DOMAIN_MEMORY_STAT_SWAP_OUT</a> = 1 /* Page faults occur when a process makes a valid access to virtual memory  that is not available.  When servicing the page fault, if disk IO is  required, it is considered a major fault.  If not, it is a minor fault.  These are expressed as the number of faults that have occurred. */
    <a name="VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT</a> = 2
    <a name="VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT</a> = 3 /* The amount of memory left completely unused by the system.  Memory that  is available but used for reclaimable caches should NOT be reported as  free.  This value is expressed in kB. */
    <a name="VIR_DOMAIN_MEMORY_STAT_UNUSED">VIR_DOMAIN_MEMORY_STAT_UNUSED</a> = 4 /* The total amount of usable memory as seen by the domain.  This value  may be less than the amount of memory assigned to the domain if a  balloon driver is in use or if the guest OS does not initialize all  assigned pages.  This value is expressed in kB. */
    <a name="VIR_DOMAIN_MEMORY_STAT_AVAILABLE">VIR_DOMAIN_MEMORY_STAT_AVAILABLE</a> = 5 /* Current balloon value (in KB). */
    <a name="VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON">VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON</a> = 6 /* Resident Set Size of the process running the domain. This value  is in kB */
    <a name="VIR_DOMAIN_MEMORY_STAT_RSS">VIR_DOMAIN_MEMORY_STAT_RSS</a> = 7 /* The number of statistics supported by this version of the interface.  To add new statistics, add them to the enum and increase this value. */
    <a name="VIR_DOMAIN_MEMORY_STAT_NR">VIR_DOMAIN_MEMORY_STAT_NR</a> = 8
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMetadataType">Enum </a>virDomainMetadataType</h3><pre class="programlisting">enum <a href="#virDomainMetadataType">virDomainMetadataType</a> {
    <a name="VIR_DOMAIN_METADATA_DESCRIPTION">VIR_DOMAIN_METADATA_DESCRIPTION</a> = 0 /* Operate on &lt;description&gt; */
    <a name="VIR_DOMAIN_METADATA_TITLE">VIR_DOMAIN_METADATA_TITLE</a> = 1 /* Operate on &lt;title&gt; */
    <a name="VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a> = 2 /* Operate on &lt;metadata&gt; */
    <a name="VIR_DOMAIN_METADATA_LAST">VIR_DOMAIN_METADATA_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateFlags">Enum </a>virDomainMigrateFlags</h3><pre class="programlisting">enum <a href="#virDomainMigrateFlags">virDomainMigrateFlags</a> {
    <a name="VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> = 1 /* live migration */
    <a name="VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> = 2 /* direct source -&gt; dest host control channel Note the less-common spelling that we're stuck with: VIR_MIGRATE_TUNNELLED should be VIR_MIGRATE_TUNNELED */
    <a name="VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> = 4 /* tunnel migration data over libvirtd connection */
    <a name="VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> = 8 /* persist the VM on the destination */
    <a name="VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> = 16 /* undefine the VM on the source */
    <a name="VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> = 32 /* pause on remote side */
    <a name="VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> = 64 /* migration with non-shared storage with full disk copy */
    <a name="VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> = 128 /* migration with non-shared storage with incremental copy (same base image shared between source and destination) */
    <a name="VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> = 256 /* protect for changing domain configuration through the  whole migration process; this will be used automatically  when supported */
    <a name="VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> = 512 /* force migration even if it is considered unsafe */
    <a name="VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> = 1024 /* offline migrate */
    <a name="VIR_MIGRATE_COMPRESSED">VIR_MIGRATE_COMPRESSED</a> = 2048 /* compress data during migration */
    <a name="VIR_MIGRATE_ABORT_ON_ERROR">VIR_MIGRATE_ABORT_ON_ERROR</a> = 4096 /* abort migration on I/O errors happened during migration */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainModificationImpact">Enum </a>virDomainModificationImpact</h3><pre class="programlisting">enum <a href="#virDomainModificationImpact">virDomainModificationImpact</a> {
    <a name="VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a> = 0 /* Affect current domain state. */
    <a name="VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> = 1 /* Affect running domain state. */
    <a name="VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> = 2 /* Affect persistent domain state.  1 &lt;&lt; 2 is reserved for virTypedParameterFlags */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainNostateReason">Enum </a>virDomainNostateReason</h3><pre class="programlisting">enum <a href="#virDomainNostateReason">virDomainNostateReason</a> {
    <a name="VIR_DOMAIN_NOSTATE_UNKNOWN">VIR_DOMAIN_NOSTATE_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_NOSTATE_LAST">VIR_DOMAIN_NOSTATE_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainNumatuneMemMode">Enum </a>virDomainNumatuneMemMode</h3><pre class="programlisting">enum <a href="#virDomainNumatuneMemMode">virDomainNumatuneMemMode</a> {
    <a name="VIR_DOMAIN_NUMATUNE_MEM_STRICT">VIR_DOMAIN_NUMATUNE_MEM_STRICT</a> = 0
    <a name="VIR_DOMAIN_NUMATUNE_MEM_PREFERRED">VIR_DOMAIN_NUMATUNE_MEM_PREFERRED</a> = 1
    <a name="VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE">VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE</a> = 2
    <a name="VIR_DOMAIN_NUMATUNE_MEM_LAST">VIR_DOMAIN_NUMATUNE_MEM_LAST</a> = 3 /* This constant is subject to change */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenGraphicsFlags">Enum </a>virDomainOpenGraphicsFlags</h3><pre class="programlisting">enum <a href="#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a> {
    <a name="VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH">VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPMSuspendedDiskReason">Enum </a>virDomainPMSuspendedDiskReason</h3><pre class="programlisting">enum <a href="#virDomainPMSuspendedDiskReason">virDomainPMSuspendedDiskReason</a> {
    <a name="VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN">VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_PMSUSPENDED_DISK_LAST">VIR_DOMAIN_PMSUSPENDED_DISK_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPMSuspendedReason">Enum </a>virDomainPMSuspendedReason</h3><pre class="programlisting">enum <a href="#virDomainPMSuspendedReason">virDomainPMSuspendedReason</a> {
    <a name="VIR_DOMAIN_PMSUSPENDED_UNKNOWN">VIR_DOMAIN_PMSUSPENDED_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_PMSUSPENDED_LAST">VIR_DOMAIN_PMSUSPENDED_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPausedReason">Enum </a>virDomainPausedReason</h3><pre class="programlisting">enum <a href="#virDomainPausedReason">virDomainPausedReason</a> {
    <a name="VIR_DOMAIN_PAUSED_UNKNOWN">VIR_DOMAIN_PAUSED_UNKNOWN</a> = 0 /* the reason is unknown */
    <a name="VIR_DOMAIN_PAUSED_USER">VIR_DOMAIN_PAUSED_USER</a> = 1 /* paused on user request */
    <a name="VIR_DOMAIN_PAUSED_MIGRATION">VIR_DOMAIN_PAUSED_MIGRATION</a> = 2 /* paused for offline migration */
    <a name="VIR_DOMAIN_PAUSED_SAVE">VIR_DOMAIN_PAUSED_SAVE</a> = 3 /* paused for save */
    <a name="VIR_DOMAIN_PAUSED_DUMP">VIR_DOMAIN_PAUSED_DUMP</a> = 4 /* paused for offline core dump */
    <a name="VIR_DOMAIN_PAUSED_IOERROR">VIR_DOMAIN_PAUSED_IOERROR</a> = 5 /* paused due to a disk I/O error */
    <a name="VIR_DOMAIN_PAUSED_WATCHDOG">VIR_DOMAIN_PAUSED_WATCHDOG</a> = 6 /* paused due to a watchdog event */
    <a name="VIR_DOMAIN_PAUSED_FROM_SNAPSHOT">VIR_DOMAIN_PAUSED_FROM_SNAPSHOT</a> = 7 /* paused after restoring from snapshot */
    <a name="VIR_DOMAIN_PAUSED_SHUTTING_DOWN">VIR_DOMAIN_PAUSED_SHUTTING_DOWN</a> = 8 /* paused during shutdown process */
    <a name="VIR_DOMAIN_PAUSED_SNAPSHOT">VIR_DOMAIN_PAUSED_SNAPSHOT</a> = 9 /* paused while creating a snapshot */
    <a name="VIR_DOMAIN_PAUSED_CRASHED">VIR_DOMAIN_PAUSED_CRASHED</a> = 10 /* paused due to a guest crash */
    <a name="VIR_DOMAIN_PAUSED_LAST">VIR_DOMAIN_PAUSED_LAST</a> = 11
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainProcessSignal">Enum </a>virDomainProcessSignal</h3><pre class="programlisting">enum <a href="#virDomainProcessSignal">virDomainProcessSignal</a> {
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_NOP">VIR_DOMAIN_PROCESS_SIGNAL_NOP</a> = 0 /* No constant in POSIX/Linux */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_HUP">VIR_DOMAIN_PROCESS_SIGNAL_HUP</a> = 1 /* SIGHUP */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_INT">VIR_DOMAIN_PROCESS_SIGNAL_INT</a> = 2 /* SIGINT */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_QUIT">VIR_DOMAIN_PROCESS_SIGNAL_QUIT</a> = 3 /* SIGQUIT */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_ILL">VIR_DOMAIN_PROCESS_SIGNAL_ILL</a> = 4 /* SIGILL */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TRAP">VIR_DOMAIN_PROCESS_SIGNAL_TRAP</a> = 5 /* SIGTRAP */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_ABRT">VIR_DOMAIN_PROCESS_SIGNAL_ABRT</a> = 6 /* SIGABRT */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_BUS">VIR_DOMAIN_PROCESS_SIGNAL_BUS</a> = 7 /* SIGBUS */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_FPE">VIR_DOMAIN_PROCESS_SIGNAL_FPE</a> = 8 /* SIGFPE */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_KILL">VIR_DOMAIN_PROCESS_SIGNAL_KILL</a> = 9 /* SIGKILL */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_USR1">VIR_DOMAIN_PROCESS_SIGNAL_USR1</a> = 10 /* SIGUSR1 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_SEGV">VIR_DOMAIN_PROCESS_SIGNAL_SEGV</a> = 11 /* SIGSEGV */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_USR2">VIR_DOMAIN_PROCESS_SIGNAL_USR2</a> = 12 /* SIGUSR2 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_PIPE">VIR_DOMAIN_PROCESS_SIGNAL_PIPE</a> = 13 /* SIGPIPE */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_ALRM">VIR_DOMAIN_PROCESS_SIGNAL_ALRM</a> = 14 /* SIGALRM */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TERM">VIR_DOMAIN_PROCESS_SIGNAL_TERM</a> = 15 /* SIGTERM */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_STKFLT">VIR_DOMAIN_PROCESS_SIGNAL_STKFLT</a> = 16 /* Not in POSIX (SIGSTKFLT on Linux */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_CHLD">VIR_DOMAIN_PROCESS_SIGNAL_CHLD</a> = 17 /* SIGCHLD */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_CONT">VIR_DOMAIN_PROCESS_SIGNAL_CONT</a> = 18 /* SIGCONT */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_STOP">VIR_DOMAIN_PROCESS_SIGNAL_STOP</a> = 19 /* SIGSTOP */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TSTP">VIR_DOMAIN_PROCESS_SIGNAL_TSTP</a> = 20 /* SIGTSTP */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TTIN">VIR_DOMAIN_PROCESS_SIGNAL_TTIN</a> = 21 /* SIGTTIN */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TTOU">VIR_DOMAIN_PROCESS_SIGNAL_TTOU</a> = 22 /* SIGTTOU */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_URG">VIR_DOMAIN_PROCESS_SIGNAL_URG</a> = 23 /* SIGURG */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_XCPU">VIR_DOMAIN_PROCESS_SIGNAL_XCPU</a> = 24 /* SIGXCPU */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_XFSZ">VIR_DOMAIN_PROCESS_SIGNAL_XFSZ</a> = 25 /* SIGXFSZ */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_VTALRM">VIR_DOMAIN_PROCESS_SIGNAL_VTALRM</a> = 26 /* SIGVTALRM */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_PROF">VIR_DOMAIN_PROCESS_SIGNAL_PROF</a> = 27 /* SIGPROF */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_WINCH">VIR_DOMAIN_PROCESS_SIGNAL_WINCH</a> = 28 /* Not in POSIX (SIGWINCH on Linux) */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_POLL">VIR_DOMAIN_PROCESS_SIGNAL_POLL</a> = 29 /* SIGPOLL (also known as SIGIO on Linux) */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_PWR">VIR_DOMAIN_PROCESS_SIGNAL_PWR</a> = 30 /* Not in POSIX (SIGPWR on Linux) */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_SYS">VIR_DOMAIN_PROCESS_SIGNAL_SYS</a> = 31 /* SIGSYS (also known as SIGUNUSED on Linux) */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT0">VIR_DOMAIN_PROCESS_SIGNAL_RT0</a> = 32 /* SIGRTMIN */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT1">VIR_DOMAIN_PROCESS_SIGNAL_RT1</a> = 33 /* SIGRTMIN + 1 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT2">VIR_DOMAIN_PROCESS_SIGNAL_RT2</a> = 34 /* SIGRTMIN + 2 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT3">VIR_DOMAIN_PROCESS_SIGNAL_RT3</a> = 35 /* SIGRTMIN + 3 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT4">VIR_DOMAIN_PROCESS_SIGNAL_RT4</a> = 36 /* SIGRTMIN + 4 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT5">VIR_DOMAIN_PROCESS_SIGNAL_RT5</a> = 37 /* SIGRTMIN + 5 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT6">VIR_DOMAIN_PROCESS_SIGNAL_RT6</a> = 38 /* SIGRTMIN + 6 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT7">VIR_DOMAIN_PROCESS_SIGNAL_RT7</a> = 39 /* SIGRTMIN + 7 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT8">VIR_DOMAIN_PROCESS_SIGNAL_RT8</a> = 40 /* SIGRTMIN + 8 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT9">VIR_DOMAIN_PROCESS_SIGNAL_RT9</a> = 41 /* SIGRTMIN + 9 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT10">VIR_DOMAIN_PROCESS_SIGNAL_RT10</a> = 42 /* SIGRTMIN + 10 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT11">VIR_DOMAIN_PROCESS_SIGNAL_RT11</a> = 43 /* SIGRTMIN + 11 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT12">VIR_DOMAIN_PROCESS_SIGNAL_RT12</a> = 44 /* SIGRTMIN + 12 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT13">VIR_DOMAIN_PROCESS_SIGNAL_RT13</a> = 45 /* SIGRTMIN + 13 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT14">VIR_DOMAIN_PROCESS_SIGNAL_RT14</a> = 46 /* SIGRTMIN + 14 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT15">VIR_DOMAIN_PROCESS_SIGNAL_RT15</a> = 47 /* SIGRTMIN + 15 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT16">VIR_DOMAIN_PROCESS_SIGNAL_RT16</a> = 48 /* SIGRTMIN + 16 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT17">VIR_DOMAIN_PROCESS_SIGNAL_RT17</a> = 49 /* SIGRTMIN + 17 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT18">VIR_DOMAIN_PROCESS_SIGNAL_RT18</a> = 50 /* SIGRTMIN + 18 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT19">VIR_DOMAIN_PROCESS_SIGNAL_RT19</a> = 51 /* SIGRTMIN + 19 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT20">VIR_DOMAIN_PROCESS_SIGNAL_RT20</a> = 52 /* SIGRTMIN + 20 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT21">VIR_DOMAIN_PROCESS_SIGNAL_RT21</a> = 53 /* SIGRTMIN + 21 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT22">VIR_DOMAIN_PROCESS_SIGNAL_RT22</a> = 54 /* SIGRTMIN + 22 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT23">VIR_DOMAIN_PROCESS_SIGNAL_RT23</a> = 55 /* SIGRTMIN + 23 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT24">VIR_DOMAIN_PROCESS_SIGNAL_RT24</a> = 56 /* SIGRTMIN + 24 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT25">VIR_DOMAIN_PROCESS_SIGNAL_RT25</a> = 57 /* SIGRTMIN + 25 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT26">VIR_DOMAIN_PROCESS_SIGNAL_RT26</a> = 58 /* SIGRTMIN + 26 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT27">VIR_DOMAIN_PROCESS_SIGNAL_RT27</a> = 59 /* SIGRTMIN + 27 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT28">VIR_DOMAIN_PROCESS_SIGNAL_RT28</a> = 60 /* SIGRTMIN + 28 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT29">VIR_DOMAIN_PROCESS_SIGNAL_RT29</a> = 61 /* SIGRTMIN + 29 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT30">VIR_DOMAIN_PROCESS_SIGNAL_RT30</a> = 62 /* SIGRTMIN + 30 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT31">VIR_DOMAIN_PROCESS_SIGNAL_RT31</a> = 63 /* SIGRTMIN + 31 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT32">VIR_DOMAIN_PROCESS_SIGNAL_RT32</a> = 64 /* SIGRTMIN + 32 / SIGRTMAX */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_LAST">VIR_DOMAIN_PROCESS_SIGNAL_LAST</a> = 65
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPtr">Typedef </a>virDomainPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomain">virDomain</a> * virDomainPtr;
</pre><p>a <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> is pointer to a <a href="libvirt-libvirt.html#virDomain">virDomain</a> private structure, this is the type used to reference a domain in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRebootFlagValues">Enum </a>virDomainRebootFlagValues</h3><pre class="programlisting">enum <a href="#virDomainRebootFlagValues">virDomainRebootFlagValues</a> {
    <a name="VIR_DOMAIN_REBOOT_DEFAULT">VIR_DOMAIN_REBOOT_DEFAULT</a> = 0 /* hypervisor choice */
    <a name="VIR_DOMAIN_REBOOT_ACPI_POWER_BTN">VIR_DOMAIN_REBOOT_ACPI_POWER_BTN</a> = 1 /* Send ACPI event */
    <a name="VIR_DOMAIN_REBOOT_GUEST_AGENT">VIR_DOMAIN_REBOOT_GUEST_AGENT</a> = 2 /* Use guest agent */
    <a name="VIR_DOMAIN_REBOOT_INITCTL">VIR_DOMAIN_REBOOT_INITCTL</a> = 4 /* Use initctl */
    <a name="VIR_DOMAIN_REBOOT_SIGNAL">VIR_DOMAIN_REBOOT_SIGNAL</a> = 8 /* Send a signal */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRunningReason">Enum </a>virDomainRunningReason</h3><pre class="programlisting">enum <a href="#virDomainRunningReason">virDomainRunningReason</a> {
    <a name="VIR_DOMAIN_RUNNING_UNKNOWN">VIR_DOMAIN_RUNNING_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_RUNNING_BOOTED">VIR_DOMAIN_RUNNING_BOOTED</a> = 1 /* normal startup from boot */
    <a name="VIR_DOMAIN_RUNNING_MIGRATED">VIR_DOMAIN_RUNNING_MIGRATED</a> = 2 /* migrated from another host */
    <a name="VIR_DOMAIN_RUNNING_RESTORED">VIR_DOMAIN_RUNNING_RESTORED</a> = 3 /* restored from a state file */
    <a name="VIR_DOMAIN_RUNNING_FROM_SNAPSHOT">VIR_DOMAIN_RUNNING_FROM_SNAPSHOT</a> = 4 /* restored from snapshot */
    <a name="VIR_DOMAIN_RUNNING_UNPAUSED">VIR_DOMAIN_RUNNING_UNPAUSED</a> = 5 /* returned from paused state */
    <a name="VIR_DOMAIN_RUNNING_MIGRATION_CANCELED">VIR_DOMAIN_RUNNING_MIGRATION_CANCELED</a> = 6 /* returned from migration */
    <a name="VIR_DOMAIN_RUNNING_SAVE_CANCELED">VIR_DOMAIN_RUNNING_SAVE_CANCELED</a> = 7 /* returned from failed save process */
    <a name="VIR_DOMAIN_RUNNING_WAKEUP">VIR_DOMAIN_RUNNING_WAKEUP</a> = 8 /* returned from pmsuspended due to wakeup event */
    <a name="VIR_DOMAIN_RUNNING_CRASHED">VIR_DOMAIN_RUNNING_CRASHED</a> = 9 /* resumed from crashed */
    <a name="VIR_DOMAIN_RUNNING_LAST">VIR_DOMAIN_RUNNING_LAST</a> = 10
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveRestoreFlags">Enum </a>virDomainSaveRestoreFlags</h3><pre class="programlisting">enum <a href="#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a> {
    <a name="VIR_DOMAIN_SAVE_BYPASS_CACHE">VIR_DOMAIN_SAVE_BYPASS_CACHE</a> = 1 /* Avoid file system cache pollution */
    <a name="VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> = 2 /* Favor running over paused */
    <a name="VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> = 4 /* Favor paused over running */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutdownFlagValues">Enum </a>virDomainShutdownFlagValues</h3><pre class="programlisting">enum <a href="#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a> {
    <a name="VIR_DOMAIN_SHUTDOWN_DEFAULT">VIR_DOMAIN_SHUTDOWN_DEFAULT</a> = 0 /* hypervisor choice */
    <a name="VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN">VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN</a> = 1 /* Send ACPI event */
    <a name="VIR_DOMAIN_SHUTDOWN_GUEST_AGENT">VIR_DOMAIN_SHUTDOWN_GUEST_AGENT</a> = 2 /* Use guest agent */
    <a name="VIR_DOMAIN_SHUTDOWN_INITCTL">VIR_DOMAIN_SHUTDOWN_INITCTL</a> = 4 /* Use initctl */
    <a name="VIR_DOMAIN_SHUTDOWN_SIGNAL">VIR_DOMAIN_SHUTDOWN_SIGNAL</a> = 8 /* Send a signal */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutdownReason">Enum </a>virDomainShutdownReason</h3><pre class="programlisting">enum <a href="#virDomainShutdownReason">virDomainShutdownReason</a> {
    <a name="VIR_DOMAIN_SHUTDOWN_UNKNOWN">VIR_DOMAIN_SHUTDOWN_UNKNOWN</a> = 0 /* the reason is unknown */
    <a name="VIR_DOMAIN_SHUTDOWN_USER">VIR_DOMAIN_SHUTDOWN_USER</a> = 1 /* shutting down on user request */
    <a name="VIR_DOMAIN_SHUTDOWN_LAST">VIR_DOMAIN_SHUTDOWN_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutoffReason">Enum </a>virDomainShutoffReason</h3><pre class="programlisting">enum <a href="#virDomainShutoffReason">virDomainShutoffReason</a> {
    <a name="VIR_DOMAIN_SHUTOFF_UNKNOWN">VIR_DOMAIN_SHUTOFF_UNKNOWN</a> = 0 /* the reason is unknown */
    <a name="VIR_DOMAIN_SHUTOFF_SHUTDOWN">VIR_DOMAIN_SHUTOFF_SHUTDOWN</a> = 1 /* normal shutdown */
    <a name="VIR_DOMAIN_SHUTOFF_DESTROYED">VIR_DOMAIN_SHUTOFF_DESTROYED</a> = 2 /* forced poweroff */
    <a name="VIR_DOMAIN_SHUTOFF_CRASHED">VIR_DOMAIN_SHUTOFF_CRASHED</a> = 3 /* domain crashed */
    <a name="VIR_DOMAIN_SHUTOFF_MIGRATED">VIR_DOMAIN_SHUTOFF_MIGRATED</a> = 4 /* migrated to another host */
    <a name="VIR_DOMAIN_SHUTOFF_SAVED">VIR_DOMAIN_SHUTOFF_SAVED</a> = 5 /* saved to a file */
    <a name="VIR_DOMAIN_SHUTOFF_FAILED">VIR_DOMAIN_SHUTOFF_FAILED</a> = 6 /* domain failed to start */
    <a name="VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT">VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT</a> = 7 /* restored from a snapshot which was  taken while domain was shutoff */
    <a name="VIR_DOMAIN_SHUTOFF_LAST">VIR_DOMAIN_SHUTOFF_LAST</a> = 8
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshot">Structure </a>virDomainSnapshot</h3><pre class="programlisting">struct _virDomainSnapshot {
The content of this structure is not made public by the API.
} virDomainSnapshot;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotCreateFlags">Enum </a>virDomainSnapshotCreateFlags</h3><pre class="programlisting">enum <a href="#virDomainSnapshotCreateFlags">virDomainSnapshotCreateFlags</a> {
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE">VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE</a> = 1 /* Restore or alter metadata */
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT">VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT</a> = 2 /* With redefine, make snapshot current */
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA">VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA</a> = 4 /* Make snapshot without remembering it */
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_HALT">VIR_DOMAIN_SNAPSHOT_CREATE_HALT</a> = 8 /* Stop running guest after snapshot */
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY</a> = 16 /* disk snapshot, not system checkpoint */
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT">VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT</a> = 32 /* reuse any existing external files */
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE">VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE</a> = 64 /* use guest agent to quiesce all mounted file systems within the domain */
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC">VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC</a> = 128 /* atomically avoid partial changes */
    <a name="VIR_DOMAIN_SNAPSHOT_CREATE_LIVE">VIR_DOMAIN_SNAPSHOT_CREATE_LIVE</a> = 256 /* create the snapshot while the guest is running */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotDeleteFlags">Enum </a>virDomainSnapshotDeleteFlags</h3><pre class="programlisting">enum <a href="#virDomainSnapshotDeleteFlags">virDomainSnapshotDeleteFlags</a> {
    <a name="VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN">VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN</a> = 1 /* Also delete children */
    <a name="VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY">VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY</a> = 2 /* Delete just metadata */
    <a name="VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY">VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY</a> = 4 /* Delete just children */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotListFlags">Enum </a>virDomainSnapshotListFlags</h3><pre class="programlisting">enum <a href="#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a> {
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS">VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS</a> = 1 /* List all descendants, not just children, when listing a snapshot For historical reasons, groups do not use contiguous bits. */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_ROOTS">VIR_DOMAIN_SNAPSHOT_LIST_ROOTS</a> = 1 /* Filter by snapshots with no parents, when listing a domain */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> = 2 /* Filter by snapshots which have metadata */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> = 4 /* Filter by snapshots with no children */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES</a> = 8 /* Filter by snapshots that have children */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA</a> = 16 /* Filter by snapshots with no metadata */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE</a> = 32 /* Filter by snapshots taken while guest was shut off */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE</a> = 64 /* Filter by snapshots taken while guest was active, and with memory state */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY</a> = 128 /* Filter by snapshots taken while guest was active, but without memory state */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> = 256 /* Filter by snapshots stored internal to disk images */
    <a name="VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL</a> = 512 /* Filter by snapshots that use files external to disk images */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotPtr">Typedef </a>virDomainSnapshotPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainSnapshot">virDomainSnapshot</a> * virDomainSnapshotPtr;
</pre><p>a <a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> is pointer to a <a href="libvirt-libvirt.html#virDomainSnapshot">virDomainSnapshot</a> private structure, and is the type used to reference a domain snapshot in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotRevertFlags">Enum </a>virDomainSnapshotRevertFlags</h3><pre class="programlisting">enum <a href="#virDomainSnapshotRevertFlags">virDomainSnapshotRevertFlags</a> {
    <a name="VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING">VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING</a> = 1 /* Run after revert */
    <a name="VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED">VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED</a> = 2 /* Pause after revert */
    <a name="VIR_DOMAIN_SNAPSHOT_REVERT_FORCE">VIR_DOMAIN_SNAPSHOT_REVERT_FORCE</a> = 4 /* Allow risky reverts */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainState">Enum </a>virDomainState</h3><pre class="programlisting">enum <a href="#virDomainState">virDomainState</a> {
    <a name="VIR_DOMAIN_NOSTATE">VIR_DOMAIN_NOSTATE</a> = 0 /* no state */
    <a name="VIR_DOMAIN_RUNNING">VIR_DOMAIN_RUNNING</a> = 1 /* the domain is running */
    <a name="VIR_DOMAIN_BLOCKED">VIR_DOMAIN_BLOCKED</a> = 2 /* the domain is blocked on resource */
    <a name="VIR_DOMAIN_PAUSED">VIR_DOMAIN_PAUSED</a> = 3 /* the domain is paused by user */
    <a name="VIR_DOMAIN_SHUTDOWN">VIR_DOMAIN_SHUTDOWN</a> = 4 /* the domain is being shut down */
    <a name="VIR_DOMAIN_SHUTOFF">VIR_DOMAIN_SHUTOFF</a> = 5 /* the domain is shut off */
    <a name="VIR_DOMAIN_CRASHED">VIR_DOMAIN_CRASHED</a> = 6 /* the domain is crashed */
    <a name="VIR_DOMAIN_PMSUSPENDED">VIR_DOMAIN_PMSUSPENDED</a> = 7 /* the domain is suspended by guest power management */
    <a name="VIR_DOMAIN_LAST">VIR_DOMAIN_LAST</a> = 8 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last state supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainUndefineFlagsValues">Enum </a>virDomainUndefineFlagsValues</h3><pre class="programlisting">enum <a href="#virDomainUndefineFlagsValues">virDomainUndefineFlagsValues</a> {
    <a name="VIR_DOMAIN_UNDEFINE_MANAGED_SAVE">VIR_DOMAIN_UNDEFINE_MANAGED_SAVE</a> = 1 /* Also remove any managed save */
    <a name="VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA">VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA</a> = 2 /* If last use of domain, then also remove any snapshot metadata Future undefine control flags should come here. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainVcpuFlags">Enum </a>virDomainVcpuFlags</h3><pre class="programlisting">enum <a href="#virDomainVcpuFlags">virDomainVcpuFlags</a> {
    <a name="VIR_DOMAIN_VCPU_CONFIG">VIR_DOMAIN_VCPU_CONFIG</a> = VIR_DOMAIN_AFFECT_CONFIG /* Additionally, these flags may be bitwise-OR'd in. */
    <a name="VIR_DOMAIN_VCPU_CURRENT">VIR_DOMAIN_VCPU_CURRENT</a> = VIR_DOMAIN_AFFECT_CURRENT
    <a name="VIR_DOMAIN_VCPU_LIVE">VIR_DOMAIN_VCPU_LIVE</a> = VIR_DOMAIN_AFFECT_LIVE
    <a name="VIR_DOMAIN_VCPU_MAXIMUM">VIR_DOMAIN_VCPU_MAXIMUM</a> = 4 /* Max rather than current count */
    <a name="VIR_DOMAIN_VCPU_GUEST">VIR_DOMAIN_VCPU_GUEST</a> = 8 /* Modify state of the cpu in the guest */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainXMLFlags">Enum </a>virDomainXMLFlags</h3><pre class="programlisting">enum <a href="#virDomainXMLFlags">virDomainXMLFlags</a> {
    <a name="VIR_DOMAIN_XML_SECURE">VIR_DOMAIN_XML_SECURE</a> = 1 /* dump security sensitive information too */
    <a name="VIR_DOMAIN_XML_INACTIVE">VIR_DOMAIN_XML_INACTIVE</a> = 2 /* dump inactive domain information */
    <a name="VIR_DOMAIN_XML_UPDATE_CPU">VIR_DOMAIN_XML_UPDATE_CPU</a> = 4 /* update guest CPU requirements according to host CPU */
    <a name="VIR_DOMAIN_XML_MIGRATABLE">VIR_DOMAIN_XML_MIGRATABLE</a> = 8 /* dump XML suitable for migration */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventHandleType">Enum </a>virEventHandleType</h3><pre class="programlisting">enum <a href="#virEventHandleType">virEventHandleType</a> {
    <a name="VIR_EVENT_HANDLE_READABLE">VIR_EVENT_HANDLE_READABLE</a> = 1
    <a name="VIR_EVENT_HANDLE_WRITABLE">VIR_EVENT_HANDLE_WRITABLE</a> = 2
    <a name="VIR_EVENT_HANDLE_ERROR">VIR_EVENT_HANDLE_ERROR</a> = 4
    <a name="VIR_EVENT_HANDLE_HANGUP">VIR_EVENT_HANDLE_HANGUP</a> = 8
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterface">Structure </a>virInterface</h3><pre class="programlisting">struct _virInterface {
The content of this structure is not made public by the API.
} virInterface;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfacePtr">Typedef </a>virInterfacePtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virInterface">virInterface</a> * virInterfacePtr;
</pre><p>a <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> is pointer to a <a href="libvirt-libvirt.html#virInterface">virInterface</a> private structure, this is the type used to reference a virtual interface in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceXMLFlags">Enum </a>virInterfaceXMLFlags</h3><pre class="programlisting">enum <a href="#virInterfaceXMLFlags">virInterfaceXMLFlags</a> {
    <a name="VIR_INTERFACE_XML_INACTIVE">VIR_INTERFACE_XML_INACTIVE</a> = 1 /* dump inactive interface information */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virKeycodeSet">Enum </a>virKeycodeSet</h3><pre class="programlisting">enum <a href="#virKeycodeSet">virKeycodeSet</a> {
    <a name="VIR_KEYCODE_SET_LINUX">VIR_KEYCODE_SET_LINUX</a> = 0
    <a name="VIR_KEYCODE_SET_XT">VIR_KEYCODE_SET_XT</a> = 1
    <a name="VIR_KEYCODE_SET_ATSET1">VIR_KEYCODE_SET_ATSET1</a> = 2
    <a name="VIR_KEYCODE_SET_ATSET2">VIR_KEYCODE_SET_ATSET2</a> = 3
    <a name="VIR_KEYCODE_SET_ATSET3">VIR_KEYCODE_SET_ATSET3</a> = 4
    <a name="VIR_KEYCODE_SET_OSX">VIR_KEYCODE_SET_OSX</a> = 5
    <a name="VIR_KEYCODE_SET_XT_KBD">VIR_KEYCODE_SET_XT_KBD</a> = 6
    <a name="VIR_KEYCODE_SET_USB">VIR_KEYCODE_SET_USB</a> = 7
    <a name="VIR_KEYCODE_SET_WIN32">VIR_KEYCODE_SET_WIN32</a> = 8
    <a name="VIR_KEYCODE_SET_RFB">VIR_KEYCODE_SET_RFB</a> = 9
    <a name="VIR_KEYCODE_SET_LAST">VIR_KEYCODE_SET_LAST</a> = 10 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last keycode set supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virMemoryParameter">Structure </a>virMemoryParameter</h3><pre class="programlisting">struct _virTypedParameter {
    char field[VIR_TYPED_PARAM_FIELD_LENGTH]	field	: parameter name
    int	type	: parameter type, <a href="libvirt-libvirt.html#virTypedParameterType">virTypedParameterType</a>
    union	value	: parameter value
} virMemoryParameter;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virMemoryParameterPtr">Typedef </a>virMemoryParameterPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a> * virMemoryParameterPtr;
</pre><p>a <a href="libvirt-libvirt.html#virMemoryParameterPtr">virMemoryParameterPtr</a> is a pointer to a <a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a> structure. Provided for backwards compatibility; <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> is the preferred alias since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virMemoryParameterType">Enum </a>virMemoryParameterType</h3><pre class="programlisting">enum <a href="#virMemoryParameterType">virMemoryParameterType</a> {
    <a name="VIR_DOMAIN_MEMORY_PARAM_BOOLEAN">VIR_DOMAIN_MEMORY_PARAM_BOOLEAN</a> = VIR_TYPED_PARAM_BOOLEAN
    <a name="VIR_DOMAIN_MEMORY_PARAM_DOUBLE">VIR_DOMAIN_MEMORY_PARAM_DOUBLE</a> = VIR_TYPED_PARAM_DOUBLE
    <a name="VIR_DOMAIN_MEMORY_PARAM_INT">VIR_DOMAIN_MEMORY_PARAM_INT</a> = VIR_TYPED_PARAM_INT
    <a name="VIR_DOMAIN_MEMORY_PARAM_LLONG">VIR_DOMAIN_MEMORY_PARAM_LLONG</a> = VIR_TYPED_PARAM_LLONG
    <a name="VIR_DOMAIN_MEMORY_PARAM_UINT">VIR_DOMAIN_MEMORY_PARAM_UINT</a> = VIR_TYPED_PARAM_UINT
    <a name="VIR_DOMAIN_MEMORY_PARAM_ULLONG">VIR_DOMAIN_MEMORY_PARAM_ULLONG</a> = VIR_TYPED_PARAM_ULLONG
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilter">Structure </a>virNWFilter</h3><pre class="programlisting">struct _virNWFilter {
The content of this structure is not made public by the API.
} virNWFilter;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterPtr">Typedef </a>virNWFilterPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilter">virNWFilter</a> * virNWFilterPtr;
</pre><p>a <a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> is pointer to a <a href="libvirt-libvirt.html#virNWFilter">virNWFilter</a> private structure, this is the type used to reference a network filter in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetwork">Structure </a>virNetwork</h3><pre class="programlisting">struct _virNetwork {
The content of this structure is not made public by the API.
} virNetwork;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkPtr">Typedef </a>virNetworkPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetwork">virNetwork</a> * virNetworkPtr;
</pre><p>a <a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> is pointer to a <a href="libvirt-libvirt.html#virNetwork">virNetwork</a> private structure, this is the type used to reference a virtual network in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkUpdateCommand">Enum </a>virNetworkUpdateCommand</h3><pre class="programlisting">enum <a href="#virNetworkUpdateCommand">virNetworkUpdateCommand</a> {
    <a name="VIR_NETWORK_UPDATE_COMMAND_NONE">VIR_NETWORK_UPDATE_COMMAND_NONE</a> = 0 /* (invalid) */
    <a name="VIR_NETWORK_UPDATE_COMMAND_MODIFY">VIR_NETWORK_UPDATE_COMMAND_MODIFY</a> = 1 /* modify an existing element */
    <a name="VIR_NETWORK_UPDATE_COMMAND_DELETE">VIR_NETWORK_UPDATE_COMMAND_DELETE</a> = 2 /* delete an existing element */
    <a name="VIR_NETWORK_UPDATE_COMMAND_ADD_LAST">VIR_NETWORK_UPDATE_COMMAND_ADD_LAST</a> = 3 /* add an element at end of list */
    <a name="VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST">VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST</a> = 4 /* add an element at start of list */
    <a name="VIR_NETWORK_UPDATE_COMMAND_LAST">VIR_NETWORK_UPDATE_COMMAND_LAST</a> = 5
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkUpdateFlags">Enum </a>virNetworkUpdateFlags</h3><pre class="programlisting">enum <a href="#virNetworkUpdateFlags">virNetworkUpdateFlags</a> {
    <a name="VIR_NETWORK_UPDATE_AFFECT_CURRENT">VIR_NETWORK_UPDATE_AFFECT_CURRENT</a> = 0 /* affect live if network is active, config if it's not active */
    <a name="VIR_NETWORK_UPDATE_AFFECT_LIVE">VIR_NETWORK_UPDATE_AFFECT_LIVE</a> = 1 /* affect live state of network only */
    <a name="VIR_NETWORK_UPDATE_AFFECT_CONFIG">VIR_NETWORK_UPDATE_AFFECT_CONFIG</a> = 2 /* affect persistent config only */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkUpdateSection">Enum </a>virNetworkUpdateSection</h3><pre class="programlisting">enum <a href="#virNetworkUpdateSection">virNetworkUpdateSection</a> {
    <a name="VIR_NETWORK_SECTION_NONE">VIR_NETWORK_SECTION_NONE</a> = 0 /* (invalid) */
    <a name="VIR_NETWORK_SECTION_BRIDGE">VIR_NETWORK_SECTION_BRIDGE</a> = 1 /* &lt;bridge&gt; */
    <a name="VIR_NETWORK_SECTION_DOMAIN">VIR_NETWORK_SECTION_DOMAIN</a> = 2 /* &lt;domain&gt; */
    <a name="VIR_NETWORK_SECTION_IP">VIR_NETWORK_SECTION_IP</a> = 3 /* &lt;ip&gt; */
    <a name="VIR_NETWORK_SECTION_IP_DHCP_HOST">VIR_NETWORK_SECTION_IP_DHCP_HOST</a> = 4 /* &lt;ip&gt;/&lt;dhcp&gt;/&lt;host&gt; */
    <a name="VIR_NETWORK_SECTION_IP_DHCP_RANGE">VIR_NETWORK_SECTION_IP_DHCP_RANGE</a> = 5 /* &lt;ip&gt;/&lt;dhcp&gt;/&lt;range&gt; */
    <a name="VIR_NETWORK_SECTION_FORWARD">VIR_NETWORK_SECTION_FORWARD</a> = 6 /* &lt;forward&gt; */
    <a name="VIR_NETWORK_SECTION_FORWARD_INTERFACE">VIR_NETWORK_SECTION_FORWARD_INTERFACE</a> = 7 /* &lt;forward&gt;/&lt;interface&gt; */
    <a name="VIR_NETWORK_SECTION_FORWARD_PF">VIR_NETWORK_SECTION_FORWARD_PF</a> = 8 /* &lt;forward&gt;/&lt;pf&gt; */
    <a name="VIR_NETWORK_SECTION_PORTGROUP">VIR_NETWORK_SECTION_PORTGROUP</a> = 9 /* &lt;portgroup&gt; */
    <a name="VIR_NETWORK_SECTION_DNS_HOST">VIR_NETWORK_SECTION_DNS_HOST</a> = 10 /* &lt;dns&gt;/&lt;host&gt; */
    <a name="VIR_NETWORK_SECTION_DNS_TXT">VIR_NETWORK_SECTION_DNS_TXT</a> = 11 /* &lt;dns&gt;/&lt;txt&gt; */
    <a name="VIR_NETWORK_SECTION_DNS_SRV">VIR_NETWORK_SECTION_DNS_SRV</a> = 12 /* &lt;dns&gt;/&lt;srv&gt; */
    <a name="VIR_NETWORK_SECTION_LAST">VIR_NETWORK_SECTION_LAST</a> = 13
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkXMLFlags">Enum </a>virNetworkXMLFlags</h3><pre class="programlisting">enum <a href="#virNetworkXMLFlags">virNetworkXMLFlags</a> {
    <a name="VIR_NETWORK_XML_INACTIVE">VIR_NETWORK_XML_INACTIVE</a> = 1 /* dump inactive network information */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeCPUStats">Structure </a>virNodeCPUStats</h3><pre class="programlisting">struct _virNodeCPUStats {
    char field[VIR_NODE_CPU_STATS_FIELD_LENGTH]	field
    unsigned long long	value
} virNodeCPUStats;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeCPUStatsPtr">Typedef </a>virNodeCPUStatsPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeCPUStats">virNodeCPUStats</a> * virNodeCPUStatsPtr;
</pre><p>a <a href="libvirt-libvirt.html#virNodeCPUStatsPtr">virNodeCPUStatsPtr</a> is a pointer to a <a href="libvirt-libvirt.html#virNodeCPUStats">virNodeCPUStats</a> structure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDevice">Structure </a>virNodeDevice</h3><pre class="programlisting">struct _virNodeDevice {
The content of this structure is not made public by the API.
} virNodeDevice;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDevicePtr">Typedef </a>virNodeDevicePtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeDevice">virNodeDevice</a> * virNodeDevicePtr;
</pre><p>A <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> is a pointer to a <a href="libvirt-libvirt.html#virNodeDevice">virNodeDevice</a> structure. Get one via virNodeDeviceLookupByName, or virNodeDeviceCreate. Be sure to call <a href="libvirt-libvirt.html#virNodeDeviceFree">virNodeDeviceFree</a> when done using a <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> obtained from any of the above functions to avoid leaking memory.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetCPUStatsAllCPUs">Enum </a>virNodeGetCPUStatsAllCPUs</h3><pre class="programlisting">enum <a href="#virNodeGetCPUStatsAllCPUs">virNodeGetCPUStatsAllCPUs</a> {
    <a name="VIR_NODE_CPU_STATS_ALL_CPUS">VIR_NODE_CPU_STATS_ALL_CPUS</a> = -1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetMemoryStatsAllCells">Enum </a>virNodeGetMemoryStatsAllCells</h3><pre class="programlisting">enum <a href="#virNodeGetMemoryStatsAllCells">virNodeGetMemoryStatsAllCells</a> {
    <a name="VIR_NODE_MEMORY_STATS_ALL_CELLS">VIR_NODE_MEMORY_STATS_ALL_CELLS</a> = -1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeInfo">Structure </a>virNodeInfo</h3><pre class="programlisting">struct _virNodeInfo {
    char model[32]	model	: string indicating the CPU model
    unsigned long	memory	: memory size in kilobytes
    unsigned int	cpus	: the number of active CPUs
    unsigned int	mhz	: expected CPU frequency
    unsigned int	nodes	: the number of NUMA cell, 1 for unusual NUMA topologies or uniform memo
    unsigned int	sockets	: number of CPU sockets per node if nodes &gt; 1, 1 in case of unusual NUMA
    unsigned int	cores	: number of cores per socket, total number of processors in case of unus
    unsigned int	threads	: number of threads per core, 1 in case of unusual numa topology
} virNodeInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeInfoPtr">Typedef </a>virNodeInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> * virNodeInfoPtr;
</pre><p>a <a href="libvirt-libvirt.html#virNodeInfoPtr">virNodeInfoPtr</a> is a pointer to a <a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> structure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeMemoryStats">Structure </a>virNodeMemoryStats</h3><pre class="programlisting">struct _virNodeMemoryStats {
    char field[VIR_NODE_MEMORY_STATS_FIELD_LENGTH]	field
    unsigned long long	value
} virNodeMemoryStats;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeMemoryStatsPtr">Typedef </a>virNodeMemoryStatsPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeMemoryStats">virNodeMemoryStats</a> * virNodeMemoryStatsPtr;
</pre><p>a <a href="libvirt-libvirt.html#virNodeMemoryStatsPtr">virNodeMemoryStatsPtr</a> is a pointer to a <a href="libvirt-libvirt.html#virNodeMemoryStats">virNodeMemoryStats</a> structure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeSuspendTarget">Enum </a>virNodeSuspendTarget</h3><pre class="programlisting">enum <a href="#virNodeSuspendTarget">virNodeSuspendTarget</a> {
    <a name="VIR_NODE_SUSPEND_TARGET_MEM">VIR_NODE_SUSPEND_TARGET_MEM</a> = 0
    <a name="VIR_NODE_SUSPEND_TARGET_DISK">VIR_NODE_SUSPEND_TARGET_DISK</a> = 1
    <a name="VIR_NODE_SUSPEND_TARGET_HYBRID">VIR_NODE_SUSPEND_TARGET_HYBRID</a> = 2
    <a name="VIR_NODE_SUSPEND_TARGET_LAST">VIR_NODE_SUSPEND_TARGET_LAST</a> = 3 /* This constant is subject to change */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSchedParameter">Structure </a>virSchedParameter</h3><pre class="programlisting">struct _virTypedParameter {
    char field[VIR_TYPED_PARAM_FIELD_LENGTH]	field	: parameter name
    int	type	: parameter type, <a href="libvirt-libvirt.html#virTypedParameterType">virTypedParameterType</a>
    union	value	: parameter value
} virSchedParameter;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSchedParameterPtr">Typedef </a>virSchedParameterPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSchedParameter">virSchedParameter</a> * virSchedParameterPtr;
</pre><p>a <a href="libvirt-libvirt.html#virSchedParameterPtr">virSchedParameterPtr</a> is a pointer to a <a href="libvirt-libvirt.html#virSchedParameter">virSchedParameter</a> structure. Provided for backwards compatibility; <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> is the preferred alias since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSchedParameterType">Enum </a>virSchedParameterType</h3><pre class="programlisting">enum <a href="#virSchedParameterType">virSchedParameterType</a> {
    <a name="VIR_DOMAIN_SCHED_FIELD_BOOLEAN">VIR_DOMAIN_SCHED_FIELD_BOOLEAN</a> = VIR_TYPED_PARAM_BOOLEAN
    <a name="VIR_DOMAIN_SCHED_FIELD_DOUBLE">VIR_DOMAIN_SCHED_FIELD_DOUBLE</a> = VIR_TYPED_PARAM_DOUBLE
    <a name="VIR_DOMAIN_SCHED_FIELD_INT">VIR_DOMAIN_SCHED_FIELD_INT</a> = VIR_TYPED_PARAM_INT
    <a name="VIR_DOMAIN_SCHED_FIELD_LLONG">VIR_DOMAIN_SCHED_FIELD_LLONG</a> = VIR_TYPED_PARAM_LLONG
    <a name="VIR_DOMAIN_SCHED_FIELD_UINT">VIR_DOMAIN_SCHED_FIELD_UINT</a> = VIR_TYPED_PARAM_UINT
    <a name="VIR_DOMAIN_SCHED_FIELD_ULLONG">VIR_DOMAIN_SCHED_FIELD_ULLONG</a> = VIR_TYPED_PARAM_ULLONG
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecret">Structure </a>virSecret</h3><pre class="programlisting">struct _virSecret {
The content of this structure is not made public by the API.
} virSecret;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretPtr">Typedef </a>virSecretPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecret">virSecret</a> * virSecretPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretUsageType">Enum </a>virSecretUsageType</h3><pre class="programlisting">enum <a href="#virSecretUsageType">virSecretUsageType</a> {
    <a name="VIR_SECRET_USAGE_TYPE_NONE">VIR_SECRET_USAGE_TYPE_NONE</a> = 0
    <a name="VIR_SECRET_USAGE_TYPE_VOLUME">VIR_SECRET_USAGE_TYPE_VOLUME</a> = 1
    <a name="VIR_SECRET_USAGE_TYPE_CEPH">VIR_SECRET_USAGE_TYPE_CEPH</a> = 2
    <a name="VIR_SECRET_USAGE_TYPE_ISCSI">VIR_SECRET_USAGE_TYPE_ISCSI</a> = 3
    <a name="VIR_SECRET_USAGE_TYPE_LAST">VIR_SECRET_USAGE_TYPE_LAST</a> = 4 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last secret owner ID  supported by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecurityLabel">Structure </a>virSecurityLabel</h3><pre class="programlisting">struct _virSecurityLabel {
The content of this structure is not made public by the API.
} virSecurityLabel;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecurityLabelPtr">Typedef </a>virSecurityLabelPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> * virSecurityLabelPtr;
</pre><p>a <a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> is a pointer to a virSecurityLabel.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecurityModel">Structure </a>virSecurityModel</h3><pre class="programlisting">struct _virSecurityModel {
The content of this structure is not made public by the API.
} virSecurityModel;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecurityModelPtr">Typedef </a>virSecurityModelPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> * virSecurityModelPtr;
</pre><p>a <a href="libvirt-libvirt.html#virSecurityModelPtr">virSecurityModelPtr</a> is a pointer to a virSecurityModel.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePool">Structure </a>virStoragePool</h3><pre class="programlisting">struct _virStoragePool {
The content of this structure is not made public by the API.
} virStoragePool;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolBuildFlags">Enum </a>virStoragePoolBuildFlags</h3><pre class="programlisting">enum <a href="#virStoragePoolBuildFlags">virStoragePoolBuildFlags</a> {
    <a name="VIR_STORAGE_POOL_BUILD_NEW">VIR_STORAGE_POOL_BUILD_NEW</a> = 0 /* Regular build from scratch */
    <a name="VIR_STORAGE_POOL_BUILD_REPAIR">VIR_STORAGE_POOL_BUILD_REPAIR</a> = 1 /* Repair / reinitialize */
    <a name="VIR_STORAGE_POOL_BUILD_RESIZE">VIR_STORAGE_POOL_BUILD_RESIZE</a> = 2 /* Extend existing pool */
    <a name="VIR_STORAGE_POOL_BUILD_NO_OVERWRITE">VIR_STORAGE_POOL_BUILD_NO_OVERWRITE</a> = 4 /* Do not overwrite existing pool */
    <a name="VIR_STORAGE_POOL_BUILD_OVERWRITE">VIR_STORAGE_POOL_BUILD_OVERWRITE</a> = 8 /* Overwrite data */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolDeleteFlags">Enum </a>virStoragePoolDeleteFlags</h3><pre class="programlisting">enum <a href="#virStoragePoolDeleteFlags">virStoragePoolDeleteFlags</a> {
    <a name="VIR_STORAGE_POOL_DELETE_NORMAL">VIR_STORAGE_POOL_DELETE_NORMAL</a> = 0 /* Delete metadata only    (fast) */
    <a name="VIR_STORAGE_POOL_DELETE_ZEROED">VIR_STORAGE_POOL_DELETE_ZEROED</a> = 1 /* Clear all data to zeros (slow) */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolInfo">Structure </a>virStoragePoolInfo</h3><pre class="programlisting">struct _virStoragePoolInfo {
    int	state	: <a href="libvirt-libvirt.html#virStoragePoolState">virStoragePoolState</a> flags
    unsigned long long	capacity	: Logical size bytes
    unsigned long long	allocation	: Current allocation bytes
    unsigned long long	available	: Remaining free space bytes
} virStoragePoolInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolInfoPtr">Typedef </a>virStoragePoolInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolInfo">virStoragePoolInfo</a> * virStoragePoolInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolPtr">Typedef </a>virStoragePoolPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePool">virStoragePool</a> * virStoragePoolPtr;
</pre><p>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> is pointer to a <a href="libvirt-libvirt.html#virStoragePool">virStoragePool</a> private structure, this is the type used to reference a storage pool in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolState">Enum </a>virStoragePoolState</h3><pre class="programlisting">enum <a href="#virStoragePoolState">virStoragePoolState</a> {
    <a name="VIR_STORAGE_POOL_INACTIVE">VIR_STORAGE_POOL_INACTIVE</a> = 0 /* Not running */
    <a name="VIR_STORAGE_POOL_BUILDING">VIR_STORAGE_POOL_BUILDING</a> = 1 /* Initializing pool, not available */
    <a name="VIR_STORAGE_POOL_RUNNING">VIR_STORAGE_POOL_RUNNING</a> = 2 /* Running normally */
    <a name="VIR_STORAGE_POOL_DEGRADED">VIR_STORAGE_POOL_DEGRADED</a> = 3 /* Running degraded */
    <a name="VIR_STORAGE_POOL_INACCESSIBLE">VIR_STORAGE_POOL_INACCESSIBLE</a> = 4 /* Running, but not accessible */
    <a name="VIR_STORAGE_POOL_STATE_LAST">VIR_STORAGE_POOL_STATE_LAST</a> = 5
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVol">Structure </a>virStorageVol</h3><pre class="programlisting">struct _virStorageVol {
The content of this structure is not made public by the API.
} virStorageVol;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolCreateFlags">Enum </a>virStorageVolCreateFlags</h3><pre class="programlisting">enum <a href="#virStorageVolCreateFlags">virStorageVolCreateFlags</a> {
    <a name="VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA">VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolDeleteFlags">Enum </a>virStorageVolDeleteFlags</h3><pre class="programlisting">enum <a href="#virStorageVolDeleteFlags">virStorageVolDeleteFlags</a> {
    <a name="VIR_STORAGE_VOL_DELETE_NORMAL">VIR_STORAGE_VOL_DELETE_NORMAL</a> = 0 /* Delete metadata only    (fast) */
    <a name="VIR_STORAGE_VOL_DELETE_ZEROED">VIR_STORAGE_VOL_DELETE_ZEROED</a> = 1 /* Clear all data to zeros (slow) */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolInfo">Structure </a>virStorageVolInfo</h3><pre class="programlisting">struct _virStorageVolInfo {
    int	type	: <a href="libvirt-libvirt.html#virStorageVolType">virStorageVolType</a> flags
    unsigned long long	capacity	: Logical size bytes
    unsigned long long	allocation	: Current allocation bytes
} virStorageVolInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolInfoPtr">Typedef </a>virStorageVolInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolInfo">virStorageVolInfo</a> * virStorageVolInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolPtr">Typedef </a>virStorageVolPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVol">virStorageVol</a> * virStorageVolPtr;
</pre><p>a <a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> is pointer to a <a href="libvirt-libvirt.html#virStorageVol">virStorageVol</a> private structure, this is the type used to reference a storage volume in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolResizeFlags">Enum </a>virStorageVolResizeFlags</h3><pre class="programlisting">enum <a href="#virStorageVolResizeFlags">virStorageVolResizeFlags</a> {
    <a name="VIR_STORAGE_VOL_RESIZE_ALLOCATE">VIR_STORAGE_VOL_RESIZE_ALLOCATE</a> = 1 /* force allocation of new size */
    <a name="VIR_STORAGE_VOL_RESIZE_DELTA">VIR_STORAGE_VOL_RESIZE_DELTA</a> = 2 /* size is relative to current */
    <a name="VIR_STORAGE_VOL_RESIZE_SHRINK">VIR_STORAGE_VOL_RESIZE_SHRINK</a> = 4 /* allow decrease in capacity */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolType">Enum </a>virStorageVolType</h3><pre class="programlisting">enum <a href="#virStorageVolType">virStorageVolType</a> {
    <a name="VIR_STORAGE_VOL_FILE">VIR_STORAGE_VOL_FILE</a> = 0 /* Regular file based volumes */
    <a name="VIR_STORAGE_VOL_BLOCK">VIR_STORAGE_VOL_BLOCK</a> = 1 /* Block based volumes */
    <a name="VIR_STORAGE_VOL_DIR">VIR_STORAGE_VOL_DIR</a> = 2 /* Directory-passthrough based volume */
    <a name="VIR_STORAGE_VOL_NETWORK">VIR_STORAGE_VOL_NETWORK</a> = 3 /* Network volumes like RBD (RADOS Block Device) */
    <a name="VIR_STORAGE_VOL_NETDIR">VIR_STORAGE_VOL_NETDIR</a> = 4 /* Network accessible directory that can  contain other network volumes */
    <a name="VIR_STORAGE_VOL_LAST">VIR_STORAGE_VOL_LAST</a> = 5
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolWipeAlgorithm">Enum </a>virStorageVolWipeAlgorithm</h3><pre class="programlisting">enum <a href="#virStorageVolWipeAlgorithm">virStorageVolWipeAlgorithm</a> {
    <a name="VIR_STORAGE_VOL_WIPE_ALG_ZERO">VIR_STORAGE_VOL_WIPE_ALG_ZERO</a> = 0 /* 1-pass, all zeroes */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_NNSA">VIR_STORAGE_VOL_WIPE_ALG_NNSA</a> = 1 /* 4-pass  NNSA Policy Letter NAP-14.1-C (XVI-8) */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_DOD">VIR_STORAGE_VOL_WIPE_ALG_DOD</a> = 2 /* 4-pass DoD 5220.22-M section 8-306 procedure */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_BSI">VIR_STORAGE_VOL_WIPE_ALG_BSI</a> = 3 /* 9-pass method recommended by the German Center of Security in Information Technologies */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_GUTMANN">VIR_STORAGE_VOL_WIPE_ALG_GUTMANN</a> = 4 /* The canonical 35-pass sequence */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER">VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER</a> = 5 /* 7-pass method described by Bruce Schneier in "Applied Cryptography" (1996) */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7">VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7</a> = 6 /* 7-pass random */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33">VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33</a> = 7 /* 33-pass random */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_RANDOM">VIR_STORAGE_VOL_WIPE_ALG_RANDOM</a> = 8 /* 1-pass random */
    <a name="VIR_STORAGE_VOL_WIPE_ALG_LAST">VIR_STORAGE_VOL_WIPE_ALG_LAST</a> = 9 /* NB: this enum value will increase over time as new algorithms are  added to the libvirt API. It reflects the last algorithm supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageXMLFlags">Enum </a>virStorageXMLFlags</h3><pre class="programlisting">enum <a href="#virStorageXMLFlags">virStorageXMLFlags</a> {
    <a name="VIR_STORAGE_XML_INACTIVE">VIR_STORAGE_XML_INACTIVE</a> = 1 /* dump inactive pool/volume information */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStream">Structure </a>virStream</h3><pre class="programlisting">struct _virStream {
The content of this structure is not made public by the API.
} virStream;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventType">Enum </a>virStreamEventType</h3><pre class="programlisting">enum <a href="#virStreamEventType">virStreamEventType</a> {
    <a name="VIR_STREAM_EVENT_READABLE">VIR_STREAM_EVENT_READABLE</a> = 1
    <a name="VIR_STREAM_EVENT_WRITABLE">VIR_STREAM_EVENT_WRITABLE</a> = 2
    <a name="VIR_STREAM_EVENT_ERROR">VIR_STREAM_EVENT_ERROR</a> = 4
    <a name="VIR_STREAM_EVENT_HANGUP">VIR_STREAM_EVENT_HANGUP</a> = 8
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamFlags">Enum </a>virStreamFlags</h3><pre class="programlisting">enum <a href="#virStreamFlags">virStreamFlags</a> {
    <a name="VIR_STREAM_NONBLOCK">VIR_STREAM_NONBLOCK</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamPtr">Typedef </a>virStreamPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStream">virStream</a> * virStreamPtr;
</pre><p>a <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> is pointer to a <a href="libvirt-libvirt.html#virStream">virStream</a> private structure, this is the type used to reference a data stream in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParameter">Structure </a>virTypedParameter</h3><pre class="programlisting">struct _virTypedParameter {
    char field[VIR_TYPED_PARAM_FIELD_LENGTH]	field	: parameter name
    int	type	: parameter type, <a href="libvirt-libvirt.html#virTypedParameterType">virTypedParameterType</a>
    union	value	: parameter value
} virTypedParameter;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParameterFlags">Enum </a>virTypedParameterFlags</h3><pre class="programlisting">enum <a href="#virTypedParameterFlags">virTypedParameterFlags</a> {
    <a name="VIR_TYPED_PARAM_STRING_OKAY">VIR_TYPED_PARAM_STRING_OKAY</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParameterPtr">Typedef </a>virTypedParameterPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virTypedParameter">virTypedParameter</a> * virTypedParameterPtr;
</pre><p>a pointer to a <a href="libvirt-libvirt.html#virTypedParameter">virTypedParameter</a> structure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParameterType">Enum </a>virTypedParameterType</h3><pre class="programlisting">enum <a href="#virTypedParameterType">virTypedParameterType</a> {
    <a name="VIR_TYPED_PARAM_INT">VIR_TYPED_PARAM_INT</a> = 1 /* integer case */
    <a name="VIR_TYPED_PARAM_UINT">VIR_TYPED_PARAM_UINT</a> = 2 /* unsigned integer case */
    <a name="VIR_TYPED_PARAM_LLONG">VIR_TYPED_PARAM_LLONG</a> = 3 /* long long case */
    <a name="VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a> = 4 /* unsigned long long case */
    <a name="VIR_TYPED_PARAM_DOUBLE">VIR_TYPED_PARAM_DOUBLE</a> = 5 /* double case */
    <a name="VIR_TYPED_PARAM_BOOLEAN">VIR_TYPED_PARAM_BOOLEAN</a> = 6 /* boolean(character) case */
    <a name="VIR_TYPED_PARAM_STRING">VIR_TYPED_PARAM_STRING</a> = 7 /* string case */
    <a name="VIR_TYPED_PARAM_LAST">VIR_TYPED_PARAM_LAST</a> = 8
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virVcpuInfo">Structure </a>virVcpuInfo</h3><pre class="programlisting">struct _virVcpuInfo {
    unsigned int	number	: virtual CPU number
    int	state	: value from <a href="libvirt-libvirt.html#virVcpuState">virVcpuState</a>
    unsigned long long	cpuTime	: CPU time used, in nanoseconds
    int	cpu	: real CPU number, or -1 if offline
} virVcpuInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virVcpuInfoPtr">Typedef </a>virVcpuInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virVcpuInfo">virVcpuInfo</a> * virVcpuInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virVcpuState">Enum </a>virVcpuState</h3><pre class="programlisting">enum <a href="#virVcpuState">virVcpuState</a> {
    <a name="VIR_VCPU_OFFLINE">VIR_VCPU_OFFLINE</a> = 0 /* the virtual CPU is offline */
    <a name="VIR_VCPU_RUNNING">VIR_VCPU_RUNNING</a> = 1 /* the virtual CPU is running */
    <a name="VIR_VCPU_BLOCKED">VIR_VCPU_BLOCKED</a> = 2 /* the virtual CPU is blocked on resource */
    <a name="VIR_VCPU_LAST">VIR_VCPU_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectAuthCallbackPtr"/>Function type virConnectAuthCallbackPtr</h3><pre class="programlisting">int	virConnectAuthCallbackPtr	(<a href="libvirt-libvirt.html#virConnectCredentialPtr">virConnectCredentialPtr</a> cred, <br/>					 unsigned int ncred, <br/>					 void * cbdata)<br/>
</pre><p>When authentication requires one or more interactions, this callback
is invoked. For each interaction supplied, data must be gathered
from the user and filled in to the 'result' and 'resultlen' fields.
If an interaction cannot be filled, fill in NULL and 0.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cred</tt></i>:</span></td><td>list of <a href="libvirt-libvirt.html#virConnectCredential">virConnectCredential</a> object to fetch from user</td></tr><tr><td><span class="term"><i><tt>ncred</tt></i>:</span></td><td>size of cred list</td></tr><tr><td><span class="term"><i><tt>cbdata</tt></i>:</span></td><td>opaque data passed to <a href="libvirt-libvirt.html#virConnectOpenAuth">virConnectOpenAuth</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all interactions were filled, or -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectCloseFunc"/>Function type virConnectCloseFunc</h3><pre class="programlisting">void	virConnectCloseFunc		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int reason, <br/>					 void * opaque)<br/>
</pre><p>A callback function to be registered, and called when the connection
is closed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why the connection was closed (one of virConnectCloseReason)</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque user data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventBalloonChangeCallback"/>Function type virConnectDomainEventBalloonChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventBalloonChangeCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 unsigned long long actual, <br/>							 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>actual</tt></i>:</span></td><td>the new balloon level measured in kibibytes(blocks of 1024 bytes)</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventBlockJobCallback"/>Function type virConnectDomainEventBlockJobCallback</h3><pre class="programlisting">void	virConnectDomainEventBlockJobCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * disk, <br/>						 int type, <br/>						 int status, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_BLOCK_JOB with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>fully-qualified filename of the affected disk</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of block job (virDomainBlockJobType)</td></tr><tr><td><span class="term"><i><tt>status</tt></i>:</span></td><td>final status of the operation (virConnectDomainEventBlockJobStatus)</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventCallback"/>Function type virConnectDomainEventCallback</h3><pre class="programlisting">int	virConnectDomainEventCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 int event, <br/>					 int detail, <br/>					 void * opaque)<br/>
</pre><p>A callback function to be registered, and called when a domain event occurs</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>The domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>event</tt></i>:</span></td><td>The specific <a href="libvirt-libvirt.html#virDomainEventType">virDomainEventType</a> which occurred</td></tr><tr><td><span class="term"><i><tt>detail</tt></i>:</span></td><td>event specific detail information</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque user data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 (the return value is currently ignored)</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDeviceRemovedCallback"/>Function type virConnectDomainEventDeviceRemovedCallback</h3><pre class="programlisting">void	virConnectDomainEventDeviceRemovedCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * devAlias, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs when a device is removed from the domain.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>device alias</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDiskChangeCallback"/>Function type virConnectDomainEventDiskChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventDiskChangeCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * oldSrcPath, <br/>						 const char * newSrcPath, <br/>						 const char * devAlias, <br/>						 int reason, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when disk gets changed. However,
not all @reason will cause both @oldSrcPath and @newSrcPath
to be non-NULL. Please see virConnectDomainEventDiskChangeReason
for more details.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DISK_CHANGE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>oldSrcPath</tt></i>:</span></td><td>old source path</td></tr><tr><td><span class="term"><i><tt>newSrcPath</tt></i>:</span></td><td>new source path</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>device alias name</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why this callback was called; any of <a href="libvirt-libvirt.html#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a></td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventGenericCallback"/>Function type virConnectDomainEventGenericCallback</h3><pre class="programlisting">void	virConnectDomainEventGenericCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 void * opaque)<br/>
</pre><p>A generic domain event callback handler. Specific events usually
have a customization with extra parameters</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>the connection pointer</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>the domain pointer</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventGraphicsCallback"/>Function type virConnectDomainEventGraphicsCallback</h3><pre class="programlisting">void	virConnectDomainEventGraphicsCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int phase, <br/>						 const <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * local, <br/>						 const <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * remote, <br/>						 const char * authScheme, <br/>						 const <a href="libvirt-libvirt.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * subject, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_GRAPHICS with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>phase</tt></i>:</span></td><td>the phase of the connection</td></tr><tr><td><span class="term"><i><tt>local</tt></i>:</span></td><td>the local server address</td></tr><tr><td><span class="term"><i><tt>remote</tt></i>:</span></td><td>the remote client address</td></tr><tr><td><span class="term"><i><tt>authScheme</tt></i>:</span></td><td>the authentication scheme activated</td></tr><tr><td><span class="term"><i><tt>subject</tt></i>:</span></td><td>the authenticated subject (user)</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventIOErrorCallback"/>Function type virConnectDomainEventIOErrorCallback</h3><pre class="programlisting">void	virConnectDomainEventIOErrorCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * srcPath, <br/>						 const char * devAlias, <br/>						 int action, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>srcPath</tt></i>:</span></td><td>The host file on which the IO error occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>The guest device alias associated with the path</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to the IO error</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventIOErrorReasonCallback"/>Function type virConnectDomainEventIOErrorReasonCallback</h3><pre class="programlisting">void	virConnectDomainEventIOErrorReasonCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * srcPath, <br/>							 const char * devAlias, <br/>							 int action, <br/>							 const char * reason, <br/>							 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>srcPath</tt></i>:</span></td><td>The host file on which the IO error occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>The guest device alias associated with the path</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to the IO error</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>the cause of the IO error</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventPMSuspendCallback"/>Function type virConnectDomainEventPMSuspendCallback</h3><pre class="programlisting">void	virConnectDomainEventPMSuspendCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int reason, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when the guest is waken up.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMSUSPEND with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why the callback was called, unused currently, always passes 0</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventPMSuspendDiskCallback"/>Function type virConnectDomainEventPMSuspendDiskCallback</h3><pre class="programlisting">void	virConnectDomainEventPMSuspendDiskCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int reason, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs when the guest is suspended to disk.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why the callback was called, unused currently, always passes 0</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventPMWakeupCallback"/>Function type virConnectDomainEventPMWakeupCallback</h3><pre class="programlisting">void	virConnectDomainEventPMWakeupCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int reason, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when the guest is waken up.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMWAKEUP with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why the callback was called, unused currently, always passes 0</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventRTCChangeCallback"/>Function type virConnectDomainEventRTCChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventRTCChangeCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 long long utcoffset, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_RTC_CHANGE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>utcoffset</tt></i>:</span></td><td>the new RTC offset from UTC, measured in seconds</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventTrayChangeCallback"/>Function type virConnectDomainEventTrayChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventTrayChangeCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * devAlias, <br/>						 int reason, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when the tray of a removable device is moved.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_TRAY_CHANGE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>device alias</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>why the tray status was changed?</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventWatchdogCallback"/>Function type virConnectDomainEventWatchdogCallback</h3><pre class="programlisting">void	virConnectDomainEventWatchdogCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int action, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_WATCHDOG with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to watchdog firing</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventAddHandleFunc"/>Function type virEventAddHandleFunc</h3><pre class="programlisting">int	virEventAddHandleFunc		(int fd, <br/>					 int event, <br/>					 <a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)<br/>
</pre><p>Part of the EventImpl, this callback adds a file handle callback to
listen for specific events. The same file handle can be registered
multiple times provided the requested event sets are non-overlapping

If the opaque user data requires free'ing when the handle
is unregistered, then a 2nd callback can be supplied for
this purpose. This callback needs to be invoked from a clean stack.
If 'ff' callbacks are invoked directly from the virEventRemoveHandleFunc
they will likely deadlock in libvirt.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>file descriptor to listen on</td></tr><tr><td><span class="term"><i><tt>event</tt></i>:</span></td><td>bitset of events on which to fire the callback</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>the callback to be called when an event occurrs</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data to pass to the callback</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>the callback invoked to free opaque data blob</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 if the file handle cannot be registered, otherwise a handle watch number to be used for updating and unregistering for events</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventAddTimeoutFunc"/>Function type virEventAddTimeoutFunc</h3><pre class="programlisting">int	virEventAddTimeoutFunc		(int timeout, <br/>					 <a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)<br/>
</pre><p>Part of the EventImpl, this user-defined callback handles adding an
event timeout.

If the opaque user data requires free'ing when the handle
is unregistered, then a 2nd callback can be supplied for
this purpose.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>timeout</tt></i>:</span></td><td>The timeout to monitor</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>the callback to call when timeout has expired</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data to pass to the callback</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>the callback invoked to free opaque data blob</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a timer value</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventHandleCallback"/>Function type virEventHandleCallback</h3><pre class="programlisting">void	virEventHandleCallback		(int watch, <br/>					 int fd, <br/>					 int events, <br/>					 void * opaque)<br/>
</pre><p>Callback for receiving file handle events. The callback will
be invoked once for each event which is pending.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>watch</tt></i>:</span></td><td>watch on which the event occurred</td></tr><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>file handle on which the event occurred</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>bitset of events from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data registered with handle</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventRemoveHandleFunc"/>Function type virEventRemoveHandleFunc</h3><pre class="programlisting">int	virEventRemoveHandleFunc	(int watch)<br/>
</pre><p>Part of the EventImpl, this user-provided callback is notified when
an fd is no longer being listened on.

If a virEventHandleFreeFunc was supplied when the handle was
registered, it will be invoked some time during, or after this
function call, when it is safe to release the user data.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>watch</tt></i>:</span></td><td>file descriptor watch to stop listening on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 if the file handle was not registered, 0 upon success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventRemoveTimeoutFunc"/>Function type virEventRemoveTimeoutFunc</h3><pre class="programlisting">int	virEventRemoveTimeoutFunc	(int timer)<br/>
</pre><p>Part of the EventImpl, this user-defined callback removes a timer

If a virEventTimeoutFreeFunc was supplied when the handle was
registered, it will be invoked some time during, or after this
function call, when it is safe to release the user data.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>timer</tt></i>:</span></td><td>the timer to remove</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventTimeoutCallback"/>Function type virEventTimeoutCallback</h3><pre class="programlisting">void	virEventTimeoutCallback		(int timer, <br/>					 void * opaque)<br/>
</pre><p>callback for receiving timer events</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>timer</tt></i>:</span></td><td>timer id emitting the event</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data registered with handle</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventUpdateHandleFunc"/>Function type virEventUpdateHandleFunc</h3><pre class="programlisting">void	virEventUpdateHandleFunc	(int watch, <br/>					 int event)<br/>
</pre><p>Part of the EventImpl, this user-provided callback is notified when
events to listen on change</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>watch</tt></i>:</span></td><td>file descriptor watch to modify</td></tr><tr><td><span class="term"><i><tt>event</tt></i>:</span></td><td>new events to listen on</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventUpdateTimeoutFunc"/>Function type virEventUpdateTimeoutFunc</h3><pre class="programlisting">void	virEventUpdateTimeoutFunc	(int timer, <br/>					 int timeout)<br/>
</pre><p>Part of the EventImpl, this user-defined callback updates an
event timeout.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>timer</tt></i>:</span></td><td>the timer to modify</td></tr><tr><td><span class="term"><i><tt>timeout</tt></i>:</span></td><td>the new timeout value</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virFreeCallback"/>Function type virFreeCallback</h3><pre class="programlisting">void	virFreeCallback			(void * opaque)<br/>
</pre><p>Type for a callback cleanup function to be paired with a callback. This
function will be called as a final chance to clean up the @opaque
registered with the primary callback, at the time when the primary
callback is deregistered.

It is forbidden to call any other libvirt APIs from an
implementation of this callback, since it can be invoked
from a context which is not re-entrant safe. Failure to
abide by this requirement may lead to application deadlocks
or crashes.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque user data provided at registration</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventCallback"/>Function type virStreamEventCallback</h3><pre class="programlisting">void	virStreamEventCallback		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events, <br/>					 void * opaque)<br/>
</pre><p>Callback for receiving stream events. The callback will
be invoked once for each event which is pending.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>stream on which the event occurred</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>bitset of events from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data registered with handle</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSinkFunc"/>Function type virStreamSinkFunc</h3><pre class="programlisting">int	virStreamSinkFunc		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br/>					 const char * data, <br/>					 size_t nbytes, <br/>					 void * opaque)<br/>
</pre><p>The <a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a> callback is used together
with the <a href="libvirt-libvirt.html#virStreamRecvAll">virStreamRecvAll</a> function for libvirt to
provide the data that has been received.

The callback will be invoked multiple times,
providing data in small chunks. The application
should consume up 'nbytes' from the 'data' array
of data and then return the number actual number
of bytes consumed. The callback will continue to be
invoked until it indicates the end of the stream
has been reached. A return value of -1 at any time
will abort the receive operation</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>preallocated array to be filled with data</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of the data array</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes consumed or -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSourceFunc"/>Function type virStreamSourceFunc</h3><pre class="programlisting">int	virStreamSourceFunc		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br/>					 char * data, <br/>					 size_t nbytes, <br/>					 void * opaque)<br/>
</pre><p>The <a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a> callback is used together
with the <a href="libvirt-libvirt.html#virStreamSendAll">virStreamSendAll</a> function for libvirt to
obtain the data that is to be sent.

The callback will be invoked multiple times,
fetching data in small chunks. The application
should fill the 'data' array with up to 'nbytes'
of data and then return the number actual number
of bytes. The callback will continue to be
invoked until it indicates the end of the source
has been reached by returning 0. A return value
of -1 at any time will abort the send operation</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>preallocated array to be filled with data</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of the data array</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes filled, 0 upon end of file, or -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectAuthPtrDefault">Variable </a>virConnectAuthPtrDefault</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectAuthPtr">virConnectAuthPtr</a> virConnectAuthPtrDefault;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectBaselineCPU"/>virConnectBaselineCPU ()</h3><pre class="programlisting">char *	virConnectBaselineCPU		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char ** xmlCPUs, <br/>					 unsigned int ncpus, <br/>					 unsigned int flags)<br/>
</pre><p>Computes the most feature-rich CPU which is compatible with all given
host CPUs.

If @flags includes <a href="libvirt-libvirt.html#VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES">VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES</a> then libvirt
will explicitly list all CPU features that are part of the host CPU,
without this flag features that are part of the CPU model will not be
listed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>xmlCPUs</tt></i>:</span></td><td>array of XML descriptions of host CPUs</td></tr><tr><td><span class="term"><i><tt>ncpus</tt></i>:</span></td><td>number of CPUs in xmlCPUs</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virConnectBaselineCPUFlags">virConnectBaselineCPUFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>XML description of the computed CPU or NULL on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectClose"/>virConnectClose ()</h3><pre class="programlisting">int	virConnectClose			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>This function closes the connection to the Hypervisor. This should
not be called if further interaction with the Hypervisor are needed
especially if there is running domain which need further monitoring by
the application.

Connections are reference counted; the count is explicitly
increased by the initial open (virConnectOpen, virConnectOpenAuth,
and the like) as well as virConnectRef; it is also temporarily
increased by other API that depend on the connection remaining
alive. The open and every <a href="libvirt-libvirt.html#virConnectRef">virConnectRef</a> call should have a
matching virConnectClose, and all other references will be released
after the corresponding operation completes.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a positive number if at least 1 reference remains on success. The returned value should not be assumed to be the total reference count. A return of 0 implies no references remain and the connection is closed and memory has been freed. A return of -1 implies a failure. It is possible for the last <a href="libvirt-libvirt.html#virConnectClose">virConnectClose</a> to return a positive value if some other object still has a temporary reference to the connection, but the application should not try to further use a connection after the <a href="libvirt-libvirt.html#virConnectClose">virConnectClose</a> that matches the initial open.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectCompareCPU"/>virConnectCompareCPU ()</h3><pre class="programlisting">int	virConnectCompareCPU		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags)<br/>
</pre><p>Compares the given CPU description with the host CPU</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>XML describing the CPU to compare with host CPU</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>comparison result according to enum <a href="libvirt-libvirt.html#virCPUCompareResult">virCPUCompareResult</a></td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDeregister"/>virConnectDomainEventDeregister ()</h3><pre class="programlisting">int	virConnectDomainEventDeregister	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb)<br/>
</pre><p>Removes a callback previously registered with the virConnectDomainEventRegister
function.

Use of this method is no longer recommended. Instead applications
should try virConnectDomainEventUnregisterAny which has a more flexible
API contract</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDeregisterAny"/>virConnectDomainEventDeregisterAny ()</h3><pre class="programlisting">int	virConnectDomainEventDeregisterAny	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 int callbackID)<br/>
</pre><p>Removes an event callback. The callbackID parameter should be the
vaule obtained from a previous virDomainEventRegisterAny method.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>callbackID</tt></i>:</span></td><td>the callback identifier</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventRegister"/>virConnectDomainEventRegister ()</h3><pre class="programlisting">int	virConnectDomainEventRegister	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb)<br/>
</pre><p>Adds a callback to receive notifications of domain lifecycle events
occurring on a connection

Use of this method is no longer recommended. Instead applications
should try <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a> which has a more flexible
API contract

The <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback returns,
it shall take a reference to it, by calling virDomainRef.
The reference can be released once the object is no longer required
by calling virDomainFree.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque data to pass on to the callback</td></tr><tr><td><span class="term"><i><tt>freecb</tt></i>:</span></td><td>optional function to deallocate opaque when not used anymore</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventRegisterAny"/>virConnectDomainEventRegisterAny ()</h3><pre class="programlisting">int	virConnectDomainEventRegisterAny	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int eventID, <br/>						 <a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a> cb, <br/>						 void * opaque, <br/>						 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb)<br/>
</pre><p>Adds a callback to receive notifications of arbitrary domain events
occurring on a domain.

If dom is NULL, then events will be monitored for any domain. If dom
is non-NULL, then only the specific domain will be monitored

Most types of event have a callback providing a custom set of parameters
for the event. When registering an event, it is thus necessary to use
the VIR_DOMAIN_EVENT_CALLBACK() macro to cast the supplied function pointer
to match the signature of this method.

The <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback returns,
it shall take a reference to it, by calling virDomainRef.
The reference can be released once the object is no longer required
by calling virDomainFree.

The return value from this method is a positive integer identifier
for the callback. To unregister a callback, this callback ID should
be passed to the virDomainEventUnregisterAny method</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>eventID</tt></i>:</span></td><td>the event type to receive</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque data to pass on to the callback</td></tr><tr><td><span class="term"><i><tt>freecb</tt></i>:</span></td><td>optional function to deallocate opaque when not used anymore</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a callback identifier on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainXMLFromNative"/>virConnectDomainXMLFromNative ()</h3><pre class="programlisting">char *	virConnectDomainXMLFromNative	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * nativeFormat, <br/>					 const char * nativeConfig, <br/>					 unsigned int flags)<br/>
</pre><p>Reads native configuration data describing a domain, and
generates libvirt domain XML. The format of the native
data is hypervisor dependant.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>a connection object</td></tr><tr><td><span class="term"><i><tt>nativeFormat</tt></i>:</span></td><td>configuration format importing from</td></tr><tr><td><span class="term"><i><tt>nativeConfig</tt></i>:</span></td><td>the configuration data to import</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainXMLToNative"/>virConnectDomainXMLToNative ()</h3><pre class="programlisting">char *	virConnectDomainXMLToNative	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * nativeFormat, <br/>					 const char * domainXml, <br/>					 unsigned int flags)<br/>
</pre><p>Reads a domain XML configuration document, and generates
a native configuration file describing the domain.
The format of the native data is hypervisor dependant.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>a connection object</td></tr><tr><td><span class="term"><i><tt>nativeFormat</tt></i>:</span></td><td>configuration format exporting to</td></tr><tr><td><span class="term"><i><tt>domainXml</tt></i>:</span></td><td>the domain configuration to export</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectFindStoragePoolSources"/>virConnectFindStoragePoolSources ()</h3><pre class="programlisting">char *	virConnectFindStoragePoolSources	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * type, <br/>						 const char * srcSpec, <br/>						 unsigned int flags)<br/>
</pre><p>Talks to a storage backend and attempts to auto-discover the set of
available storage pool sources. e.g. For iSCSI this would be a set of
iSCSI targets. For NFS this would be a list of exported paths. The
srcSpec (optional for some storage pool types, e.g. local ones) is
an instance of the storage pool's source element specifying where
to look for the pools.

srcSpec is not required for some types (e.g., those querying
local storage resources only)</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of storage pool sources to discover</td></tr><tr><td><span class="term"><i><tt>srcSpec</tt></i>:</span></td><td>XML document specifying discovery source</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>an xml document consisting of a SourceList element containing a source document appropriate to the given pool type for each discovered source.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetCPUModelNames"/>virConnectGetCPUModelNames ()</h3><pre class="programlisting">int	virConnectGetCPUModelNames	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * arch, <br/>					 char ** * models, <br/>					 unsigned int flags)<br/>
</pre><p>Get the list of supported CPU models for a specific architecture.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>arch</tt></i>:</span></td><td>Architecture</td></tr><tr><td><span class="term"><i><tt>models</tt></i>:</span></td><td>Pointer to a variable to store the NULL-terminated array of the CPU models supported for the specified architecture. Each element and the array itself must be freed by the caller with free. Pass NULL if only the list length is needed.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 on error, number of elements in @models on success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetCapabilities"/>virConnectGetCapabilities ()</h3><pre class="programlisting">char *	virConnectGetCapabilities	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides capabilities of the hypervisor / driver.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, or an XML string defining the capabilities. The client must free the returned string after use.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetHostname"/>virConnectGetHostname ()</h3><pre class="programlisting">char *	virConnectGetHostname		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>This returns a system hostname on which the hypervisor is
running (based on the result of the gethostname system call, but
possibly expanded to a fully-qualified domain name via getaddrinfo).
If we are connected to a remote system, then this returns the
hostname of the remote system.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to a hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the hostname which must be freed by the caller, or NULL if there was an error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetLibVersion"/>virConnectGetLibVersion ()</h3><pre class="programlisting">int	virConnectGetLibVersion		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned long * libVer)<br/>
</pre><p>Provides @libVer, which is the version of libvirt used by the
 daemon running on the @conn host</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>libVer</tt></i>:</span></td><td>returns the libvirt library version used on the connection (OUT)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 otherwise, and values for @libVer have the format major * 1,000,000 + minor * 1,000 + release.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetMaxVcpus"/>virConnectGetMaxVcpus ()</h3><pre class="programlisting">int	virConnectGetMaxVcpus		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * type)<br/>
</pre><p>Provides the maximum number of virtual CPUs supported for a guest VM of a
specific type. The 'type' parameter here corresponds to the 'type'
attribute in the &lt;domain&gt; element of the XML.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>value of the 'type' attribute in the &lt;domain&gt; element</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the maximum of virtual CPU or -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetSysinfo"/>virConnectGetSysinfo ()</h3><pre class="programlisting">char *	virConnectGetSysinfo		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags)<br/>
</pre><p>This returns the XML description of the sysinfo details for the
host on which the hypervisor is running, in the same format as the
&lt;sysinfo&gt; element of a domain XML. This information is generally
available only for hypervisors running with root privileges.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to a hypervisor connection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML string which must be freed by the caller, or NULL if there was an error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetType"/>virConnectGetType ()</h3><pre class="programlisting">const char *	virConnectGetType	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Get the name of the Hypervisor driver used. This is merely the driver
name; for example, both KVM and QEMU guests are serviced by the
driver for the qemu:// URI, so a return of "QEMU" does not indicate
whether KVM acceleration is present. For more details about the
hypervisor, use virConnectGetCapabilities().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a static zero terminated string otherwise. See also: http://www.redhat.com/archives/libvir-list/2007-February/msg00096.html</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetURI"/>virConnectGetURI ()</h3><pre class="programlisting">char *	virConnectGetURI		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>This returns the URI (name) of the hypervisor connection.
Normally this is the same as or similar to the string passed
to the virConnectOpen/virConnectOpenReadOnly call, but
the driver may make the URI canonical. If name == NULL
was passed to virConnectOpen, then the driver will return
a non-NULL URI which can be used to connect to the same
hypervisor later.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to a hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the URI string which must be freed by the caller, or NULL if there was an error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetVersion"/>virConnectGetVersion ()</h3><pre class="programlisting">int	virConnectGetVersion		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned long * hvVer)<br/>
</pre><p>Get the version level of the Hypervisor running. This may work only with
hypervisor call, i.e. with privileged access to the hypervisor, not
with a Read-Only connection.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>hvVer</tt></i>:</span></td><td>return value for the version of the running hypervisor (OUT)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 otherwise. if the version can't be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectIsAlive"/>virConnectIsAlive ()</h3><pre class="programlisting">int	virConnectIsAlive		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Determine if the connection to the hypervisor is still alive

A connection will be classed as alive if it is either local, or running
over a channel (TCP or UNIX socket) which is not closed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if alive, 0 if dead, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectIsEncrypted"/>virConnectIsEncrypted ()</h3><pre class="programlisting">int	virConnectIsEncrypted		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Determine if the connection to the hypervisor is encrypted</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if encrypted, 0 if not encrypted, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectIsSecure"/>virConnectIsSecure ()</h3><pre class="programlisting">int	virConnectIsSecure		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Determine if the connection to the hypervisor is secure

A connection will be classed as secure if it is either
encrypted, or running over a channel which is not exposed
to eavesdropping (eg a UNIX domain socket, or pipe)</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if secure, 0 if not secure, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllDomains"/>virConnectListAllDomains ()</h3><pre class="programlisting">int	virConnectListAllDomains	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> ** domains, <br/>					 unsigned int flags)<br/>
</pre><p>Collect a possibly-filtered list of all domains, and return an allocated
array of information for each. This API solves the race inherent in
virConnectListDomains() and virConnectListDefinedDomains().

Normally, all domains are returned; however, @flags can be used to
filter the results for a smaller list of targeted domains. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a domain, and where all bits
within a group describe all possible domains. Some hypervisors might
reject explicit bits from a group where the hypervisor cannot make a
distinction (for example, not all hypervisors can tell whether domains
have snapshots). For a group supported by a given hypervisor, the
behavior when no bits of a group are set is identical to the behavior
when all bits in that group are set. When setting bits from more than
one group, it is possible to select an impossible combination (such
as an inactive transient domain), in that case a hypervisor may return
either 0 or an error.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_ACTIVE">VIR_CONNECT_LIST_DOMAINS_ACTIVE</a> (online
domains) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_INACTIVE">VIR_CONNECT_LIST_DOMAINS_INACTIVE</a> (offline domains).

The next group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_PERSISTENT">VIR_CONNECT_LIST_DOMAINS_PERSISTENT</a> (defined
domains) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_TRANSIENT">VIR_CONNECT_LIST_DOMAINS_TRANSIENT</a> (running but not defined).

The next group of @flags covers various domain states:
VIR_CONNECT_LIST_DOMAINS_RUNNING, VIR_CONNECT_LIST_DOMAINS_PAUSED,
VIR_CONNECT_LIST_DOMAINS_SHUTOFF, and a catch-all for all other states
(such as crashed, this catch-all covers the possibility of adding new
states).

The remaining groups cover boolean attributes commonly asked about
domains; they include <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE</a> and
VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE, for filtering based on whether
a managed save image exists; <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_AUTOSTART</a> and
VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART, for filtering based on autostart;
VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT and
VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT, for filtering based on whether
a domain has snapshots.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>domains</tt></i>:</span></td><td>Pointer to a variable to store the array containing domain objects or NULL if the list is not required (just returns number of guests).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virConnectListAllDomainsFlags">virConnectListAllDomainsFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domains found or -1 and sets domains to NULL in case of error. On success, the array stored into @domains is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virDomainFree() on each array element, then calling free() on @domains. Example of usage: <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> *domains; size_t i; int ret; unsigned int flags = <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_RUNNING">VIR_CONNECT_LIST_DOMAINS_RUNNING</a> | VIR_CONNECT_LIST_DOMAINS_PERSISTENT; ret = virConnectListAllDomains(conn, &amp;domains, flags); if (ret &lt; 0) error(); for (i = 0; i &lt; ret; i++) { do_something_with_domain(domains[i]); //here or in a separate loop if needed virDomainFree(domains[i]); } free(domains);</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllInterfaces"/>virConnectListAllInterfaces ()</h3><pre class="programlisting">int	virConnectListAllInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> ** ifaces, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of interfaces, and allocate an array to store those
objects. This API solves the race inherent between virConnectListInterfaces
and virConnectListDefinedInterfaces.

Normally, all interfaces are returned; however, @flags can be used to
filter the results for a smaller list of targeted interfaces. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a interface, and where all bits
within a group describe all possible interfaces.

The only group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_INTERFACES_ACTIVE">VIR_CONNECT_LIST_INTERFACES_ACTIVE</a> (up) and
VIR_CONNECT_LIST_INTERFACES_INACTIVE (down) to filter the interfaces by state.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>ifaces</tt></i>:</span></td><td>Pointer to a variable to store the array containing the interface objects or NULL if the list is not required (just returns number of interfaces).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of virConnectListAllInterfacesFlags.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of interfaces found or -1 and sets @ifaces to NULL in case of error. On success, the array stored into @ifaces is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virStorageInterfaceFree() on each array element, then calling free() on @ifaces.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllNWFilters"/>virConnectListAllNWFilters ()</h3><pre class="programlisting">int	virConnectListAllNWFilters	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> ** filters, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of network filters, and allocate an array to store those
objects.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>filters</tt></i>:</span></td><td>Pointer to a variable to store the array containing the network filter objects or NULL if the list is not required (just returns number of network filters).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of network filters found or -1 and sets @filters to NULL in case of error. On success, the array stored into @filters is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virNWFilterFree() on each array element, then calling free() on @filters.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllNetworks"/>virConnectListAllNetworks ()</h3><pre class="programlisting">int	virConnectListAllNetworks	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> ** nets, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of networks, and allocate an array to store those
objects. This API solves the race inherent between virConnectListNetworks
and virConnectListDefinedNetworks.

Normally, all networks are returned; however, @flags can be used to
filter the results for a smaller list of targeted networks. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a network, and where all bits
within a group describe all possible networks.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_ACTIVE">VIR_CONNECT_LIST_NETWORKS_ACTIVE</a> (up) and
VIR_CONNECT_LIST_NETWORKS_INACTIVE (down) to filter the networks by state.

The second group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_PERSISTENT">VIR_CONNECT_LIST_NETWORKS_PERSISTENT</a> (defined)
and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_TRANSIENT">VIR_CONNECT_LIST_NETWORKS_TRANSIENT</a> (running but not defined), to filter
the networks by whether they have persistent config or not.

The third group of @flags is VIR_CONNECT_LIST_NETWORKS_AUTOSTART
and VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART, to filter the networks by
whether they are marked as autostart or not.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>nets</tt></i>:</span></td><td>Pointer to a variable to store the array containing the network objects or NULL if the list is not required (just returns number of networks).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of virConnectListAllNetworksFlags.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of networks found or -1 and sets @nets to NULL in case of error. On success, the array stored into @nets is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virNetworkFree() on each array element, then calling free() on @nets.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllNodeDevices"/>virConnectListAllNodeDevices ()</h3><pre class="programlisting">int	virConnectListAllNodeDevices	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> ** devices, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of node devices, and allocate an array to store those
objects.

Normally, all node devices are returned; however, @flags can be used to
filter the results for a smaller list of targeted node devices. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a node device, and where all bits
within a group describe all possible node devices.

Only one group of the @flags is provided to filter the node devices by
capability type, flags include:
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS
 <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC</a></p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>devices</tt></i>:</span></td><td>Pointer to a variable to store the array containing the node device objects or NULL if the list is not required (just returns number of node devices).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of virConnectListAllNodeDevices.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of node devices found or -1 and sets @devices to NULL in case of error. On success, the array stored into @devices is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virNodeDeviceFree() on each array element, then calling free() on @devices.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllSecrets"/>virConnectListAllSecrets ()</h3><pre class="programlisting">int	virConnectListAllSecrets	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> ** secrets, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of secrets, and allocate an array to store those
objects.

Normally, all secrets are returned; however, @flags can be used to
filter the results for a smaller list of targeted secrets. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a secret, and where all bits
within a group describe all possible secrets.

The first group of @flags is used to filter secrets by its storage
location. Flag <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_SECRETS_EPHEMERAL">VIR_CONNECT_LIST_SECRETS_EPHEMERAL</a> selects secrets that
are kept only in memory. Flag VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL
selects secrets that are kept in persistent storage.

The second group of @flags is used to filter secrets by privacy. Flag
VIR_CONNECT_LIST_SECRETS_PRIVATE seclets secrets that are never revealed
to any caller of libvirt nor to any other node. Flag
VIR_CONNECT_LIST_SECRETS_NO_PRIVATE selects non-private secrets.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>secrets</tt></i>:</span></td><td>Pointer to a variable to store the array containing the secret objects or NULL if the list is not required (just returns the number of secrets).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of secrets found or -1 and sets @secrets to NULL in case of error. On success, the array stored into @secrets is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virSecretFree() on each array element, then calling free() on @secrets.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllStoragePools"/>virConnectListAllStoragePools ()</h3><pre class="programlisting">int	virConnectListAllStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> ** pools, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of storage pools, and allocate an array to store those
objects. This API solves the race inherent between
virConnectListStoragePools and virConnectListDefinedStoragePools.

Normally, all storage pools are returned; however, @flags can be used to
filter the results for a smaller list of targeted pools. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a pool, and where all bits
within a group describe all possible pools.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE">VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE</a> (online)
and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE">VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE</a> (offline) to filter the pools
by state.

The second group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_PERSITENT
(defined) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT">VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT</a> (running but not
defined), to filter the pools by whether they have persistent config or not.

The third group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART
and VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART, to filter the pools by
whether they are marked as autostart or not.

The last group of @flags is provided to filter the pools by the types,
the flags include:
VIR_CONNECT_LIST_STORAGE_POOLS_DIR
VIR_CONNECT_LIST_STORAGE_POOLS_FS
VIR_CONNECT_LIST_STORAGE_POOLS_NETFS
VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL
VIR_CONNECT_LIST_STORAGE_POOLS_DISK
VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI
VIR_CONNECT_LIST_STORAGE_POOLS_SCSI
VIR_CONNECT_LIST_STORAGE_POOLS_MPATH
VIR_CONNECT_LIST_STORAGE_POOLS_RBD
VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>pools</tt></i>:</span></td><td>Pointer to a variable to store the array containing storage pool objects or NULL if the list is not required (just returns number of pools).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of virConnectListAllStoragePoolsFlags.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of storage pools found or -1 and sets @pools to NULL in case of error. On success, the array stored into @pools is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virStoragePoolFree() on each array element, then calling free() on @pools.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListDefinedDomains"/>virConnectListDefinedDomains ()</h3><pre class="programlisting">int	virConnectListDefinedDomains	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>list the defined but inactive domains, stores the pointers to the names
in @names

For active domains, see virConnectListDomains(). For more control over
the results, see virConnectListAllDomains().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>pointer to an array to store the names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a domain can be defined between a call to virConnectNumOfDefinedDomains() and this call; you are only guaranteed that all currently defined domains were listed if the return is less than @maxids. The client must call free() on each returned name.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListDefinedInterfaces"/>virConnectListDefinedInterfaces ()</h3><pre class="programlisting">int	virConnectListDefinedInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>Collect the list of defined (inactive) physical host interfaces,
and store their names in @names.

For more control over the results, see virConnectListAllInterfaces().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of interfaces</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a interface can be defined between a call to virConnectNumOfDefinedInterfaces() and this call; you are only guaranteed that all currently defined interfaces were listed if the return is less than @maxnames. The client must call free() on each returned name.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListDefinedNetworks"/>virConnectListDefinedNetworks ()</h3><pre class="programlisting">int	virConnectListDefinedNetworks	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>list the inactive networks, stores the pointers to the names in @names

For more control over the results, see virConnectListAllNetworks().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>pointer to an array to store the names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a network can be defined between a call to virConnectNumOfDefinedNetworks() and this call; you are only guaranteed that all currently defined networks were listed if the return is less than @maxnames. The client must call free() on each returned name.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListDefinedStoragePools"/>virConnectListDefinedStoragePools ()</h3><pre class="programlisting">int	virConnectListDefinedStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 char ** const names, <br/>						 int maxnames)<br/>
</pre><p>Provides the list of names of inactive storage pools up to maxnames.
If there are more than maxnames, the remaining names will be silently
ignored.

For more control over the results, see virConnectListAllStoragePools().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array of char * to fill with pool names (allocated by caller)</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the names array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a pool can be defined between a call to virConnectNumOfDefinedStoragePools() and this call; you are only guaranteed that all currently defined pools were listed if the return is less than @maxnames. The client must call free() on each returned name.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListDomains"/>virConnectListDomains ()</h3><pre class="programlisting">int	virConnectListDomains		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int * ids, <br/>					 int maxids)<br/>
</pre><p>Collect the list of active domains, and store their IDs in array @ids

For inactive domains, see virConnectListDefinedDomains(). For more
control over the results, see virConnectListAllDomains().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>ids</tt></i>:</span></td><td>array to collect the list of IDs of active domains</td></tr><tr><td><span class="term"><i><tt>maxids</tt></i>:</span></td><td>size of @ids</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domains found or -1 in case of error. Note that this command is inherently racy; a domain can be started between a call to virConnectNumOfDomains() and this call; you are only guaranteed that all currently active domains were listed if the return is less than @maxids.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListInterfaces"/>virConnectListInterfaces ()</h3><pre class="programlisting">int	virConnectListInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>Collect the list of active physical host interfaces,
and store their names in @names

For more control over the results, see virConnectListAllInterfaces().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of interfaces</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of interfaces found or -1 in case of error. Note that this command is inherently racy; a interface can be started between a call to virConnectNumOfInterfaces() and this call; you are only guaranteed that all currently active interfaces were listed if the return is less than @maxnames. The client must call free() on each returned name.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListNWFilters"/>virConnectListNWFilters ()</h3><pre class="programlisting">int	virConnectListNWFilters		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>Collect the list of network filters, and store their names in @names</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of network filters</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of network filters found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListNetworks"/>virConnectListNetworks ()</h3><pre class="programlisting">int	virConnectListNetworks		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>Collect the list of active networks, and store their names in @names

For more control over the results, see virConnectListAllNetworks().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of active networks</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of networks found or -1 in case of error. Note that this command is inherently racy; a network can be started between a call to virConnectNumOfNetworks() and this call; you are only guaranteed that all currently active networks were listed if the return is less than @maxnames. The client must call free() on each returned name.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListSecrets"/>virConnectListSecrets ()</h3><pre class="programlisting">int	virConnectListSecrets		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** uuids, <br/>					 int maxuuids)<br/>
</pre><p>List UUIDs of defined secrets, store pointers to names in uuids.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>uuids</tt></i>:</span></td><td>Pointer to an array to store the UUIDs</td></tr><tr><td><span class="term"><i><tt>maxuuids</tt></i>:</span></td><td>size of the array.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of UUIDs provided in the array, or -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListStoragePools"/>virConnectListStoragePools ()</h3><pre class="programlisting">int	virConnectListStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>Provides the list of names of active storage pools up to maxnames.
If there are more than maxnames, the remaining names will be silently
ignored.

For more control over the results, see virConnectListAllStoragePools().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array of char * to fill with pool names (allocated by caller)</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the names array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of pools found or -1 in case of error. Note that this command is inherently racy; a pool can be started between a call to virConnectNumOfStoragePools() and this call; you are only guaranteed that all currently active pools were listed if the return is less than @maxnames. The client must call free() on each returned name.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfDefinedDomains"/>virConnectNumOfDefinedDomains ()</h3><pre class="programlisting">int	virConnectNumOfDefinedDomains	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of defined but inactive domains.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfDefinedInterfaces"/>virConnectNumOfDefinedInterfaces ()</h3><pre class="programlisting">int	virConnectNumOfDefinedInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of defined (inactive) interfaces on the physical host.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of defined interface found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfDefinedNetworks"/>virConnectNumOfDefinedNetworks ()</h3><pre class="programlisting">int	virConnectNumOfDefinedNetworks	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of inactive networks.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of networks found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfDefinedStoragePools"/>virConnectNumOfDefinedStoragePools ()</h3><pre class="programlisting">int	virConnectNumOfDefinedStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of inactive storage pools</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of pools found, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfDomains"/>virConnectNumOfDomains ()</h3><pre class="programlisting">int	virConnectNumOfDomains		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of active domains.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfInterfaces"/>virConnectNumOfInterfaces ()</h3><pre class="programlisting">int	virConnectNumOfInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of active interfaces on the physical host.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of active interfaces found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfNWFilters"/>virConnectNumOfNWFilters ()</h3><pre class="programlisting">int	virConnectNumOfNWFilters	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of nwfilters.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of nwfilters found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfNetworks"/>virConnectNumOfNetworks ()</h3><pre class="programlisting">int	virConnectNumOfNetworks		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of active networks.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of network found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfSecrets"/>virConnectNumOfSecrets ()</h3><pre class="programlisting">int	virConnectNumOfSecrets		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Fetch number of currently defined secrets.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number currently defined secrets.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfStoragePools"/>virConnectNumOfStoragePools ()</h3><pre class="programlisting">int	virConnectNumOfStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of active storage pools</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of pools found, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectOpen"/>virConnectOpen ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virConnectOpen		(const char * name)<br/>
</pre><p>This function should be called first to get a connection to the
Hypervisor and xen store</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>(optional) URI of the hypervisor</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the hypervisor connection or NULL in case of error If @name is NULL, if the LIBVIRT_DEFAULT_URI environment variable is set, then it will be used. Otherwise if the client configuration file has the "uri_default" parameter set, then it will be used. Finally probing will be done to determine a suitable default driver to activate. This involves trying each hypervisor in turn until one successfully opens. If connecting to an unprivileged hypervisor driver which requires the libvirtd daemon to be active, it will automatically be launched if not already running. This can be prevented by setting the environment variable LIBVIRT_AUTOSTART=0 URIs are documented at http://libvirt.org/uri.html</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectOpenAuth"/>virConnectOpenAuth ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virConnectOpenAuth	(const char * name, <br/>					 <a href="libvirt-libvirt.html#virConnectAuthPtr">virConnectAuthPtr</a> auth, <br/>					 unsigned int flags)<br/>
</pre><p>This function should be called first to get a connection to the
Hypervisor. If necessary, authentication will be performed fetching
credentials via the callback

See <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> for notes about environment variables which can
have an effect on opening drivers</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>(optional) URI of the hypervisor</td></tr><tr><td><span class="term"><i><tt>auth</tt></i>:</span></td><td>Authenticate callback parameters</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virConnectFlags">virConnectFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the hypervisor connection or NULL in case of error URIs are documented at http://libvirt.org/uri.html</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectOpenReadOnly"/>virConnectOpenReadOnly ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virConnectOpenReadOnly	(const char * name)<br/>
</pre><p>This function should be called first to get a restricted connection to the
library functionalities. The set of APIs usable are then restricted
on the available methods to control the domains.

See <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> for notes about environment variables which can
have an effect on opening drivers</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>(optional) URI of the hypervisor</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the hypervisor connection or NULL in case of error URIs are documented at http://libvirt.org/uri.html</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectRef"/>virConnectRef ()</h3><pre class="programlisting">int	virConnectRef			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Increment the reference count on the connection. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virConnectClose">virConnectClose</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a connection would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>the connection to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectRegisterCloseCallback"/>virConnectRegisterCloseCallback ()</h3><pre class="programlisting">int	virConnectRegisterCloseCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virConnectCloseFunc">virConnectCloseFunc</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb)<br/>
</pre><p>Registers a callback to be invoked when the connection
is closed. This callback is invoked when there is any
condition that causes the socket connection to the
hypervisor to be closed.

This function is only applicable to hypervisor drivers
which maintain a persistent open connection. Drivers
which open a new connection for every operation will
not invoke this.

The @freecb must not invoke any other libvirt public
APIs, since it is not called from a re-entrant safe
context.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to connection object</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to invoke upon close</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data to pass to @cb</td></tr><tr><td><span class="term"><i><tt>freecb</tt></i>:</span></td><td>callback to free @opaque</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectSetKeepAlive"/>virConnectSetKeepAlive ()</h3><pre class="programlisting">int	virConnectSetKeepAlive		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int interval, <br/>					 unsigned int count)<br/>
</pre><p>Start sending keepalive messages after interval second of inactivity and
consider the connection to be broken when no response is received after
count keepalive messages sent in a row. In other words, sending count + 1
keepalive message results in closing the connection. When interval is &lt;= 0,
no keepalive messages will be sent. When count is 0, the connection will be
automatically closed after interval seconds of inactivity without sending
any keepalive messages.

Note: client has to implement and run event loop to be able to use keepalive
messages. Failure to do so may result in connections being closed
unexpectedly.

Note: This API function controls only keepalive messages sent by the client.
If the server is configured to use keepalive you still need to run the event
loop to respond to them, even if you disable keepalives by this function.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to a hypervisor connection</td></tr><tr><td><span class="term"><i><tt>interval</tt></i>:</span></td><td>number of seconds of inactivity before a keepalive message is sent</td></tr><tr><td><span class="term"><i><tt>count</tt></i>:</span></td><td>number of messages that can be sent in a row</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 on error, 0 on success, 1 when remote party doesn't support keepalive messages.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectUnregisterCloseCallback"/>virConnectUnregisterCloseCallback ()</h3><pre class="programlisting">int	virConnectUnregisterCloseCallback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt.html#virConnectCloseFunc">virConnectCloseFunc</a> cb)<br/>
</pre><p>Unregisters the callback previously set with the
virConnectRegisterCloseCallback method. The callback
will no longer receive notifications when the connection
closes. If a <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> was provided at time of
registration, it will be invoked</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to connection object</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>pointer to the current registered callback</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainAbortJob"/>virDomainAbortJob ()</h3><pre class="programlisting">int	virDomainAbortJob		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Requests that the current background job be aborted at the
soonest opportunity.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainAttachDevice"/>virDomainAttachDevice ()</h3><pre class="programlisting">int	virDomainAttachDevice		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml)<br/>
</pre><p>Create a virtual device attachment to backend. This function,
having hotplug semantics, is only allowed on an active domain.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainAttachDeviceFlags"/>virDomainAttachDeviceFlags ()</h3><pre class="programlisting">int	virDomainAttachDeviceFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Attach a virtual device to a domain, using the flags parameter
to control how the device is attached. VIR_DOMAIN_AFFECT_CURRENT
specifies that the device allocation is made based on current domain
state. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be
allocated to the active domain instance only and is not added to the
persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be allocated to the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockCommit"/>virDomainBlockCommit ()</h3><pre class="programlisting">int	virDomainBlockCommit		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * base, <br/>					 const char * top, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Commit changes that were made to temporary top-level files within a disk
image backing file chain into a lower-level base file. In other words,
take all the difference between @base and @top, and update @base to contain
that difference; after the commit, any portion of the chain that previously
depended on @top will now depend on @base, and all files after @base up
to and including @top will now be invalidated. A typical use of this
command is to reduce the length of a backing file chain after taking an
external disk snapshot. To move data in the opposite direction, see
virDomainBlockPull().

This command starts a long-running commit block job, whose status may
be tracked by virDomainBlockJobInfo() with a job type of
VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT, and the operation can be aborted with
virDomainBlockJobAbort(). When finished, an asynchronous event is
raised to indicate the final status, and the job no longer exists. If
the job is aborted, it is up to the hypervisor whether starting a new
job will resume from the same point, or start over.

Be aware that this command may invalidate files even if it is aborted;
the user is cautioned against relying on the contents of invalidated
intermediate files such as @top without manually rebasing those files
to use a backing file of a read-only copy of @base prior to the point
where the commit operation was started (although such a rebase cannot
be safely done until the commit has successfully completed). However,
the domain itself will not have any issues; the active layer remains
valid throughout the entire commit operation. As a convenience,
if @flags contains VIR_DOMAIN_BLOCK_COMMIT_DELETE, this command will
unlink all files that were invalidated, after the commit successfully
completes.

By default, if @base is NULL, the commit target will be the bottom of
the backing chain; if @flags contains VIR_DOMAIN_BLOCK_COMMIT_SHALLOW,
then the immediate backing file of @top will be used instead. If @top
is NULL, the active image at the top of the chain will be used. Some
hypervisors place restrictions on how much can be committed, and might
fail if @base is not the immediate backing file of @top, or if @top is
the active layer in use by a running domain, or if @top is not the
top-most file; restrictions may differ for online vs. offline domains.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The maximum bandwidth (in MiB/s) that will be used to do the commit can be
specified with the bandwidth parameter. If set to 0, libvirt will choose a
suitable default. Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still be
possible for a later call to virDomainBlockJobSetSpeed() to succeed.
The actual speed can be determined with virDomainGetBlockJobInfo().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>base</tt></i>:</span></td><td>path to backing file to merge into, or NULL for default</td></tr><tr><td><span class="term"><i><tt>top</tt></i>:</span></td><td>path to file within backing chain that contains data to be merged, or NULL to merge all possible data</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify commit bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainBlockCommitFlags">virDomainBlockCommitFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the operation has started, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobAbort"/>virDomainBlockJobAbort ()</h3><pre class="programlisting">int	virDomainBlockJobAbort		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned int flags)<br/>
</pre><p>Cancel the active block job on the given disk.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, then
by default, this function performs a synchronous operation and the caller
may assume that the operation has completed when 0 is returned. However,
BlockJob operations may take a long time to cancel, and during this time
further domain interactions may be unresponsive. To avoid this problem,
pass <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC">VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC</a> in the @flags argument to enable
asynchronous behavior, returning as soon as possible. When the job has
been canceled, a BlockJob event will be emitted, with status
VIR_DOMAIN_BLOCK_JOB_CANCELED (even if the ABORT_ASYNC flag was not
used); it is also possible to poll virDomainBlockJobInfo() to see if
the job cancellation is still pending. This type of job can be restarted
to pick up from where it left off.

If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_COPY, then
the default is to abort the mirroring and revert to the source disk;
adding @flags of <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT">VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT</a> causes this call to
fail with <a href="libvirt-virterror.html#VIR_ERR_BLOCK_COPY_ACTIVE">VIR_ERR_BLOCK_COPY_ACTIVE</a> if the copy is not fully populated,
otherwise it will swap the disk over to the copy to end the mirroring. An
event will be issued when the job is ended, and it is possible to use
VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC to control whether this command waits
for the completion of the job. Restarting this job requires starting
over from the beginning of the first phase.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainBlockJobAbortFlags">virDomainBlockJobAbortFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 when successful.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobSetSpeed"/>virDomainBlockJobSetSpeed ()</h3><pre class="programlisting">int	virDomainBlockJobSetSpeed	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Set the maximimum allowable bandwidth that a block job may consume. If
bandwidth is 0, the limit will revert to the hypervisor default.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>specify bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 when successful.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockPeek"/>virDomainBlockPeek ()</h3><pre class="programlisting">int	virDomainBlockPeek		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long long offset, <br/>					 size_t size, <br/>					 void * buffer, <br/>					 unsigned int flags)<br/>
</pre><p>This function allows you to read the contents of a domain's
disk device.

Typical uses for this are to determine if the domain has
written a Master Boot Record (indicating that the domain
has completed installation), or to try to work out the state
of the domain's filesystems.

(Note that in the local case you might try to open the
block device or file directly, but that won't work in the
remote case, nor if you don't have sufficient permission.
Hence the need for this call).

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

'offset' and 'size' represent an area which must lie entirely
within the device or file. 'size' may be 0 to test if the
call would succeed.

'buffer' is the return buffer and must be at least 'size' bytes.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to &lt;= 65536 bytes.
However, with 0.9.13 this RPC limit has been raised to 1M byte.
Starting with version 1.0.6 the RPC limit has been raised again.
Now large requests up to 16M byte are supported.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>offset</tt></i>:</span></td><td>offset within block device</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size to read</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>return buffer (must be at least size bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure. really 64 bits</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockPull"/>virDomainBlockPull ()</h3><pre class="programlisting">int	virDomainBlockPull		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Populate a disk image with data from its backing image. Once all data from
its backing image has been pulled, the disk no longer depends on a backing
image. This function pulls data for the entire device in the background.
Progress of the operation can be checked with virDomainGetBlockJobInfo() and
the operation can be aborted with virDomainBlockJobAbort(). When finished,
an asynchronous event is raised to indicate the final status. To move
data in the opposite direction, see virDomainBlockCommit().

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The maximum bandwidth (in MiB/s) that will be used to do the copy can be
specified with the bandwidth parameter. If set to 0, libvirt will choose a
suitable default. Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still be
possible for a later call to virDomainBlockJobSetSpeed() to succeed.
The actual speed can be determined with virDomainGetBlockJobInfo().

This is shorthand for virDomainBlockRebase() with a NULL base.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify copy bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the operation has started, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockRebase"/>virDomainBlockRebase ()</h3><pre class="programlisting">int	virDomainBlockRebase		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * base, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Populate a disk image with data from its backing image chain, and
setting the backing image to @base, or alternatively copy an entire
backing chain to a new file @base.

When @flags is 0, this starts a pull, where @base must be the absolute
path of one of the backing images further up the chain, or NULL to
convert the disk image so that it has no backing image. Once all
data from its backing image chain has been pulled, the disk no
longer depends on those intermediate backing images. This function
pulls data for the entire device in the background. Progress of
the operation can be checked with virDomainGetBlockJobInfo() with a
job type of VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, and the operation can be
aborted with virDomainBlockJobAbort(). When finished, an asynchronous
event is raised to indicate the final status, and the job no longer
exists. If the job is aborted, a new one can be started later to
resume from the same point.

When @flags includes VIR_DOMAIN_BLOCK_REBASE_COPY, this starts a copy,
where @base must be the name of a new file to copy the chain to. By
default, the copy will pull the entire source chain into the destination
file, but if @flags also contains VIR_DOMAIN_BLOCK_REBASE_SHALLOW, then
only the top of the source chain will be copied (the source and
destination have a common backing file). By default, @base will be
created with the same file format as the source, but this can be altered
by adding <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_REBASE_COPY_RAW">VIR_DOMAIN_BLOCK_REBASE_COPY_RAW</a> to force the copy to be raw
(does not make sense with the shallow flag unless the source is also raw),
or by using <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT">VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT</a> to reuse an existing file
with initial contents identical to the backing file of the source (this
allows a management app to pre-create files with relative backing file
names, rather than the default of absolute backing file names; as a
security precaution, you should generally only use reuse_ext with the
shallow flag and a non-raw destination file).

A copy job has two parts; in the first phase, the @bandwidth parameter
affects how fast the source is pulled into the destination, and the job
can only be canceled by reverting to the source file; progress in this
phase can be tracked via the virDomainBlockJobInfo() command, with a
job type of VIR_DOMAIN_BLOCK_JOB_TYPE_COPY. The job transitions to the
second phase when the job info states cur == end, and remains alive to
mirror all further changes to both source and destination. The user
must call virDomainBlockJobAbort() to end the mirroring while choosing
whether to revert to source or pivot to the destination. An event is
issued when the job ends, and depending on the hypervisor, an event may
also be issued when the job transitions from pulling to mirroring. If
the job is aborted, a new job will have to start over from the beginning
of the first phase.

Some hypervisors will restrict certain actions, such as virDomainSave()
or virDomainDetachDevice(), while a copy job is active; they may
also restrict a copy job to transient domains.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The maximum bandwidth (in MiB/s) that will be used to do the copy can be
specified with the bandwidth parameter. If set to 0, libvirt will choose a
suitable default. Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still be
possible for a later call to virDomainBlockJobSetSpeed() to succeed.
The actual speed can be determined with virDomainGetBlockJobInfo().

When @base is NULL and @flags is 0, this is identical to
virDomainBlockPull().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>base</tt></i>:</span></td><td>path to backing file to keep, or NULL for no backing file</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify copy bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainBlockRebaseFlags">virDomainBlockRebaseFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the operation has started, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockResize"/>virDomainBlockResize ()</h3><pre class="programlisting">int	virDomainBlockResize		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long long size, <br/>					 unsigned int flags)<br/>
</pre><p>Resize a block device of domain while the domain is running. If
@flags is 0, then @size is in kibibytes (blocks of 1024 bytes);
since 0.9.11, if @flags includes VIR_DOMAIN_BLOCK_RESIZE_BYTES,
@size is in bytes instead. @size is taken directly as the new
size. Depending on the file format, the hypervisor may round up
to the next alignment boundary.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

Note that this call may fail if the underlying virtualization hypervisor
does not support it; this call requires privileged access to the
hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block image, or shorthand</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>new size of the block image, see below for unit</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainBlockResizeFlags">virDomainBlockResizeFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockStats"/>virDomainBlockStats ()</h3><pre class="programlisting">int	virDomainBlockStats		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a> stats, <br/>					 size_t size)<br/>
</pre><p>This function returns block device (disk) stats for block
devices attached to the domain.

The @disk parameter is either the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "xvda"), or (since 0.9.8)
an unambiguous source name of the block device (the &lt;source
file='...'/&gt; sub-element, such as "/path/to/image"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

Domains may have more than one block device. To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>block device stats (returned)</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of stats structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockStatsFlags"/>virDomainBlockStatsFlags ()</h3><pre class="programlisting">int	virDomainBlockStatsFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>This function is to get block stats parameters for block
devices attached to the domain.

The @disk parameter is either the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "xvda"), or (since 0.9.8)
an unambiguous source name of the block device (the &lt;source
file='...'/&gt; sub-element, such as "/path/to/image"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

Domains may have more than one block device. To get stats for
each you should make multiple calls to this function.

On input, @nparams gives the size of the @params array; on output,
@nparams gives how many slots were filled with parameter
information, which might be less but will not exceed the input
value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. (Note that block devices of different types
might support different parameters, so it might be necessary to compute
@nparams for each block device). The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again. See virDomainGetMemoryParameters() for more details.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to block stats parameter object (return value)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of block stats; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCoreDump"/>virDomainCoreDump ()</h3><pre class="programlisting">int	virDomainCoreDump		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 unsigned int flags)<br/>
</pre><p>This method will dump the core of a domain on a given file for analysis.
Note that for remote Xen Daemon the file path will be interpreted in
the remote host. Hypervisors may require the user to manually ensure
proper permissions on the file named by @to.

If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with
a crashed state after the dump completes. If @flags includes
VIR_DUMP_LIVE, then make the core dump while continuing to allow
the guest to run; otherwise, the guest is suspended during the dump.
VIR_DUMP_RESET flag forces reset of the quest after dump.
The above three flags are mutually exclusive.

Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt
will attempt to bypass the file system cache while creating the file,
or fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the core file</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreate"/>virDomainCreate ()</h3><pre class="programlisting">int	virDomainCreate			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools. The domain will be paused only
if restoring from managed state created from a paused domain. For more
control, see virDomainCreateWithFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateLinux"/>virDomainCreateLinux ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainCreateLinux	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags)<br/>
</pre><p>Deprecated after 0.4.6.
Renamed to virDomainCreateXML() providing identical functionality.
This existing name will left indefinitely for API compatibility.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateWithFiles"/>virDomainCreateWithFiles ()</h3><pre class="programlisting">int	virDomainCreateWithFiles	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nfiles, <br/>					 int * files, <br/>					 unsigned int flags)<br/>
</pre><p>Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.

@files provides an array of file descriptors which will be
made available to the 'init' process of the guest. The file
handles exposed to the guest will be renumbered to start
from 3 (ie immediately following stderr). This is only
supported for guests which use container based virtualization
technology.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, or if the guest domain
has a managed save image that requested paused state (see
virDomainManagedSave()) the guest domain will be started, but its
CPUs will remain paused. The CPUs can later be manually started
using virDomainResume(). In all other cases, the guest domain will
be running.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a> flag is set, and there is a
managed save file for this domain (created by virDomainManagedSave()),
then libvirt will attempt to bypass the file system cache while restoring
the file, or fail if it cannot do so for the given system; this can allow
less pressure on file system cache, but also risks slowing loads from NFS.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a> flag is set, then any managed save
file for this domain is discarded, and the domain boots from scratch.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>nfiles</tt></i>:</span></td><td>number of file descriptors passed</td></tr><tr><td><span class="term"><i><tt>files</tt></i>:</span></td><td>list of file descriptors passed</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateWithFlags"/>virDomainCreateWithFlags ()</h3><pre class="programlisting">int	virDomainCreateWithFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, or if the guest domain
has a managed save image that requested paused state (see
virDomainManagedSave()) the guest domain will be started, but its
CPUs will remain paused. The CPUs can later be manually started
using virDomainResume(). In all other cases, the guest domain will
be running.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a> flag is set, and there is a
managed save file for this domain (created by virDomainManagedSave()),
then libvirt will attempt to bypass the file system cache while restoring
the file, or fail if it cannot do so for the given system; this can allow
less pressure on file system cache, but also risks slowing loads from NFS.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a> flag is set, then any managed save
file for this domain is discarded, and the domain boots from scratch.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateXML"/>virDomainCreateXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainCreateXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags)<br/>
</pre><p>Launch a new guest domain, based on an XML description similar
to the one returned by virDomainGetXMLDesc()
This function may require privileged access to the hypervisor.
The domain is not persistent, so its definition will disappear when it
is destroyed, or if the host is restarted (see virDomainDefineXML() to
define persistent domains).

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, the guest domain
will be started, but its CPUs will remain paused. The CPUs
can later be manually started using virDomainResume.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateXMLWithFiles"/>virDomainCreateXMLWithFiles ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainCreateXMLWithFiles	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int nfiles, <br/>						 int * files, <br/>						 unsigned int flags)<br/>
</pre><p>Launch a new guest domain, based on an XML description similar
to the one returned by virDomainGetXMLDesc()
This function may require privileged access to the hypervisor.
The domain is not persistent, so its definition will disappear when it
is destroyed, or if the host is restarted (see virDomainDefineXML() to
define persistent domains).

@files provides an array of file descriptors which will be
made available to the 'init' process of the guest. The file
handles exposed to the guest will be renumbered to start
from 3 (ie immediately following stderr). This is only
supported for guests which use container based virtualization
technology.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, the guest domain
will be started, but its CPUs will remain paused. The CPUs
can later be manually started using virDomainResume.

If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>nfiles</tt></i>:</span></td><td>number of file descriptors passed</td></tr><tr><td><span class="term"><i><tt>files</tt></i>:</span></td><td>list of file descriptors passed</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDefineXML"/>virDomainDefineXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml)<br/>
</pre><p>Define a domain, but does not start it.
This definition is persistent, until explicitly undefined with
virDomainUndefine(). A previous definition for this domain would be
overridden if it already exists.

Some hypervisors may prevent this operation if there is a current
block copy operation on a transient domain with the same id as the
domain being defined; in that case, use virDomainBlockJobAbort() to
stop the block copy first.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the domain, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a pointer to the domain otherwise</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDestroy"/>virDomainDestroy ()</h3><pre class="programlisting">int	virDomainDestroy		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Destroy the domain object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object.
This function may require privileged access.

virDomainDestroy first requests that a guest terminate
(e.g. SIGTERM), then waits for it to comply. After a reasonable
timeout, if the guest still exists, <a href="libvirt-libvirt.html#virDomainDestroy">virDomainDestroy</a> will
forcefully terminate the guest (e.g. SIGKILL) if necessary (which
may produce undesirable results, for example unflushed disk cache
in the guest). To avoid this possibility, it's recommended to
instead call virDomainDestroyFlags, sending the
VIR_DOMAIN_DESTROY_GRACEFUL flag.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDestroyFlags"/>virDomainDestroyFlags ()</h3><pre class="programlisting">int	virDomainDestroyFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Destroy the domain object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor.
This does not free the associated <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object.
This function may require privileged access.

Calling this function with no @flags set (equal to zero) is
equivalent to calling virDomainDestroy, and after a reasonable
timeout will forcefully terminate the guest (e.g. SIGKILL) if
necessary (which may produce undesirable results, for example
unflushed disk cache in the guest). Including
VIR_DOMAIN_DESTROY_GRACEFUL in the flags will prevent the forceful
termination of the guest, and <a href="libvirt-libvirt.html#virDomainDestroyFlags">virDomainDestroyFlags</a> will instead
return an error if the guest doesn't terminate by the end of the
timeout; at that time, the management application can decide if
calling again without <a href="libvirt-libvirt.html#VIR_DOMAIN_DESTROY_GRACEFUL">VIR_DOMAIN_DESTROY_GRACEFUL</a> is appropriate.

Another alternative which may produce cleaner results for the
guest's disks is to use virDomainShutdown() instead, but that
depends on guest support (some hypervisor/guest combinations may
ignore the shutdown request).</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainDestroyFlagsValues">virDomainDestroyFlagsValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDetachDevice"/>virDomainDetachDevice ()</h3><pre class="programlisting">int	virDomainDetachDevice		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml)<br/>
</pre><p>Destroy a virtual device attachment to backend. This function,
having hot-unplug semantics, is only allowed on an active domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDetachDeviceFlags"/>virDomainDetachDeviceFlags ()</h3><pre class="programlisting">int	virDomainDetachDeviceFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Detach a virtual device from a domain, using the flags parameter
to control how the device is detached. VIR_DOMAIN_AFFECT_CURRENT
specifies that the device allocation is removed based on current domain
state. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be
deallocated from the active domain instance only and is not from the
persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be deallocated from the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports removing the
persisted device allocation.

Some hypervisors may prevent this operation if there is a current
block copy operation on the device being detached; in that case,
use virDomainBlockJobAbort() to stop the block copy first.

Beware that depending on the hypervisor and device type, detaching a device
from a running domain may be asynchronous. That is, calling
virDomainDetachDeviceFlags may just request device removal while the device
is actually removed later (in cooperation with a guest OS). Previously,
this fact was ignored and the device could have been removed from domain
configuration before it was actually removed by the hypervisor causing
various failures on subsequent operations. To check whether the device was
successfully removed, either recheck domain configuration using
virDomainGetXMLDesc() or add handler for VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED
event. In case the device is already gone when <a href="libvirt-libvirt.html#virDomainDetachDeviceFlags">virDomainDetachDeviceFlags</a></p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the event is delivered before this API call ends. To help existing clients work better in most cases, this API will try to transform an asynchronous device removal that finishes shortly after the request into a synchronous removal. In other words, this API may wait a bit for the removal to complete in case it was not synchronous. Returns 0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFSTrim"/>virDomainFSTrim ()</h3><pre class="programlisting">int	virDomainFSTrim			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * mountPoint, <br/>					 unsigned long long minimum, <br/>					 unsigned int flags)<br/>
</pre><p>Calls FITRIM within the guest (hence guest agent may be
required depending on hypervisor used). Either call it on each
mounted filesystem (@mountPoint is NULL) or just on specified
@mountPoint. @minimum hints that free ranges smaller than this
may be ignored (this is a hint and the guest may not respect
it). By increasing this value, the fstrim operation will
complete more quickly for filesystems with badly fragmented
free space, although not all blocks will be discarded.
If @minimum is not zero, the command may fail.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>mountPoint</tt></i>:</span></td><td>which mount point to trim</td></tr><tr><td><span class="term"><i><tt>minimum</tt></i>:</span></td><td>Minimum contiguous free range to discard in bytes</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags, not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFree"/>virDomainFree ()</h3><pre class="programlisting">int	virDomainFree			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Free the domain object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetAutostart"/>virDomainGetAutostart ()</h3><pre class="programlisting">int	virDomainGetAutostart		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * autostart)<br/>
</pre><p>Provides a boolean value indicating whether the domain
configured to be automatically started when the host
machine boots.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>the value returned</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetBlkioParameters"/>virDomainGetBlkioParameters ()</h3><pre class="programlisting">int	virDomainGetBlkioParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all blkio parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

See virDomainGetMemoryParameters() for an equivalent usage example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to blkio parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of blkio parameters; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetBlockInfo"/>virDomainGetBlockInfo ()</h3><pre class="programlisting">int	virDomainGetBlockInfo		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a> info, <br/>					 unsigned int flags)<br/>
</pre><p>Extract information about a domain's block device.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virDomainBlockInfo">virDomainBlockInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetBlockIoTune"/>virDomainGetBlockIoTune ()</h3><pre class="programlisting">int	virDomainGetBlockIoTune		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all block IO tunable parameters for a given device. On input,
@nparams gives the size of the @params array; on output, @nparams
gives how many slots were filled with parameter information, which
might be less but will not exceed the input value.

As a special case, calling with @params as NULL and @nparams as 0
on input will cause @nparams on output to contain the number of
parameters supported by the hypervisor, either for the given @disk
(note that block devices of different types might support different
parameters), or if @disk is NULL, for all possible disks. The
caller should then allocate @params array,
i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again. See virDomainGetMemoryParameters() for more details.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the &lt;target
dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found
by calling virDomainGetXMLDesc() and inspecting elements
within //domain/devices/disk. This parameter cannot be NULL
unless @nparams is 0 on input.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>Pointer to blkio parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>Pointer to number of blkio parameters</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetBlockJobInfo"/>virDomainGetBlockJobInfo ()</h3><pre class="programlisting">int	virDomainGetBlockJobInfo	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a> info, <br/>					 unsigned int flags)<br/>
</pre><p>Request block job information for the given disk. If an operation is active
@info will be updated with the current progress.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a> structure</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 when nothing found, 1 when info was found.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetCPUStats"/>virDomainGetCPUStats ()</h3><pre class="programlisting">int	virDomainGetCPUStats		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 int start_cpu, <br/>					 unsigned int ncpus, <br/>					 unsigned int flags)<br/>
</pre><p>Get statistics relating to CPU usage attributable to a single
domain (in contrast to the statistics returned by
virNodeGetCPUStats() for all processes on the host). @dom
must be running (an inactive domain has no attributable cpu
usage). On input, @params must contain at least @nparams * @ncpus
entries, allocated by the caller.

If @start_cpu is -1, then @ncpus must be 1, and the returned
results reflect the statistics attributable to the entire
domain (such as user and system time for the process as a
whole). Otherwise, @start_cpu represents which cpu to start
with, and @ncpus represents how many consecutive processors to
query, with statistics attributable per processor (such as
per-cpu usage). If @ncpus is larger than the number of cpus
available to query, then the trailing part of the array will
be unpopulated.

The remote driver imposes a limit of 128 @ncpus and 16 @nparams;
the number of parameters per cpu should not exceed 16, but if you
have a host with more than 128 CPUs, your program should split
the request into multiple calls.

As special cases, if @params is NULL and @nparams is 0 and
@ncpus is 1, and the return value will be how many
statistics are available for the given @start_cpu. This number
may be different for @start_cpu of -1 than for any non-negative
value, but will be the same for all non-negative @start_cpu.
Likewise, if @params is NULL and @nparams is 0 and @ncpus is 0,
the number of cpus available to query is returned. From the
host perspective, this would typically match the cpus member
of virNodeGetInfo(), but might be less due to host cpu hotplug.

For now, @flags is unused, and the statistics all relate to the
usage from the host perspective. It is possible that a future
version will support a flag that queries the cpu usage from the
guest's perspective, where the maximum cpu to query would be
related to virDomainGetVcpusFlags() rather than virNodeGetInfo().
An individual guest vcpu cannot be reliably mapped back to a
specific host cpu unless a single-processor vcpu pinning was used,
but when @start_cpu is -1, any difference in usage between a host
and guest perspective would serve as a measure of hypervisor overhead.

Typical use sequence is below.

getting total stats: set start_cpu as -1, ncpus 1
virDomainGetCPUStats(dom, NULL, 0, -1, 1, 0) =&gt; nparams
params = calloc(nparams, sizeof(virTypedParameter))
virDomainGetCPUStats(dom, params, nparams, -1, 1, 0) =&gt; total stats.

getting per-cpu stats:
virDomainGetCPUStats(dom, NULL, 0, 0, 0, 0) =&gt; ncpus
virDomainGetCPUStats(dom, NULL, 0, 0, 1, 0) =&gt; nparams
params = calloc(ncpus * nparams, sizeof(virTypedParameter))
virDomainGetCPUStats(dom, params, nparams, 0, ncpus, 0) =&gt; per-cpu stats</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>domain to query</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array to populate on output</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters per cpu</td></tr><tr><td><span class="term"><i><tt>start_cpu</tt></i>:</span></td><td>which cpu to start with, or -1 for summary</td></tr><tr><td><span class="term"><i><tt>ncpus</tt></i>:</span></td><td>how many cpus to query</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 on failure, or the number of statistics that were populated per cpu on success (this will be less than the total number of populated @params, unless @ncpus was 1; and may be less than @nparams). The populated parameters start at each stride of @nparams, which means the results may be discontiguous; any unpopulated parameters will be zeroed on success (this includes skipped elements if @nparams is too large, and tail elements if @ncpus is too large). The caller is responsible for freeing any returned string parameters.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetConnect"/>virDomainGetConnect ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virDomainGetConnect	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)<br/>
</pre><p>Provides the connection pointer associated with a domain. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the domain object together.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to a domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetControlInfo"/>virDomainGetControlInfo ()</h3><pre class="programlisting">int	virDomainGetControlInfo		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virDomainControlInfoPtr">virDomainControlInfoPtr</a> info, <br/>					 unsigned int flags)<br/>
</pre><p>Extract details about current state of control interface to a domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virDomainControlInfo">virDomainControlInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetDiskErrors"/>virDomainGetDiskErrors ()</h3><pre class="programlisting">int	virDomainGetDiskErrors		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt.html#virDomainDiskErrorPtr">virDomainDiskErrorPtr</a> errors, <br/>					 unsigned int maxerrors, <br/>					 unsigned int flags)<br/>
</pre><p>The function populates @errors array with all disks that encountered an
I/O error. Disks with no error will not be returned in the @errors array.
Each disk is identified by its target (the dev attribute of target
subelement in domain XML), such as "vda", and accompanied with the error
that was seen on it. The caller is also responsible for calling free()
on each disk name returned.

In a special case when @errors is NULL and @maxerrors is 0, the function</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>errors</tt></i>:</span></td><td>array to populate on output</td></tr><tr><td><span class="term"><i><tt>maxerrors</tt></i>:</span></td><td>size of @errors array</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>preferred size of @errors that the caller should use to get all disk errors. Since calling virDomainGetDiskErrors(dom, NULL, 0, 0) to get preferred size of @errors array and getting the errors are two separate operations, new disks may be hotplugged to the domain and new errors may be encountered between the two calls. Thus, this function may not return all disk errors because the supplied array is not large enough. Such errors may, however, be detected by listening to domain events. Returns number of disks with errors filled in the @errors array or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetEmulatorPinInfo"/>virDomainGetEmulatorPinInfo ()</h3><pre class="programlisting">int	virDomainGetEmulatorPinInfo	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Query the CPU affinity setting of all emulator threads of domain, store
it in cpumap.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs for all emulator threads of this domain (in 8-bit bytes) (OUT) There is only one cpumap for all emulator threads. Must not be NULL.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> Must not be <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> concurrently.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 in case of success, 0 in case of no emulator threads are pined to pcpus, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetHostname"/>virDomainGetHostname ()</h3><pre class="programlisting">char *	virDomainGetHostname		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Get the hostname for that domain.

Dependent on hypervisor used, this may require a guest agent to be
available.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the hostname which must be freed by the caller, or NULL if there was an error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetID"/>virDomainGetID ()</h3><pre class="programlisting">unsigned int	virDomainGetID		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Get the hypervisor ID number for the domain</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the domain ID number or (unsigned int) -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetInfo"/>virDomainGetInfo ()</h3><pre class="programlisting">int	virDomainGetInfo		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virDomainInfoPtr">virDomainInfoPtr</a> info)<br/>
</pre><p>Extract information about a domain. Note that if the connection
used to get the domain is limited only a partial set of the information
can be extracted.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virDomainInfo">virDomainInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetInterfaceParameters"/>virDomainGetInterfaceParameters ()</h3><pre class="programlisting">int	virDomainGetInterfaceParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all interface parameters. On input, @nparams gives the size of
the @params array; on output, @nparams gives how many slots were
filled with parameter information, which might be less but will not
exceed the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the
API again. See virDomainGetMemoryParameters() for an equivalent usage
example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>device</tt></i>:</span></td><td>the interface name or mac address</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to interface parameter objects (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of interface parameter; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetJobInfo"/>virDomainGetJobInfo ()</h3><pre class="programlisting">int	virDomainGetJobInfo		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virDomainJobInfoPtr">virDomainJobInfoPtr</a> info)<br/>
</pre><p>Extract information about progress of a background job on a domain.
Will return an error if the domain is not active.

This function returns a limited amount of information in comparison
to virDomainGetJobStats().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetJobStats"/>virDomainGetJobStats ()</h3><pre class="programlisting">int	virDomainGetJobStats		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * type, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Extract information about progress of a background job on a domain.
Will return an error if the domain is not active. The function returns
a superset of progress information provided by virDomainGetJobInfo.
Possible fields returned in @params are defined by VIR_DOMAIN_JOB_*
macros and new fields will likely be introduced in the future so callers
may receive fields that they do not understand in case they talk to a
newer server.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>where to store the job type (one of virDomainJobType)</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>where to store job statistics</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of items in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetMaxMemory"/>virDomainGetMaxMemory ()</h3><pre class="programlisting">unsigned long	virDomainGetMaxMemory	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Retrieve the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this get the amount of memory reserved
to Domain0 i.e. the domain where the application runs.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the memory size in kibibytes (blocks of 1024 bytes), or 0 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetMaxVcpus"/>virDomainGetMaxVcpus ()</h3><pre class="programlisting">int	virDomainGetMaxVcpus		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Provides the maximum number of virtual CPUs supported for
the guest VM. If the guest is inactive, this is basically
the same as virConnectGetMaxVcpus(). If the guest is running
this will reflect the maximum number of virtual CPUs the
guest was booted with. For more details, see virDomainGetVcpusFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the maximum of virtual CPU or -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetMemoryParameters"/>virDomainGetMemoryParameters ()</h3><pre class="programlisting">int	virDomainGetMemoryParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all memory parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

Here is a sample code snippet:

 if ((virDomainGetMemoryParameters(dom, NULL, &amp;nparams, 0) == 0) &amp;&amp;
 (nparams != 0)) {
 if ((params = malloc(sizeof(*params) * nparams)) == NULL)
 goto error;
 memset(params, 0, sizeof(*params) * nparams);
 if (virDomainGetMemoryParameters(dom, params, &amp;nparams, 0))
 goto error;
 }

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to memory parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of memory parameters; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetMetadata"/>virDomainGetMetadata ()</h3><pre class="programlisting">char *	virDomainGetMetadata		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int type, <br/>					 const char * uri, <br/>					 unsigned int flags)<br/>
</pre><p>Retrieves the appropriate domain element given by @type.
If <a href="libvirt-libvirt.html#VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a> is requested parameter @uri
must be set to the name of the namespace the requested elements
belong to, otherwise must be NULL.

If an element of the domain XML is not present, the resulting
error will be VIR_ERR_NO_DOMAIN_METADATA. This method forms
a shortcut for seeing information from virDomainSetMetadata()
without having to go through virDomainGetXMLDesc().

@flags controls whether the live domain or persistent
configuration will be queried.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of description, from <a href="libvirt-libvirt.html#virDomainMetadataType">virDomainMetadataType</a></td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>XML namespace identifier</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the metadata string on success (caller must free), or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetName"/>virDomainGetName ()</h3><pre class="programlisting">const char *	virDomainGetName	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Get the public name for that domain</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetNumaParameters"/>virDomainGetNumaParameters ()</h3><pre class="programlisting">int	virDomainGetNumaParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all numa parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

See virDomainGetMemoryParameters() for an equivalent usage example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to numa parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of numa parameters</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetOSType"/>virDomainGetOSType ()</h3><pre class="programlisting">char *	virDomainGetOSType		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Get the type of domain operation system.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new string or NULL in case of error, the string must be freed by the caller.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSchedulerParameters"/>virDomainGetSchedulerParameters ()</h3><pre class="programlisting">int	virDomainGetSchedulerParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams)<br/>
</pre><p>Get all scheduler parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value. @nparams cannot be 0.

It is hypervisor specific whether this returns the live or
persistent state; for more control, use
virDomainGetSchedulerParametersFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter objects (return value)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of scheduler parameter objects (this value should generally be as large as the returned value nparams of virDomainGetSchedulerType()); input and output</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSchedulerParametersFlags"/>virDomainGetSchedulerParametersFlags ()</h3><pre class="programlisting">int	virDomainGetSchedulerParametersFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int * nparams, <br/>						 unsigned int flags)<br/>
</pre><p>Get all scheduler parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value. @nparams cannot be 0.

The value of @flags can be exactly VIR_DOMAIN_AFFECT_CURRENT,
VIR_DOMAIN_AFFECT_LIVE, or VIR_DOMAIN_AFFECT_CONFIG.

Here is a sample code snippet:

char *ret = virDomainGetSchedulerType(dom, &amp;nparams);
if (ret &amp;&amp; nparams != 0) {
 if ((params = malloc(sizeof(*params) * nparams)) == NULL)
 goto error;
 memset(params, 0, sizeof(*params) * nparams);
 if (virDomainGetSchedulerParametersFlags(dom, params, &amp;nparams, 0))
 goto error;
}</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter object (return value)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of scheduler parameter (this value should be same than the returned value nparams of virDomainGetSchedulerType()); input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSchedulerType"/>virDomainGetSchedulerType ()</h3><pre class="programlisting">char *	virDomainGetSchedulerType	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * nparams)<br/>
</pre><p>Get the scheduler type and the number of scheduler parameters.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of scheduler parameters, can be NULL (return value)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error. The caller must free the returned string.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSecurityLabel"/>virDomainGetSecurityLabel ()</h3><pre class="programlisting">int	virDomainGetSecurityLabel	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> seclabel)<br/>
</pre><p>Extract security label of an active domain. The 'label' field
in the @seclabel argument will be initialized to the empty
string if the domain is not running under a security model.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>seclabel</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSecurityLabelList"/>virDomainGetSecurityLabelList ()</h3><pre class="programlisting">int	virDomainGetSecurityLabelList	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> * seclabels)<br/>
</pre><p>Extract the security labels of an active domain. The 'label' field
in the @seclabels argument will be initialized to the empty
string if the domain is not running under a security model.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>seclabels</tt></i>:</span></td><td>will be auto-allocated and filled with domains' security labels. Caller must free memory on return.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>number of elemnets in @seclabels on success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetState"/>virDomainGetState ()</h3><pre class="programlisting">int	virDomainGetState		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * state, <br/>					 int * reason, <br/>					 unsigned int flags)<br/>
</pre><p>Extract domain state. Each state can be accompanied with a reason (if known)
which led to the state.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>state</tt></i>:</span></td><td>returned state of the domain (one of virDomainState)</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>returned reason which led to @state (one of virDomain*Reason corresponding to the current state); it is allowed to be NULL</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetUUID"/>virDomainGetUUID ()</h3><pre class="programlisting">int	virDomainGetUUID		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * uuid)<br/>
</pre><p>Get the UUID for a domain</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetUUIDString"/>virDomainGetUUIDString ()</h3><pre class="programlisting">int	virDomainGetUUIDString		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 char * buf)<br/>
</pre><p>Get the UUID for a domain as string. For more information about
UUID see RFC4122.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetVcpuPinInfo"/>virDomainGetVcpuPinInfo ()</h3><pre class="programlisting">int	virDomainGetVcpuPinInfo		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int ncpumaps, <br/>					 unsigned char * cpumaps, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Query the CPU affinity setting of all virtual CPUs of domain, store it
in cpumaps.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>ncpumaps</tt></i>:</span></td><td>the number of cpumap (listed first to match virDomainGetVcpus)</td></tr><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) It's assumed there is &lt;ncpumaps&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (ncpumaps * maplen) bytes (ie: calloc(ncpumaps, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API. Must not be NULL.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> Must not be <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> concurrently.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of virtual CPUs in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetVcpus"/>virDomainGetVcpus ()</h3><pre class="programlisting">int	virDomainGetVcpus		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virVcpuInfoPtr">virVcpuInfoPtr</a> info, <br/>					 int maxinfo, <br/>					 unsigned char * cpumaps, <br/>					 int maplen)<br/>
</pre><p>Extract information about virtual CPUs of domain, store it in info array
and also in cpumaps if this pointer isn't NULL. This call may fail
on an inactive domain.

See also <a href="libvirt-libvirt.html#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a> for querying just cpumaps, including on
an inactive domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to an array of <a href="libvirt-libvirt.html#virVcpuInfo">virVcpuInfo</a> structures (OUT)</td></tr><tr><td><span class="term"><i><tt>maxinfo</tt></i>:</span></td><td>number of structures in info array</td></tr><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cpumap information is returned by the API. It's assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). Must be zero when cpumaps is NULL and positive when it is non-NULL.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of info filled in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetVcpusFlags"/>virDomainGetVcpusFlags ()</h3><pre class="programlisting">int	virDomainGetVcpusFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Query the number of virtual CPUs used by the domain. Note that
this call may fail if the underlying virtualization hypervisor does
not support it. This function may require privileged access to the
hypervisor.

If @flags includes VIR_DOMAIN_AFFECT_LIVE, this will query a
running domain (which will fail if domain is not active); if
it includes VIR_DOMAIN_AFFECT_CONFIG, this will query the XML
description of the domain. It is an error to set both flags.
If neither flag is set (that is, VIR_DOMAIN_AFFECT_CURRENT),
then the configuration queried depends on whether the domain
is currently running.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then the maximum
virtual CPU limit is queried. Otherwise, this call queries the
current virtual CPU count.

If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of the processors
is modified in the guest instead of the hypervisor. This flag is only usable
on live domains. Guest agent may be needed for this flag to be available.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainVcpuFlags">virDomainVcpuFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of vCPUs in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetXMLDesc"/>virDomainGetXMLDesc ()</h3><pre class="programlisting">char *	virDomainGetXMLDesc		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Provide an XML description of the domain. The description may be reused
later to relaunch the domain with virDomainCreateXML().

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only
connections. If @flags includes VIR_DOMAIN_XML_INACTIVE, then the
XML represents the configuration that will be used on the next boot
of a persistent domain; otherwise, the configuration represents the
currently running domain. If @flags contains
VIR_DOMAIN_XML_UPDATE_CPU, then the portion of the domain XML
describing CPU capabilities is modified to match actual
capabilities of the host.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainXMLFlags">virDomainXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainHasCurrentSnapshot"/>virDomainHasCurrentSnapshot ()</h3><pre class="programlisting">int	virDomainHasCurrentSnapshot	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Determine if the domain has a current snapshot.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if such snapshot exists, 0 if it doesn't, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainHasManagedSaveImage"/>virDomainHasManagedSaveImage ()</h3><pre class="programlisting">int	virDomainHasManagedSaveImage	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags)<br/>
</pre><p>Check if a domain has a managed save image as created by
virDomainManagedSave(). Note that any running domain should not have
such an image, as it should have been removed on restart.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if no image is present, 1 if an image is present, and -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInjectNMI"/>virDomainInjectNMI ()</h3><pre class="programlisting">int	virDomainInjectNMI		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Send NMI to the guest</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceStats"/>virDomainInterfaceStats ()</h3><pre class="programlisting">int	virDomainInterfaceStats		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * path, <br/>					 <a href="libvirt-libvirt.html#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a> stats, <br/>					 size_t size)<br/>
</pre><p>This function returns network interface stats for interfaces
attached to the domain.

The path parameter is the name of the network interface.

Domains may have more than one network interface. To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>path</tt></i>:</span></td><td>path to the interface</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>network interface stats (returned)</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of stats structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIsActive"/>virDomainIsActive ()</h3><pre class="programlisting">int	virDomainIsActive		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)<br/>
</pre><p>Determine if the domain is currently running</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIsPersistent"/>virDomainIsPersistent ()</h3><pre class="programlisting">int	virDomainIsPersistent		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)<br/>
</pre><p>Determine if the domain has a persistent configuration
which means it will still exist after shutting down</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if persistent, 0 if transient, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIsUpdated"/>virDomainIsUpdated ()</h3><pre class="programlisting">int	virDomainIsUpdated		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)<br/>
</pre><p>Determine if the domain has been updated.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if updated, 0 if not, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainListAllSnapshots"/>virDomainListAllSnapshots ()</h3><pre class="programlisting">int	virDomainListAllSnapshots	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> ** snaps, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of domain snapshots for the given domain, and allocate
an array to store those objects. This API solves the race inherent in
virDomainSnapshotListNames().

By default, this command covers all snapshots; it is also possible to
limit things to just snapshots with no parents, when @flags includes
VIR_DOMAIN_SNAPSHOT_LIST_ROOTS. Additional filters are provided in
groups, where each group contains bits that describe mutually exclusive
attributes of a snapshot, and where all bits within a group describe
all possible snapshots. Some hypervisors might reject explicit bits
from a group where the hypervisor cannot make a distinction. For a
group supported by a given hypervisor, the behavior when no bits of a
group are set is identical to the behavior when all bits in that group
are set. When setting bits from more than one group, it is possible to
select an impossible combination, in that case a hypervisor may return
either 0 or an error.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that
have no further children (a leaf snapshot).

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on
whether they have metadata that would prevent the removal of the last
reference to a domain.

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,
VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,
for filtering snapshots based on what domain state is tracked by the
snapshot.

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and
VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on
whether the snapshot is stored inside the disk images or as
additional files.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>snaps</tt></i>:</span></td><td>pointer to variable to store the array containing snapshot objects, or NULL if the list is not required (just returns number of snapshots)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain snapshots found or -1 and sets @snaps to NULL in case of error. On success, the array stored into @snaps is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virDomainSnapshotFree() on each array element, then calling free() on @snaps.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLookupByID"/>virDomainLookupByID ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int id)<br/>
</pre><p>Try to find a domain based on the hypervisor ID number
Note that this won't work for inactive domains which have an ID of -1,
in that case a lookup based on the Name or UUId need to be done instead.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>id</tt></i>:</span></td><td>the domain ID number</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLookupByName"/>virDomainLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * name)<br/>
</pre><p>Try to lookup a domain on the given hypervisor based on its name.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLookupByUUID"/>virDomainLookupByUUID ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid)<br/>
</pre><p>Try to lookup a domain on the given hypervisor based on its UUID.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLookupByUUIDString"/>virDomainLookupByUUIDString ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr)<br/>
</pre><p>Try to lookup a domain on the given hypervisor based on its UUID.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainManagedSave"/>virDomainManagedSave ()</h3><pre class="programlisting">int	virDomainManagedSave		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags)<br/>
</pre><p>This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore.
The difference from virDomainSave() is that libvirt is keeping track of
the saved state itself, and will reuse it once the domain is being
restarted (automatically or via an explicit libvirt call).
As a result any running domain is sure to not have a managed saved image.
This also implies that managed save only works on persistent domains,
since the domain must still exist in order to use virDomainCreate() to
restart it.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while creating the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.

Normally, the managed saved state will remember whether the domain
was running or paused, and start will resume to the same state.
Specifying <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override the default saved into the file. These two
flags are mutually exclusive.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainManagedSaveRemove"/>virDomainManagedSaveRemove ()</h3><pre class="programlisting">int	virDomainManagedSaveRemove	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags)<br/>
</pre><p>Remove any managed save image for this domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, and -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryPeek"/>virDomainMemoryPeek ()</h3><pre class="programlisting">int	virDomainMemoryPeek		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned long long start, <br/>					 size_t size, <br/>					 void * buffer, <br/>					 unsigned int flags)<br/>
</pre><p>This function allows you to read the contents of a domain's
memory.

The memory which is read is controlled by the 'start', 'size'
and 'flags' parameters.

If 'flags' is <a href="libvirt-libvirt.html#VIR_MEMORY_VIRTUAL">VIR_MEMORY_VIRTUAL</a> then the 'start' and 'size'
parameters are interpreted as virtual memory addresses for
whichever task happens to be running on the domain at the
moment. Although this sounds haphazard it is in fact what
you want in order to read Linux kernel state, because it
ensures that pointers in the kernel image can be interpreted
coherently.

'buffer' is the return buffer and must be at least 'size' bytes.
'size' may be 0 to test if the call would succeed.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to &lt;= 65536 bytes.
However, with 0.9.13 this RPC limit has been raised to 1M byte.
Starting with version 1.0.6 the RPC limit has been raised again.
Now large requests up to 16M byte are supported.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>start</tt></i>:</span></td><td>start of memory to peek</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of memory to peek</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>return buffer (must be at least size bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMemoryFlags">virDomainMemoryFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure. really 64 bits</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryStats"/>virDomainMemoryStats ()</h3><pre class="programlisting">int	virDomainMemoryStats		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt.html#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a> stats, <br/>					 unsigned int nr_stats, <br/>					 unsigned int flags)<br/>
</pre><p>This function provides memory statistics for the domain.

Up to 'nr_stats' elements of 'stats' will be populated with memory statistics
from the domain. Only statistics supported by the domain, the driver, and
this version of libvirt will be returned.

Memory Statistics:

VIR_DOMAIN_MEMORY_STAT_SWAP_IN:
 The total amount of data read from swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_SWAP_OUT:
 The total amount of memory written out to swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT:
 The number of page faults that required disk IO to service.
VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT:
 The number of page faults serviced without disk IO.
VIR_DOMAIN_MEMORY_STAT_UNUSED:
 The amount of memory which is not being used for any purpose (in kb).
VIR_DOMAIN_MEMORY_STAT_AVAILABLE:
 The total amount of memory available to the domain's OS (in kb).
VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON:
 Current balloon value (in kb).</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>nr_stats-sized array of stat structures (returned)</td></tr><tr><td><span class="term"><i><tt>nr_stats</tt></i>:</span></td><td>number of memory statistics requested</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>The number of stats provided or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrate"/>virDomainMigrate ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainMigrate	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 const char * uri, <br/>					 unsigned long bandwidth)<br/>
</pre><p>Migrate the domain object from its current host to the destination
host given by dconn (a connection to the destination host).

Flags may be one of more of the following:
 <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts
 <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain
 on the destination host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the
 domain on the source host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> Migration with non-shared storage with full
 disk copy
 <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> Migration with non-shared storage with
 incremental disk copy
 <a href="libvirt-libvirt.html#VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> Protect against domain configuration
 changes during the migration process (set
 automatically when supported).
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> Force migration even if it is considered unsafe.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> Migrate offline

VIR_MIGRATE_TUNNELLED requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.
Applications using the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag will probably
prefer to invoke virDomainMigrateToURI, avoiding the need to
open connection to the destination host themselves.

If a hypervisor supports renaming domains during migration,
then you may set the dname parameter to the new name (otherwise
it keeps the same name). If this is not supported by the
hypervisor, dname must be NULL or else you will get an error.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the uri parameter
must be a valid libvirt connection URI, by which the source
libvirt driver can connect to the destination libvirt. If
omitted, the dconn connection object will be queried for its
current URI.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the URI parameter
takes a hypervisor specific format. The hypervisor capabilities
XML includes details of the support URI schemes. If omitted
the dconn will be asked for a default URI.

If you want to copy non-shared storage within migration you
can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or
VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.

In either case it is typically only necessary to specify a
URI if the destination host has multiple interfaces and a
specific interface is required to transmit migration data.

The maximum bandwidth (in MiB/s) that will be used to do migration
can be specified with the bandwidth parameter. If set to 0,
libvirt will choose a suitable default. Some hypervisors do
not support this feature and will return an error if bandwidth
is not 0.

To see which features are supported by the current hypervisor,
see virConnectGetCapabilities, /capabilities/host/migration_features.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconn</tt></i>:</span></td><td>destination host (a connection object)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>(optional) dest hostname/URI as seen from the source host</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrate2"/>virDomainMigrate2 ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainMigrate2	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 const char * dxml, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 const char * uri, <br/>					 unsigned long bandwidth)<br/>
</pre><p>Migrate the domain object from its current host to the destination
host given by dconn (a connection to the destination host).

Flags may be one of more of the following:
 <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts
 <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain
 on the destination host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the
 domain on the source host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> Migration with non-shared storage with full
 disk copy
 <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> Migration with non-shared storage with
 incremental disk copy
 <a href="libvirt-libvirt.html#VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> Protect against domain configuration
 changes during the migration process (set
 automatically when supported).
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> Force migration even if it is considered unsafe.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> Migrate offline

VIR_MIGRATE_TUNNELLED requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.
Applications using the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag will probably
prefer to invoke virDomainMigrateToURI, avoiding the need to
open connection to the destination host themselves.

If a hypervisor supports renaming domains during migration,
then you may set the dname parameter to the new name (otherwise
it keeps the same name). If this is not supported by the
hypervisor, dname must be NULL or else you will get an error.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the uri parameter
must be a valid libvirt connection URI, by which the source
libvirt driver can connect to the destination libvirt. If
omitted, the dconn connection object will be queried for its
current URI.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the URI parameter
takes a hypervisor specific format. The hypervisor capabilities
XML includes details of the support URI schemes. If omitted
the dconn will be asked for a default URI.

If you want to copy non-shared storage within migration you
can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or
VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.

In either case it is typically only necessary to specify a
URI if the destination host has multiple interfaces and a
specific interface is required to transmit migration data.

The maximum bandwidth (in MiB/s) that will be used to do migration
can be specified with the bandwidth parameter. If set to 0,
libvirt will choose a suitable default. Some hypervisors do
not support this feature and will return an error if bandwidth
is not 0.

To see which features are supported by the current hypervisor,
see virConnectGetCapabilities, /capabilities/host/migration_features.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.

If the hypervisor supports it, @dxml can be used to alter
host-specific portions of the domain XML that will be used on
the destination. For example, it is possible to alter the
backing filename that is associated with a disk device, in order
to account for naming differences between source and destination
in accessing the underlying storage. The migration will fail
if @dxml would cause any guest-visible changes. Pass NULL
if no changes are needed to the XML between source and destination.
@dxml cannot be used to rename the domain during migration (use
@dname for that purpose). Domain name in @dxml must match the
original domain name.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconn</tt></i>:</span></td><td>destination host (a connection object)</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>(optional) XML config for launching guest on target</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>(optional) dest hostname/URI as seen from the source host</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrate3"/>virDomainMigrate3 ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainMigrate3	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Migrate the domain object from its current host to the destination host
given by dconn (a connection to the destination host).

See <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a> documentation for description of individual flags.

VIR_MIGRATE_TUNNELLED and <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> are not supported by this
API, use <a href="libvirt-libvirt.html#virDomainMigrateToURI3">virDomainMigrateToURI3</a> instead.

If you want to copy non-shared storage within migration you
can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or
VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconn</tt></i>:</span></td><td>destination host (a connection object)</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>(optional) migration parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>(optional) number of migration parameters in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateGetCompressionCache"/>virDomainMigrateGetCompressionCache ()</h3><pre class="programlisting">int	virDomainMigrateGetCompressionCache	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 unsigned long long * cacheSize, <br/>						 unsigned int flags)<br/>
</pre><p>Gets current size of the cache (in bytes) used for compressing repeatedly
transferred memory pages during live migration.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>cacheSize</tt></i>:</span></td><td>return value of current size of the cache (in bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateGetMaxSpeed"/>virDomainMigrateGetMaxSpeed ()</h3><pre class="programlisting">int	virDomainMigrateGetMaxSpeed	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long * bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Get the current maximum bandwidth (in MiB/s) that will be used if the
domain is migrated. Not all hypervisors will support a bandwidth limit.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>return value of current migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateSetCompressionCache"/>virDomainMigrateSetCompressionCache ()</h3><pre class="programlisting">int	virDomainMigrateSetCompressionCache	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 unsigned long long cacheSize, <br/>						 unsigned int flags)<br/>
</pre><p>Sets size of the cache (in bytes) used for compressing repeatedly
transferred memory pages during live migration. It's supposed to be called
while the domain is being live-migrated as a reaction to migration progress
and increasing number of compression cache misses obtained from
virDomainGetJobStats.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>cacheSize</tt></i>:</span></td><td>size of the cache (in bytes) used for compression</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateSetMaxDowntime"/>virDomainMigrateSetMaxDowntime ()</h3><pre class="programlisting">int	virDomainMigrateSetMaxDowntime	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long long downtime, <br/>					 unsigned int flags)<br/>
</pre><p>Sets maximum tolerable time for which the domain is allowed to be paused
at the end of live migration. It's supposed to be called while the domain is
being live-migrated as a reaction to migration progress.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>downtime</tt></i>:</span></td><td>maximum tolerable downtime for live migration, in milliseconds</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateSetMaxSpeed"/>virDomainMigrateSetMaxSpeed ()</h3><pre class="programlisting">int	virDomainMigrateSetMaxSpeed	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>The maximum bandwidth (in MiB/s) that will be used to do migration
can be specified with the bandwidth parameter. Not all hypervisors
will support a bandwidth cap</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateToURI"/>virDomainMigrateToURI ()</h3><pre class="programlisting">int	virDomainMigrateToURI		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * duri, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 unsigned long bandwidth)<br/>
</pre><p>Migrate the domain object from its current host to the destination
host given by duri.

Flags may be one of more of the following:
 <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts
 <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain
 on the destination host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the
 domain on the source host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> Migration with non-shared storage with full
 disk copy
 <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> Migration with non-shared storage with
 incremental disk copy
 <a href="libvirt-libvirt.html#VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> Protect against domain configuration
 changes during the migration process (set
 automatically when supported).
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> Force migration even if it is considered unsafe.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> Migrate offline

The operation of this API hinges on the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.
If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the duri parameter
takes a hypervisor specific format. The uri_transports element of the
hypervisor capabilities XML includes details of the supported URI
schemes. Not all hypervisors will support this mode of migration, so
if the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is not set, then it may be necessary
to use the alternative <a href="libvirt-libvirt.html#virDomainMigrate">virDomainMigrate</a> API providing and explicit
virConnectPtr for the destination host.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag IS set, the duri parameter
must be a valid libvirt connection URI, by which the source
libvirt driver can connect to the destination libvirt.

VIR_MIGRATE_TUNNELLED requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.

If you want to copy non-shared storage within migration you
can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or
VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.

If a hypervisor supports renaming domains during migration,
the dname parameter specifies the new name for the domain.
Setting dname to NULL keeps the domain name the same. If domain
renaming is not supported by the hypervisor, dname must be NULL or
else an error will be returned.

The maximum bandwidth (in MiB/s) that will be used to do migration
can be specified with the bandwidth parameter. If set to 0,
libvirt will choose a suitable default. Some hypervisors do
not support this feature and will return an error if bandwidth
is not 0.

To see which features are supported by the current hypervisor,
see virConnectGetCapabilities, /capabilities/host/migration_features.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>duri</tt></i>:</span></td><td>mandatory URI for the destination host</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the migration succeeded, -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateToURI2"/>virDomainMigrateToURI2 ()</h3><pre class="programlisting">int	virDomainMigrateToURI2		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dconnuri, <br/>					 const char * miguri, <br/>					 const char * dxml, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 unsigned long bandwidth)<br/>
</pre><p>Migrate the domain object from its current host to the destination
host given by duri.

Flags may be one of more of the following:
 <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts
 <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain
 on the destination host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the
 domain on the source host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> Migration with non-shared storage with full
 disk copy
 <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> Migration with non-shared storage with
 incremental disk copy
 <a href="libvirt-libvirt.html#VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> Protect against domain configuration
 changes during the migration process (set
 automatically when supported).
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> Force migration even if it is considered unsafe.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> Migrate offline

The operation of this API hinges on the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the @dconnuri parameter
must be a valid libvirt connection URI, by which the source
libvirt driver can connect to the destination libvirt. If the
VIR_MIGRATE_PEER2PEER flag is NOT set, then @dconnuri must be
NULL.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> flag is NOT set, then the @miguri
parameter allows specification of a URI to use to initiate the
VM migration. It takes a hypervisor specific format. The uri_transports
element of the hypervisor capabilities XML includes details of the
supported URI schemes.

VIR_MIGRATE_TUNNELLED requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.

If you want to copy non-shared storage within migration you
can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or
VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.

If a hypervisor supports changing the configuration of the guest
during migration, the @dxml parameter specifies the new config
for the guest. The configuration must include an identical set
of virtual devices, to ensure a stable guest ABI across migration.
Only parameters related to host side configuration can be
changed in the XML. Hypervisors will validate this and refuse to
allow migration if the provided XML would cause a change in the
guest ABI,

If a hypervisor supports renaming domains during migration,
the dname parameter specifies the new name for the domain.
Setting dname to NULL keeps the domain name the same. If domain
renaming is not supported by the hypervisor, dname must be NULL or
else an error will be returned.

The maximum bandwidth (in MiB/s) that will be used to do migration
can be specified with the bandwidth parameter. If set to 0,
libvirt will choose a suitable default. Some hypervisors do
not support this feature and will return an error if bandwidth
is not 0.

To see which features are supported by the current hypervisor,
see virConnectGetCapabilities, /capabilities/host/migration_features.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconnuri</tt></i>:</span></td><td>(optional) URI for target libvirtd if @flags includes <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a></td></tr><tr><td><span class="term"><i><tt>miguri</tt></i>:</span></td><td>(optional) URI for invoking the migration, not if @flags includs <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a></td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>(optional) XML config for launching guest on target</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the migration succeeded, -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateToURI3"/>virDomainMigrateToURI3 ()</h3><pre class="programlisting">int	virDomainMigrateToURI3		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dconnuri, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Migrate the domain object from its current host to the destination host
given by URI.

See <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a> documentation for description of individual flags.

The operation of this API hinges on the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the @dconnuri parameter must be a
valid libvirt connection URI, by which the source libvirt daemon can connect
to the destination libvirt.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, then @dconnuri must be NULL
and <a href="libvirt-libvirt.html#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a> migration parameter must be filled in with
hypervisor specific URI used to initiate the migration. This is called
"direct" migration.

VIR_MIGRATE_TUNNELLED requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.

If you want to copy non-shared storage within migration you
can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or
VIR_MIGRATE_NON_SHARED_INC as they are mutually exclusive.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconnuri</tt></i>:</span></td><td>(optional) URI for target libvirtd if @flags includes <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a></td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>(optional) migration parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>(optional) number of migration parameters in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the migration succeeded, -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenChannel"/>virDomainOpenChannel ()</h3><pre class="programlisting">int	virDomainOpenChannel		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * name, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br/>					 unsigned int flags)<br/>
</pre><p>This opens the host interface associated with a channel device on a
guest, if the host interface is supported. If @name is given, it
can match either the device alias (e.g. "channel0"), or the virtio
target name (e.g. "org.qemu.guest_agent.0"). If @name is omitted,
then the first channel is opened. The channel is associated with
the passed in @st stream, which should have been opened in
non-blocking mode for bi-directional I/O.

By default, when @flags is 0, the open will fail if libvirt detects
that the channel is already in use by another client; passing
VIR_DOMAIN_CHANNEL_FORCE will cause libvirt to forcefully remove the
other client prior to opening this channel.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the channel name, or NULL</td></tr><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>a stream to associate with the channel</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainChannelFlags">virDomainChannelFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the channel was opened, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenConsole"/>virDomainOpenConsole ()</h3><pre class="programlisting">int	virDomainOpenConsole		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * dev_name, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br/>					 unsigned int flags)<br/>
</pre><p>This opens the backend associated with a console, serial or
parallel port device on a guest, if the backend is supported.
If the @dev_name is omitted, then the first console or serial
device is opened. The console is associated with the passed
in @st stream, which should have been opened in non-blocking
mode for bi-directional I/O.

By default, when @flags is 0, the open will fail if libvirt
detects that the console is already in use by another client;
passing <a href="libvirt-libvirt.html#VIR_DOMAIN_CONSOLE_FORCE">VIR_DOMAIN_CONSOLE_FORCE</a> will cause libvirt to forcefully
remove the other client prior to opening this console.

If flag <a href="libvirt-libvirt.html#VIR_DOMAIN_CONSOLE_SAFE">VIR_DOMAIN_CONSOLE_SAFE</a> the console is opened only in the
case where the hypervisor driver supports safe (mutually exclusive)
console handling.

Older servers did not support either flag, and also did not forbid
simultaneous clients on a console, with potentially confusing results.
When passing @flags of 0 in order to support a wider range of server
versions, it is up to the client to ensure mutual exclusion.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dev_name</tt></i>:</span></td><td>the console, serial or parallel port device alias, or NULL</td></tr><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>a stream to associate with the console</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainConsoleFlags">virDomainConsoleFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the console was opened, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenGraphics"/>virDomainOpenGraphics ()</h3><pre class="programlisting">int	virDomainOpenGraphics		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int idx, <br/>					 int fd, <br/>					 unsigned int flags)<br/>
</pre><p>This will attempt to connect the file descriptor @fd, to
the graphics backend of @dom. If @dom has multiple graphics
backends configured, then @idx will determine which one is
opened, starting from @idx 0.

To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH
constant for @flags.

The caller should use an anonymous socketpair to open
@fd before invocation.

This method can only be used when connected to a local
libvirt hypervisor, over a UNIX domain socket. Attempts
to use this method over a TCP connection will always fail</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>idx</tt></i>:</span></td><td>index of graphics config to open</td></tr><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>file descriptor to attach graphics to</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPMSuspendForDuration"/>virDomainPMSuspendForDuration ()</h3><pre class="programlisting">int	virDomainPMSuspendForDuration	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int target, <br/>					 unsigned long long duration, <br/>					 unsigned int flags)<br/>
</pre><p>Attempt to have the guest enter the given @target power management
suspension level. If @duration is non-zero, also schedule the guest to
resume normal operation after that many seconds, if nothing else has
resumed it earlier. Some hypervisors require that @duration be 0, for
an indefinite suspension.

Dependent on hypervisor used, this may require a
guest agent to be available, e.g. QEMU.

Beware that at least for QEMU, the domain's process will be terminated
when <a href="libvirt-libvirt.html#VIR_NODE_SUSPEND_TARGET_DISK">VIR_NODE_SUSPEND_TARGET_DISK</a> is used and a new process will be
launched when libvirt is asked to wake up the domain. As a result of
this, any runtime changes, such as device hotplug or memory settings,
are lost unless such changes were made with VIR_DOMAIN_AFFECT_CONFIG
flag.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>target</tt></i>:</span></td><td>a value from <a href="libvirt-libvirt.html#virNodeSuspendTarget">virNodeSuspendTarget</a></td></tr><tr><td><span class="term"><i><tt>duration</tt></i>:</span></td><td>duration in seconds to suspend, or 0 for indefinite</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPMWakeup"/>virDomainPMWakeup ()</h3><pre class="programlisting">int	virDomainPMWakeup		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags)<br/>
</pre><p>Inject a wakeup into the guest that previously used
virDomainPMSuspendForDuration, rather than waiting for the
previously requested duration (if any) to elapse.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPinEmulator"/>virDomainPinEmulator ()</h3><pre class="programlisting">int	virDomainPinEmulator		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the real CPUs which can be allocated to all emulator
threads. This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain
and may fail if domain is not alive.
If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.
Not all hypervisors can support all flag combinations.

See also <a href="libvirt-libvirt.html#virDomainGetEmulatorPinInfo">virDomainGetEmulatorPinInfo</a> for querying this information.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPinVcpu"/>virDomainPinVcpu ()</h3><pre class="programlisting">int	virDomainPinVcpu		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int vcpu, <br/>					 unsigned char * cpumap, <br/>					 int maplen)<br/>
</pre><p>Dynamically change the real CPUs which can be allocated to a virtual CPU.
This function may require privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPinVcpuFlags"/>virDomainPinVcpuFlags ()</h3><pre class="programlisting">int	virDomainPinVcpuFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int vcpu, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the real CPUs which can be allocated to a virtual CPU.
This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain
and may fail if domain is not alive.
If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.
Not all hypervisors can support all flag combinations.

See also <a href="libvirt-libvirt.html#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a> for querying this information.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainReboot"/>virDomainReboot ()</h3><pre class="programlisting">int	virDomainReboot			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Reboot a domain, the domain object is still usable thereafter, but
the domain OS is being stopped for a restart.
Note that the guest OS may ignore the request.
Additionally, the hypervisor may check and support the domain
'on_reboot' XML setting resulting in a domain that shuts down instead
of rebooting.

If @flags is set to zero, then the hypervisor will choose the
method of shutdown it considers best. To have greater control
pass one or more of the virDomainShutdownFlagValues. The order
in which the hypervisor tries each shutdown method is undefined,
and a hypervisor is not required to support all methods.

To use guest agent (VIR_DOMAIN_REBOOT_GUEST_AGENT) the domain XML
must have &lt;channel&gt; configured.

Due to implementation limitations in some drivers (the qemu driver,
for instance) it is not advised to migrate or save a guest that is
rebooting as a result of this API. Migrating such a guest can lead
to a plain shutdown on the destination.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainRebootFlagValues">virDomainRebootFlagValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRef"/>virDomainRef ()</h3><pre class="programlisting">int	virDomainRef			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Increment the reference count on the domain. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virDomainFree">virDomainFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a domain would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>the domain to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainReset"/>virDomainReset ()</h3><pre class="programlisting">int	virDomainReset			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Reset a domain immediately without any guest OS shutdown.
Reset emulates the power reset button on a machine, where all
hardware sees the RST line set and reinitializes internal state.

Note that there is a risk of data loss caused by reset without any
guest OS shutdown.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRestore"/>virDomainRestore ()</h3><pre class="programlisting">int	virDomainRestore		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * from)<br/>
</pre><p>This method will restore a domain saved to disk by virDomainSave().

See virDomainRestoreFlags() for more control.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>from</tt></i>:</span></td><td>path to the input file</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRestoreFlags"/>virDomainRestoreFlags ()</h3><pre class="programlisting">int	virDomainRestoreFlags		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * from, <br/>					 const char * dxml, <br/>					 unsigned int flags)<br/>
</pre><p>This method will restore a domain saved to disk by virDomainSave().

If the hypervisor supports it, @dxml can be used to alter
host-specific portions of the domain XML that will be used when
restoring an image. For example, it is possible to alter the
backing filename that is associated with a disk device, in order to
prepare for file renaming done as part of backing up the disk
device while the domain is stopped.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while restoring the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing restores from NFS.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override the default read from the file. These two
flags are mutually exclusive.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>from</tt></i>:</span></td><td>path to the input file</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>(optional) XML config for adjusting guest xml used on restore</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainResume"/>virDomainResume ()</h3><pre class="programlisting">int	virDomainResume			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Resume a suspended domain, the process is restarted from the state where
it was frozen by calling virDomainSuspend().
This function may require privileged access
Moreover, resume may not be supported if domain is in some
special state like VIR_DOMAIN_PMSUSPENDED.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRevertToSnapshot"/>virDomainRevertToSnapshot ()</h3><pre class="programlisting">int	virDomainRevertToSnapshot	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags)<br/>
</pre><p>Revert the domain to a given snapshot.

Normally, the domain will revert to the same state the domain was
in while the snapshot was taken (whether inactive, running, or
paused), except that disk snapshots default to reverting to
inactive state. Including <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING">VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING</a> in
@flags overrides the snapshot state to guarantee a running domain
after the revert; or including <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED">VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED</a> in
@flags guarantees a paused domain after the revert. These two
flags are mutually exclusive. While a persistent domain does not
need either flag, it is not possible to revert a transient domain
into an inactive state, so transient domains require the use of one
of these two flags.

Reverting to any snapshot discards all configuration changes made since
the last snapshot. Additionally, reverting to a snapshot from a running
domain is a form of data loss, since it discards whatever is in the
guest's RAM at the time. Since the very nature of keeping snapshots
implies the intent to roll back state, no additional confirmation is
normally required for these lossy effects.

However, there are two particular situations where reverting will
be refused by default, and where @flags must include
VIR_DOMAIN_SNAPSHOT_REVERT_FORCE to acknowledge the risks. 1) Any
attempt to revert to a snapshot that lacks the metadata to perform
ABI compatibility checks (generally the case for snapshots that
lack a full &lt;domain&gt; when listed by virDomainSnapshotGetXMLDesc(),
such as those created prior to libvirt 0.9.5). 2) Any attempt to
revert a running domain to an active state that requires starting a
new hypervisor instance rather than reusing the existing hypervisor
(since this would terminate all connections to the domain, such as
such as VNC or Spice graphics) - this condition arises from active
snapshots that are provably ABI incomaptible, as well as from
inactive snapshots with a @flags request to start the domain after
the revert.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSnapshotRevertFlags">virDomainSnapshotRevertFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the creation is successful, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSave"/>virDomainSave ()</h3><pre class="programlisting">int	virDomainSave			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to)<br/>
</pre><p>This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore (this ends the life of a transient domain).
Use virDomainRestore() to restore a domain after saving.

See virDomainSaveFlags() for more control. Also, a save file can
be inspected or modified slightly with virDomainSaveImageGetXMLDesc()
and virDomainSaveImageDefineXML().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the output file</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveFlags"/>virDomainSaveFlags ()</h3><pre class="programlisting">int	virDomainSaveFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 const char * dxml, <br/>					 unsigned int flags)<br/>
</pre><p>This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore (this ends the life of a transient domain).
Use virDomainRestore() to restore a domain after saving.

If the hypervisor supports it, @dxml can be used to alter
host-specific portions of the domain XML that will be used when
restoring an image. For example, it is possible to alter the
backing filename that is associated with a disk device, in order to
prepare for file renaming done as part of backing up the disk
device while the domain is stopped.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while creating the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override what state gets saved into the file. These
two flags are mutually exclusive.

A save file can be inspected or modified slightly with
virDomainSaveImageGetXMLDesc() and virDomainSaveImageDefineXML().

Some hypervisors may prevent this operation if there is a current
block copy operation; in that case, use virDomainBlockJobAbort()
to stop the block copy first.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the output file</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>(optional) XML config for adjusting guest xml used on restore</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveImageDefineXML"/>virDomainSaveImageDefineXML ()</h3><pre class="programlisting">int	virDomainSaveImageDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * file, <br/>					 const char * dxml, <br/>					 unsigned int flags)<br/>
</pre><p>This updates the definition of a domain stored in a saved state
file. @file must be a file created previously by virDomainSave()
or virDomainSaveFlags().

@dxml can be used to alter host-specific portions of the domain XML
that will be used when restoring an image. For example, it is
possible to alter the backing filename that is associated with a
disk device, to match renaming done as part of backing up the disk
device while the domain is stopped.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override the default saved into the file; omitting both
leaves the file's default unchanged. These two flags are mutually
exclusive.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>file</tt></i>:</span></td><td>path to saved state file</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>XML config for adjusting guest xml used on restore</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveImageGetXMLDesc"/>virDomainSaveImageGetXMLDesc ()</h3><pre class="programlisting">char *	virDomainSaveImageGetXMLDesc	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * file, <br/>					 unsigned int flags)<br/>
</pre><p>This method will extract the XML describing the domain at the time
a saved state file was created. @file must be a file created
previously by virDomainSave() or virDomainSaveFlags().

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only
connections. For this API, @flags should not contain either
VIR_DOMAIN_XML_INACTIVE or VIR_DOMAIN_XML_UPDATE_CPU.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>file</tt></i>:</span></td><td>path to saved state file</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of subset of <a href="libvirt-libvirt.html#virDomainXMLFlags">virDomainXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainScreenshot"/>virDomainScreenshot ()</h3><pre class="programlisting">char *	virDomainScreenshot		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 unsigned int screen, <br/>					 unsigned int flags)<br/>
</pre><p>Take a screenshot of current domain console as a stream. The image format
is hypervisor specific. Moreover, some hypervisors supports multiple
displays per domain. These can be distinguished by @screen argument.

This call sets up a stream; subsequent use of stream API is necessary
to transfer actual data, determine how much data is successfully
transferred, and detect any errors.

The screen ID is the sequential number of screen. In case of multiple
graphics cards, heads are enumerated before devices, e.g. having
two graphics cards, both with four heads, screen ID 5 addresses
the second head on the second card.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>stream to use as output</td></tr><tr><td><span class="term"><i><tt>screen</tt></i>:</span></td><td>monitor ID to take screenshot from</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a string representing the mime-type of the image format, or NULL upon error. The caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSendKey"/>virDomainSendKey ()</h3><pre class="programlisting">int	virDomainSendKey		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int codeset, <br/>					 unsigned int holdtime, <br/>					 unsigned int * keycodes, <br/>					 int nkeycodes, <br/>					 unsigned int flags)<br/>
</pre><p>Send key(s) to the guest.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>codeset</tt></i>:</span></td><td>the code set of keycodes, from <a href="libvirt-libvirt.html#virKeycodeSet">virKeycodeSet</a></td></tr><tr><td><span class="term"><i><tt>holdtime</tt></i>:</span></td><td>the duration (in milliseconds) that the keys will be held</td></tr><tr><td><span class="term"><i><tt>keycodes</tt></i>:</span></td><td>array of keycodes</td></tr><tr><td><span class="term"><i><tt>nkeycodes</tt></i>:</span></td><td>number of keycodes, up to <a href="libvirt-libvirt.html#VIR_DOMAIN_SEND_KEY_MAX_KEYS">VIR_DOMAIN_SEND_KEY_MAX_KEYS</a></td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSendProcessSignal"/>virDomainSendProcessSignal ()</h3><pre class="programlisting">int	virDomainSendProcessSignal	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 long long pid_value, <br/>					 unsigned int signum, <br/>					 unsigned int flags)<br/>
</pre><p>Send a signal to the designated process in the guest

The signal numbers must be taken from the virDomainProcessSignal
enum. These will be translated to the corresponding signal
number for the guest OS, by the guest agent delivering the
signal. If there is no mapping from <a href="libvirt-libvirt.html#virDomainProcessSignal">virDomainProcessSignal</a> to
the native OS signals, this API will report an error.

If @pid_value is an integer greater than zero, it is
treated as a process ID. If @pid_value is an integer
less than zero, it is treated as a process group ID.
All the @pid_value numbers are from the container/guest
namespace. The value zero is not valid.

Not all hypervisors will support sending signals to
arbitrary processes or process groups. If this API is
implemented the minimum requirement is to be able to
use @pid_value==1 (i.e. kill init). No other value is
required to be supported.

If the @signum is <a href="libvirt-libvirt.html#VIR_DOMAIN_PROCESS_SIGNAL_NOP">VIR_DOMAIN_PROCESS_SIGNAL_NOP</a> then this
API will simply report whether the process is running in
the container/guest.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>pid_value</tt></i>:</span></td><td>a positive integer process ID, or negative integer process group ID</td></tr><tr><td><span class="term"><i><tt>signum</tt></i>:</span></td><td>a signal from the <a href="libvirt-libvirt.html#virDomainProcessSignal">virDomainProcessSignal</a> enum</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>one of the virDomainProcessSignalFlag values</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetAutostart"/>virDomainSetAutostart ()</h3><pre class="programlisting">int	virDomainSetAutostart		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int autostart)<br/>
</pre><p>Configure the domain to be automatically started
when the host machine boots.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>whether the domain should be automatically started 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetBlkioParameters"/>virDomainSetBlkioParameters ()</h3><pre class="programlisting">int	virDomainSetBlkioParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the blkio tunables.
This function may require privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to blkio parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of blkio parameters (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetBlockIoTune"/>virDomainSetBlockIoTune ()</h3><pre class="programlisting">int	virDomainSetBlockIoTune		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the per-device block IO tunables.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the &lt;target
dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found
by calling virDomainGetXMLDesc() and inspecting elements
within //domain/devices/disk.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>Pointer to blkio parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>Number of blkio parameters (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetInterfaceParameters"/>virDomainSetInterfaceParameters ()</h3><pre class="programlisting">int	virDomainSetInterfaceParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change a subset or all parameters of interface; currently this
includes bandwidth parameters. The value of @flags should be
either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of values
VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG, although
hypervisors vary in which flags are supported.

This function may require privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>device</tt></i>:</span></td><td>the interface name or mac address</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to interface parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of interface parameter (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMaxMemory"/>virDomainSetMaxMemory ()</h3><pre class="programlisting">int	virDomainSetMaxMemory		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory)<br/>
</pre><p>Dynamically change the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

This command is hypervisor-specific for whether active, persistent,
or both configurations are changed; for more control, use
virDomainSetMemoryFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>memory</tt></i>:</span></td><td>the memory size in kibibytes (blocks of 1024 bytes)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMemory"/>virDomainSetMemory ()</h3><pre class="programlisting">int	virDomainSetMemory		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory)<br/>
</pre><p>Dynamically change the target amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>memory</tt></i>:</span></td><td>the memory size in kibibytes (blocks of 1024 bytes)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMemoryFlags"/>virDomainSetMemoryFlags ()</h3><pre class="programlisting">int	virDomainSetMemoryFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the target amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects
a running domain and will fail if domain is not active.
If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified
(that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain
modifies persistent setup, while an active domain is hypervisor-dependent
on whether just live or both live and persistent state is changed.
If <a href="libvirt-libvirt.html#VIR_DOMAIN_MEM_MAXIMUM">VIR_DOMAIN_MEM_MAXIMUM</a> is set, the change affects domain's maximum memory
size rather than current memory size.
Not all hypervisors can support all flag combinations.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>memory</tt></i>:</span></td><td>the memory size in kibibytes (blocks of 1024 bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMemoryModFlags">virDomainMemoryModFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMemoryParameters"/>virDomainSetMemoryParameters ()</h3><pre class="programlisting">int	virDomainSetMemoryParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the memory tunables.
This function may require privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to memory parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of memory parameter (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMemoryStatsPeriod"/>virDomainSetMemoryStatsPeriod ()</h3><pre class="programlisting">int	virDomainSetMemoryStatsPeriod	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int period, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the domain memory balloon driver statistics collection
period. Use 0 to disable and a positive value to enable.

@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects
a running domain and will fail if domain is not active.
If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified
(that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain
modifies persistent setup, while an active domain is hypervisor-dependent
on whether just live or both live and persistent state is changed.

Not all hypervisors can support all flag combinations.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>period</tt></i>:</span></td><td>the period in seconds for stats collection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMemoryModFlags">virDomainMemoryModFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMetadata"/>virDomainSetMetadata ()</h3><pre class="programlisting">int	virDomainSetMetadata		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int type, <br/>					 const char * metadata, <br/>					 const char * key, <br/>					 const char * uri, <br/>					 unsigned int flags)<br/>
</pre><p>Sets the appropriate domain element given by @type to the
value of @description. A @type of VIR_DOMAIN_METADATA_DESCRIPTION
is free-form text; <a href="libvirt-libvirt.html#VIR_DOMAIN_METADATA_TITLE">VIR_DOMAIN_METADATA_TITLE</a> is free-form, but no
newlines are permitted, and should be short (although the length is
not enforced). For these two options @key and @uri are irrelevant and
must be set to NULL.

For type <a href="libvirt-libvirt.html#VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a> @metadata must be well-formed
XML belonging to namespace defined by @uri with local name @key.

Passing NULL for @metadata says to remove that element from the
domain XML (passing the empty string leaves the element present).

The resulting metadata will be present in virDomainGetXMLDesc(),
as well as quick access through virDomainGetMetadata().

@flags controls whether the live domain, persistent configuration,
or both will be modified.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of description, from <a href="libvirt-libvirt.html#virDomainMetadataType">virDomainMetadataType</a></td></tr><tr><td><span class="term"><i><tt>metadata</tt></i>:</span></td><td>new metadata text</td></tr><tr><td><span class="term"><i><tt>key</tt></i>:</span></td><td>XML namespace key, or NULL</td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>XML namespace URI, or NULL</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetNumaParameters"/>virDomainSetNumaParameters ()</h3><pre class="programlisting">int	virDomainSetNumaParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the numa tunables.
This function may require privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to numa parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of numa parameters (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetSchedulerParameters"/>virDomainSetSchedulerParameters ()</h3><pre class="programlisting">int	virDomainSetSchedulerParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams)<br/>
</pre><p>Change all or a subset or the scheduler parameters. It is
hypervisor-specific whether this sets live, persistent, or both
settings; for more control, use
virDomainSetSchedulerParametersFlags.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetSchedulerParametersFlags"/>virDomainSetSchedulerParametersFlags ()</h3><pre class="programlisting">int	virDomainSetSchedulerParametersFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int nparams, <br/>						 unsigned int flags)<br/>
</pre><p>Change a subset or all scheduler parameters. The value of @flags
should be either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of
values from <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and
VIR_DOMAIN_AFFECT_CURRENT, although hypervisors vary in which
flags are supported.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetVcpus"/>virDomainSetVcpus ()</h3><pre class="programlisting">int	virDomainSetVcpus		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nvcpus)<br/>
</pre><p>Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrary limited.
This function may require privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain. It is hypervisor-dependent
whether it also affects persistent configuration; for more control,
use virDomainSetVcpusFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>nvcpus</tt></i>:</span></td><td>the new number of virtual CPUs for this domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetVcpusFlags"/>virDomainSetVcpusFlags ()</h3><pre class="programlisting">int	virDomainSetVcpusFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nvcpus, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrary limited.
This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> to affect a running
domain (which may fail if domain is not active), or
VIR_DOMAIN_AFFECT_CONFIG to affect the next boot via the XML
description of the domain. Both flags may be set.
If neither flag is specified (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT),
then an inactive domain modifies persistent setup, while an active domain
is hypervisor-dependent on whether just live or both live and persistent
state is changed.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then
VIR_DOMAIN_AFFECT_LIVE must be clear, and only the maximum virtual
CPU limit is altered; generally, this value must be less than or
equal to virConnectGetMaxVcpus(). Otherwise, this call affects the
current virtual CPU limit, which must be less than or equal to the
maximum limit.

If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of processors is
modified inside the guest instead of the hypervisor. This flag can only
be used with live guests and is incompatible with VIR_DOMAIN_VCPU_MAXIMUM.
The usage of this flag may require a guest agent configured.

Not all hypervisors can support all flag combinations.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>nvcpus</tt></i>:</span></td><td>the new number of virtual CPUs for this domain, must be at least 1</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainVcpuFlags">virDomainVcpuFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutdown"/>virDomainShutdown ()</h3><pre class="programlisting">int	virDomainShutdown		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Shutdown a domain, the domain object is still usable thereafter, but
the domain OS is being stopped. Note that the guest OS may ignore the
request. Additionally, the hypervisor may check and support the domain
'on_poweroff' XML setting resulting in a domain that reboots instead of
shutting down. For guests that react to a shutdown request, the differences
from virDomainDestroy() are that the guests disk storage will be in a
stable state rather than having the (virtual) power cord pulled, and
this command returns as soon as the shutdown request is issued rather
than blocking until the guest is no longer running.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutdownFlags"/>virDomainShutdownFlags ()</h3><pre class="programlisting">int	virDomainShutdownFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Shutdown a domain, the domain object is still usable thereafter but
the domain OS is being stopped. Note that the guest OS may ignore the
request. Additionally, the hypervisor may check and support the domain
'on_poweroff' XML setting resulting in a domain that reboots instead of
shutting down. For guests that react to a shutdown request, the differences
from virDomainDestroy() are that the guest's disk storage will be in a
stable state rather than having the (virtual) power cord pulled, and
this command returns as soon as the shutdown request is issued rather
than blocking until the guest is no longer running.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.

If @flags is set to zero, then the hypervisor will choose the
method of shutdown it considers best. To have greater control
pass one or more of the virDomainShutdownFlagValues. The order
in which the hypervisor tries each shutdown method is undefined,
and a hypervisor is not required to support all methods.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotCreateXML"/>virDomainSnapshotCreateXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	virDomainSnapshotCreateXML	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>							 const char * xmlDesc, <br/>							 unsigned int flags)<br/>
</pre><p>Creates a new snapshot of a domain based on the snapshot xml
contained in xmlDesc.

If @flags is 0, the domain can be active, in which case the
snapshot will be a system checkpoint (both disk state and runtime
VM state such as RAM contents), where reverting to the snapshot is
the same as resuming from hibernation (TCP connections may have
timed out, but everything else picks up where it left off); or
the domain can be inactive, in which case the snapshot includes
just the disk state prior to booting. The newly created snapshot
becomes current (see virDomainSnapshotCurrent()), and is a child
of any previous current snapshot.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE, then this
is a request to reinstate snapshot metadata that was previously
discarded, rather than creating a new snapshot. This can be used
to recreate a snapshot hierarchy on a destination, then remove it
on the source, in order to allow migration (since migration
normally fails if snapshot metadata still remains on the source
machine). When redefining snapshot metadata, the current snapshot
will not be altered unless the VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT
flag is also present. It is an error to request the
VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT flag without
VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE. On some hypervisors,
redefining an existing snapshot can be used to alter host-specific
portions of the domain XML to be used during revert (such as
backing filenames associated with disk devices), but must not alter
guest-visible layout. When redefining a snapshot name that does
not exist, the hypervisor may validate that reverting to the
snapshot appears to be possible (for example, disk images have
snapshot contents by the requested name). Not all hypervisors
support these flags.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA, then the
domain's disk images are modified according to @xmlDesc, but then
the just-created snapshot has its metadata deleted. This flag is
incompatible with VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_HALT, then the domain
will be inactive after the snapshot completes, regardless of whether
it was active before; otherwise, a running domain will still be
running after the snapshot. This flag is invalid on transient domains,
and is incompatible with VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_LIVE, then the domain
is not paused while creating the snapshot. This increases the size
of the memory dump file, but reduces downtime of the guest while
taking the snapshot. Some hypervisors only support this flag during
external checkpoints.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY, then the
snapshot will be limited to the disks described in @xmlDesc, and no
VM state will be saved. For an active guest, the disk image may be
inconsistent (as if power had been pulled), and specifying this
with the <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_HALT">VIR_DOMAIN_SNAPSHOT_CREATE_HALT</a> flag risks data loss.

If @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE, then the
libvirt will attempt to use guest agent to freeze and thaw all
file systems in use within domain OS. However, if the guest agent
is not present, an error is thrown. Moreover, this flag requires
VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY to be passed as well.

By default, if the snapshot involves external files, and any of the
destination files already exist as a non-empty regular file, the
snapshot is rejected to avoid losing contents of those files.
However, if @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT,
then the destination files must already exist and contain content
identical to the source files (this allows a management app to
pre-create files with relative backing file names, rather than the
default of creating with absolute backing file names).

Be aware that although libvirt prefers to report errors up front with
no other effect, some hypervisors have certain types of failures where
the overall command can easily fail even though the guest configuration
was partially altered (for example, if a disk snapshot request for two
disks fails on the second disk, but the first disk alteration cannot be
rolled back). If this API call fails, it is therefore normally
necessary to follow up with virDomainGetXMLDesc() and check each disk
to determine if any partial changes occurred. However, if @flags
contains VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC, then libvirt guarantees
that this command will not alter any disks unless the entire set of
changes can be done atomically, making failure recovery simpler (note
that it is still possible to fail after disks have changed, but only
in the much rarer cases of running out of memory or disk space).

Some hypervisors may prevent this operation if there is a current
block copy operation; in that case, use virDomainBlockJobAbort()
to stop the block copy first.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSnapshotCreateFlags">virDomainSnapshotCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>an (opaque) <a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> on success, NULL on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotCurrent"/>virDomainSnapshotCurrent ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	virDomainSnapshotCurrent	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>							 unsigned int flags)<br/>
</pre><p>Get the current snapshot for a domain, if any.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a domain snapshot object or NULL in case of failure. If the current domain snapshot cannot be found, then the <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_SNAPSHOT">VIR_ERR_NO_DOMAIN_SNAPSHOT</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotDelete"/>virDomainSnapshotDelete ()</h3><pre class="programlisting">int	virDomainSnapshotDelete		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags)<br/>
</pre><p>Delete the snapshot.

If @flags is 0, then just this snapshot is deleted, and changes
from this snapshot are automatically merged into children
snapshots. If @flags includes VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN,
then this snapshot and any descendant snapshots are deleted. If
@flags includes VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY, then any
descendant snapshots are deleted, but this snapshot remains. These
two flags are mutually exclusive.

If @flags includes VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY, then
any snapshot metadata tracked by libvirt is removed while keeping
the snapshot contents intact; if a hypervisor does not require any
libvirt metadata to track snapshots, then this flag is silently
ignored.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotDeleteFlags">virDomainSnapshotDeleteFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the selected snapshot(s) were successfully deleted, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotFree"/>virDomainSnapshotFree ()</h3><pre class="programlisting">int	virDomainSnapshotFree		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot)<br/>
</pre><p>Free the domain snapshot object. The snapshot itself is not modified.
The data structure is freed and should not be used thereafter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotGetConnect"/>virDomainSnapshotGetConnect ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virDomainSnapshotGetConnect	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot)<br/>
</pre><p>Provides the connection pointer associated with a snapshot. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do not use this
function. Instead, store the connection and the snapshot object together.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a snapshot object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the connection or NULL.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotGetDomain"/>virDomainSnapshotGetDomain ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainSnapshotGetDomain	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot)<br/>
</pre><p>Provides the domain pointer associated with a snapshot. The
reference counter on the domain is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do not use this
function. Instead, store the domain and the snapshot object together.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a snapshot object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the domain or NULL.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotGetName"/>virDomainSnapshotGetName ()</h3><pre class="programlisting">const char *	virDomainSnapshotGetName	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot)<br/>
</pre><p>Get the public name for that snapshot</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a snapshot object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated as its lifetime will be the same as the snapshot object.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotGetParent"/>virDomainSnapshotGetParent ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	virDomainSnapshotGetParent	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>							 unsigned int flags)<br/>
</pre><p>Get the parent snapshot for @snapshot, if any.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a domain snapshot object or NULL in case of failure. If the given snapshot is a root (no parent), then the <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_SNAPSHOT">VIR_ERR_NO_DOMAIN_SNAPSHOT</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotGetXMLDesc"/>virDomainSnapshotGetXMLDesc ()</h3><pre class="programlisting">char *	virDomainSnapshotGetXMLDesc	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags)<br/>
</pre><p>Provide an XML description of the domain snapshot.

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only
connections. For this API, @flags should not contain either
VIR_DOMAIN_XML_INACTIVE or VIR_DOMAIN_XML_UPDATE_CPU.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of subset of <a href="libvirt-libvirt.html#virDomainXMLFlags">virDomainXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotHasMetadata"/>virDomainSnapshotHasMetadata ()</h3><pre class="programlisting">int	virDomainSnapshotHasMetadata	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags)<br/>
</pre><p>Determine if the given snapshot is associated with libvirt metadata
that would prevent the deletion of the domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if the snapshot has metadata, 0 if the snapshot exists without help from libvirt, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotIsCurrent"/>virDomainSnapshotIsCurrent ()</h3><pre class="programlisting">int	virDomainSnapshotIsCurrent	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags)<br/>
</pre><p>Determine if the given snapshot is the domain's current snapshot. See
also virDomainHasCurrentSnapshot().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if current, 0 if not current, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotListAllChildren"/>virDomainSnapshotListAllChildren ()</h3><pre class="programlisting">int	virDomainSnapshotListAllChildren	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>						 <a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> ** snaps, <br/>						 unsigned int flags)<br/>
</pre><p>Collect the list of domain snapshots that are children of the given
snapshot, and allocate an array to store those objects. This API solves
the race inherent in virDomainSnapshotListChildrenNames().

By default, this command covers only direct children; it is also possible
to expand things to cover all descendants, when @flags includes
VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS. Also, some filters are provided in
groups, where each group contains bits that describe mutually exclusive
attributes of a snapshot, and where all bits within a group describe
all possible snapshots. Some hypervisors might reject explicit bits
from a group where the hypervisor cannot make a distinction. For a
group supported by a given hypervisor, the behavior when no bits of a
group are set is identical to the behavior when all bits in that group
are set. When setting bits from more than one group, it is possible to
select an impossible combination, in that case a hypervisor may return
either 0 or an error.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that
have no further children (a leaf snapshot).

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on
whether they have metadata that would prevent the removal of the last
reference to a domain.

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,
VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,
for filtering snapshots based on what domain state is tracked by the
snapshot.

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and
VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on
whether the snapshot is stored inside the disk images or as
additional files.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>snaps</tt></i>:</span></td><td>pointer to variable to store the array containing snapshot objects, or NULL if the list is not required (just returns number of snapshots)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain snapshots found or -1 and sets @snaps to NULL in case of error. On success, the array stored into @snaps is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virDomainSnapshotFree() on each array element, then calling free() on @snaps.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotListChildrenNames"/>virDomainSnapshotListChildrenNames ()</h3><pre class="programlisting">int	virDomainSnapshotListChildrenNames	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>						 char ** names, <br/>						 int nameslen, <br/>						 unsigned int flags)<br/>
</pre><p>Collect the list of domain snapshots that are children of the given
snapshot, and store their names in @names. The value to use for
@nameslen can be determined by virDomainSnapshotNumChildren() with
the same @flags.

By default, this command covers only direct children; it is also possible
to expand things to cover all descendants, when @flags includes
VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS. Also, some filters are provided in
groups, where each group contains bits that describe mutually exclusive
attributes of a snapshot, and where all bits within a group describe
all possible snapshots. Some hypervisors might reject explicit bits
from a group where the hypervisor cannot make a distinction. For a
group supported by a given hypervisor, the behavior when no bits of a
group are set is identical to the behavior when all bits in that group
are set. When setting bits from more than one group, it is possible to
select an impossible combination, in that case a hypervisor may return
either 0 or an error.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that
have no further children (a leaf snapshot).

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on
whether they have metadata that would prevent the removal of the last
reference to a domain.

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,
VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,
for filtering snapshots based on what domain state is tracked by the
snapshot.

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and
VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on
whether the snapshot is stored inside the disk images or as
additional files.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of snapshots</td></tr><tr><td><span class="term"><i><tt>nameslen</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain snapshots found or -1 in case of error. Note that this command is inherently racy: another connection can define a new snapshot between a call to virDomainSnapshotNumChildren() and this call. You are only guaranteed that all currently defined snapshots were listed if the return is less than @nameslen. Likewise, you should be prepared for virDomainSnapshotLookupByName() to fail when converting a name from this call into a snapshot object, if another connection deletes the snapshot in the meantime. For more control over the results, see virDomainSnapshotListAllChildren(). Returns the number of domain snapshots found or -1 in case of error. The caller is responsible to call free() for each member of the array.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotListNames"/>virDomainSnapshotListNames ()</h3><pre class="programlisting">int	virDomainSnapshotListNames	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 char ** names, <br/>					 int nameslen, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of domain snapshots for the given domain, and store
their names in @names. The value to use for @nameslen can be determined
by virDomainSnapshotNum() with the same @flags.

By default, this command covers all snapshots; it is also possible to
limit things to just snapshots with no parents, when @flags includes
VIR_DOMAIN_SNAPSHOT_LIST_ROOTS. Additional filters are provided in
groups, where each group contains bits that describe mutually exclusive
attributes of a snapshot, and where all bits within a group describe
all possible snapshots. Some hypervisors might reject explicit bits
from a group where the hypervisor cannot make a distinction. For a
group supported by a given hypervisor, the behavior when no bits of a
group are set is identical to the behavior when all bits in that group
are set. When setting bits from more than one group, it is possible to
select an impossible combination, in that case a hypervisor may return
either 0 or an error.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that
have no further children (a leaf snapshot).

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on
whether they have metadata that would prevent the removal of the last
reference to a domain.

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,
VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,
for filtering snapshots based on what domain state is tracked by the
snapshot.

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and
VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on
whether the snapshot is stored inside the disk images or as
additional files.

Note that this command is inherently racy: another connection can
define a new snapshot between a call to virDomainSnapshotNum() and
this call. You are only guaranteed that all currently defined
snapshots were listed if the return is less than @nameslen. Likewise,
you should be prepared for virDomainSnapshotLookupByName() to fail when
converting a name from this call into a snapshot object, if another
connection deletes the snapshot in the meantime. For more control over
the results, see virDomainListAllSnapshots().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of snapshots</td></tr><tr><td><span class="term"><i><tt>nameslen</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain snapshots found or -1 in case of error. The caller is responsible to call free() for each member of the array.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotLookupByName"/>virDomainSnapshotLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	virDomainSnapshotLookupByName	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>							 const char * name, <br/>							 unsigned int flags)<br/>
</pre><p>Try to lookup a domain snapshot based on its name.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the domain snapshot</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a domain snapshot object or NULL in case of failure. If the domain snapshot cannot be found, then the <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_SNAPSHOT">VIR_ERR_NO_DOMAIN_SNAPSHOT</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotNum"/>virDomainSnapshotNum ()</h3><pre class="programlisting">int	virDomainSnapshotNum		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Provides the number of domain snapshots for this domain.

By default, this command covers all snapshots; it is also possible to
limit things to just snapshots with no parents, when @flags includes
VIR_DOMAIN_SNAPSHOT_LIST_ROOTS. Additional filters are provided in
groups, where each group contains bits that describe mutually exclusive
attributes of a snapshot, and where all bits within a group describe
all possible snapshots. Some hypervisors might reject explicit bits
from a group where the hypervisor cannot make a distinction. For a
group supported by a given hypervisor, the behavior when no bits of a
group are set is identical to the behavior when all bits in that group
are set. When setting bits from more than one group, it is possible to
select an impossible combination, in that case a hypervisor may return
either 0 or an error.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that
have no further children (a leaf snapshot).

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on
whether they have metadata that would prevent the removal of the last
reference to a domain.

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,
VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,
for filtering snapshots based on what domain state is tracked by the
snapshot.

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and
VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on
whether the snapshot is stored inside the disk images or as
additional files.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain snapshots found or -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotNumChildren"/>virDomainSnapshotNumChildren ()</h3><pre class="programlisting">int	virDomainSnapshotNumChildren	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br/>					 unsigned int flags)<br/>
</pre><p>Provides the number of child snapshots for this domain snapshot.

By default, this command covers only direct children; it is also possible
to expand things to cover all descendants, when @flags includes
VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS. Also, some filters are provided in
groups, where each group contains bits that describe mutually exclusive
attributes of a snapshot, and where all bits within a group describe
all possible snapshots. Some hypervisors might reject explicit bits
from a group where the hypervisor cannot make a distinction. For a
group supported by a given hypervisor, the behavior when no bits of a
group are set is identical to the behavior when all bits in that group
are set. When setting bits from more than one group, it is possible to
select an impossible combination, in that case a hypervisor may return
either 0 or an error.

The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that
have no further children (a leaf snapshot).

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and
VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on
whether they have metadata that would prevent the removal of the last
reference to a domain.

The next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,
VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,
for filtering snapshots based on what domain state is tracked by the
snapshot.

The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and
VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on
whether the snapshot is stored inside the disk images or as
additional files.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain snapshots found or -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSnapshotRef"/>virDomainSnapshotRef ()</h3><pre class="programlisting">int	virDomainSnapshotRef		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot)<br/>
</pre><p>Increment the reference count on the snapshot. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virDomainSnapshotFree">virDomainSnapshotFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection and domain remain open until all threads have finished
using the snapshot. ie, each new thread using a snapshot would
increment the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>the snapshot to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSuspend"/>virDomainSuspend ()</h3><pre class="programlisting">int	virDomainSuspend		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Suspends an active domain, the process is frozen without further access
to CPU resources and I/O but the memory used by the domain at the
hypervisor level will stay allocated. Use virDomainResume() to reactivate
the domain.
This function may require privileged access.
Moreover, suspend may not be supported if domain is in some
special state like VIR_DOMAIN_PMSUSPENDED.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainUndefine"/>virDomainUndefine ()</h3><pre class="programlisting">int	virDomainUndefine		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Undefine a domain. If the domain is running, it's converted to
transient domain, without stopping it. If the domain is inactive,
the domain configuration is removed.

If the domain has a managed save image (see
virDomainHasManagedSaveImage()), or if it is inactive and has any
snapshot metadata (see virDomainSnapshotNum()), then the undefine will
fail. See virDomainUndefineFlags() for more control.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainUndefineFlags"/>virDomainUndefineFlags ()</h3><pre class="programlisting">int	virDomainUndefineFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Undefine a domain. If the domain is running, it's converted to
transient domain, without stopping it. If the domain is inactive,
the domain configuration is removed.

If the domain has a managed save image (see virDomainHasManagedSaveImage()),
then including <a href="libvirt-libvirt.html#VIR_DOMAIN_UNDEFINE_MANAGED_SAVE">VIR_DOMAIN_UNDEFINE_MANAGED_SAVE</a> in @flags will also remove
that file, and omitting the flag will cause the undefine process to fail.

If the domain is inactive and has any snapshot metadata (see
virDomainSnapshotNum()), then including
VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA in @flags will also remove
that metadata. Omitting the flag will cause the undefine of an
inactive domain to fail. Active snapshots will retain snapshot
metadata until the (now-transient) domain halts, regardless of
whether this flag is present. On hypervisors where snapshots do
not use libvirt metadata, this flag has no effect.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainUndefineFlagsValues">virDomainUndefineFlagsValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainUpdateDeviceFlags"/>virDomainUpdateDeviceFlags ()</h3><pre class="programlisting">int	virDomainUpdateDeviceFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Change a virtual device on a domain, using the flags parameter
to control how the device is changed. VIR_DOMAIN_AFFECT_CURRENT
specifies that the device change is made based on current domain
state. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be
changed on the active domain instance only and is not added to the
persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be changed on the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

This method is used for actions such changing CDROM/Floppy device
media, altering the graphics configuration such as password,
reconfiguring the NIC device backend connectivity, etc.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventAddHandle"/>virEventAddHandle ()</h3><pre class="programlisting">int	virEventAddHandle		(int fd, <br/>					 int events, <br/>					 <a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)<br/>
</pre><p>Register a callback for monitoring file handle events.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>file handle to monitor for events</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>bitset of events to watch from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to invoke when an event occurs</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data to pass to callback</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>callback to free opaque when handle is removed</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 if the file handle cannot be registered, otherwise a handle watch number to be used for updating and unregistering for events</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventAddTimeout"/>virEventAddTimeout ()</h3><pre class="programlisting">int	virEventAddTimeout		(int timeout, <br/>					 <a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)<br/>
</pre><p>Register a callback for a timer event.

Setting timeout to -1 will disable the timer. Setting the timeout
to zero will cause it to fire on every event loop iteration.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>timeout</tt></i>:</span></td><td>time between events in milliseconds</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to invoke when an event occurs</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data to pass to callback</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>callback to free opaque when timeout is removed</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 if the timer cannot be registered, a positive integer timer id upon success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventRegisterDefaultImpl"/>virEventRegisterDefaultImpl ()</h3><pre class="programlisting">int	virEventRegisterDefaultImpl	(void)<br/>
</pre><p>Registers a default event implementation based on the
poll() system call. This is a generic implementation
that can be used by any client application which does
not have a need to integrate with an external event
loop impl.

Once registered, the application has to invoke <a href="libvirt-libvirt.html#virEventRunDefaultImpl">virEventRunDefaultImpl</a> in
a loop to process events. Failure to do so may result in connections being
closed unexpectedly as a result of keepalive timeout.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventRegisterImpl"/>virEventRegisterImpl ()</h3><pre class="programlisting">void	virEventRegisterImpl		(<a href="libvirt-libvirt.html#virEventAddHandleFunc">virEventAddHandleFunc</a> addHandle, <br/>					 <a href="libvirt-libvirt.html#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a> updateHandle, <br/>					 <a href="libvirt-libvirt.html#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a> removeHandle, <br/>					 <a href="libvirt-libvirt.html#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a> addTimeout, <br/>					 <a href="libvirt-libvirt.html#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a> updateTimeout, <br/>					 <a href="libvirt-libvirt.html#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a> removeTimeout)<br/>
</pre><p>Registers an event implementation, to allow integration
with an external event loop. Applications would use this
to integrate with the libglib2 event loop, or libevent
or the QT event loop.

If an application does not need to integrate with an
existing event loop implementation, then the
virEventRegisterDefaultImpl method can be used to setup
the generic libvirt implementation.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>addHandle</tt></i>:</span></td><td>the callback to add fd handles</td></tr><tr><td><span class="term"><i><tt>updateHandle</tt></i>:</span></td><td>the callback to update fd handles</td></tr><tr><td><span class="term"><i><tt>removeHandle</tt></i>:</span></td><td>the callback to remove fd handles</td></tr><tr><td><span class="term"><i><tt>addTimeout</tt></i>:</span></td><td>the callback to add a timeout</td></tr><tr><td><span class="term"><i><tt>updateTimeout</tt></i>:</span></td><td>the callback to update a timeout</td></tr><tr><td><span class="term"><i><tt>removeTimeout</tt></i>:</span></td><td>the callback to remove a timeout</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventRemoveHandle"/>virEventRemoveHandle ()</h3><pre class="programlisting">int	virEventRemoveHandle		(int watch)<br/>
</pre><p>Unregister a callback from a file handle.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>watch</tt></i>:</span></td><td>watch whose file handle to remove</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 if the file handle was not registered, 0 upon success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventRemoveTimeout"/>virEventRemoveTimeout ()</h3><pre class="programlisting">int	virEventRemoveTimeout		(int timer)<br/>
</pre><p>Unregister a callback for a timer.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>timer</tt></i>:</span></td><td>the timer id to remove</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 if the timer was not registered, 0 upon success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventRunDefaultImpl"/>virEventRunDefaultImpl ()</h3><pre class="programlisting">int	virEventRunDefaultImpl		(void)<br/>
</pre><p>Run one iteration of the event loop. Applications
will generally want to have a thread which invokes
this method in an infinite loop

 static bool quit = false;

 while (!quit) {
 if (virEventRunDefaultImpl() &lt; 0)
 ...print error...
 }</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventUpdateHandle"/>virEventUpdateHandle ()</h3><pre class="programlisting">void	virEventUpdateHandle		(int watch, <br/>					 int events)<br/>
</pre><p>Change event set for a monitored file handle.

Will not fail if fd exists</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>watch</tt></i>:</span></td><td>watch whose file handle to update</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>bitset of events to watch from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virEventUpdateTimeout"/>virEventUpdateTimeout ()</h3><pre class="programlisting">void	virEventUpdateTimeout		(int timer, <br/>					 int timeout)<br/>
</pre><p>Change frequency for a timer.

Setting frequency to -1 will disable the timer. Setting the frequency
to zero will cause it to fire on every event loop iteration.

Will not fail if timer exists</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>timer</tt></i>:</span></td><td>timer id to change</td></tr><tr><td><span class="term"><i><tt>timeout</tt></i>:</span></td><td>time between events in milliseconds</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virGetVersion"/>virGetVersion ()</h3><pre class="programlisting">int	virGetVersion			(unsigned long * libVer, <br/>					 const char * type, <br/>					 unsigned long * typeVer)<br/>
</pre><p>Provides version information. @libVer is the version of the
library and will always be set unless an error occurs, in which case
an error code will be returned. @typeVer exists for historical
compatibility; if it is not NULL it will duplicate @libVer (it was
originally intended to return hypervisor information based on @type,
but due to the design of remote clients this is not reliable). To
get the version of the running hypervisor use the virConnectGetVersion
function instead. To get the libvirt library version used by a
connection use the <a href="libvirt-libvirt.html#virConnectGetLibVersion">virConnectGetLibVersion</a> instead.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>libVer</tt></i>:</span></td><td>return value for the library version (OUT)</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>ignored; pass NULL</td></tr><tr><td><span class="term"><i><tt>typeVer</tt></i>:</span></td><td>pass NULL; for historical purposes duplicates @libVer if non-NULL</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInitialize"/>virInitialize ()</h3><pre class="programlisting">int	virInitialize			(void)<br/>
</pre><p>Initialize the library.

This method is invoked automatically by any of the <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> API
calls. Since release 1.0.0, there is no need to call this method even
in a multithreaded application, since initialization is performed in
a thread safe manner.

The only time it would be necessary to call <a href="libvirt-libvirt.html#virInitialize">virInitialize</a> is if the
application did not invoke <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> as its first API call.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceChangeBegin"/>virInterfaceChangeBegin ()</h3><pre class="programlisting">int	virInterfaceChangeBegin		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags)<br/>
</pre><p>This function creates a restore point to which one can return
later by calling virInterfaceChangeRollback(). This function should
be called before any transaction with interface configuration.
Once it is known that a new configuration works, it can be committed via
virInterfaceChangeCommit(), which frees the restore point.

If virInterfaceChangeBegin() is called when a transaction is
already opened, this function will fail, and a
VIR_ERR_INVALID_OPERATION will be logged.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceChangeCommit"/>virInterfaceChangeCommit ()</h3><pre class="programlisting">int	virInterfaceChangeCommit	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags)<br/>
</pre><p>This commits the changes made to interfaces and frees the restore point
created by virInterfaceChangeBegin().

If virInterfaceChangeCommit() is called when a transaction is not
opened, this function will fail, and a VIR_ERR_INVALID_OPERATION
will be logged.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceChangeRollback"/>virInterfaceChangeRollback ()</h3><pre class="programlisting">int	virInterfaceChangeRollback	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags)<br/>
</pre><p>This cancels changes made to interfaces settings by restoring previous
state created by virInterfaceChangeBegin().

If virInterfaceChangeRollback() is called when a transaction is not
opened, this function will fail, and a VIR_ERR_INVALID_OPERATION
will be logged.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceCreate"/>virInterfaceCreate ()</h3><pre class="programlisting">int	virInterfaceCreate		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br/>					 unsigned int flags)<br/>
</pre><p>Activate an interface (i.e. call "ifup").

If there was an open network config transaction at the time this
interface was defined (that is, if virInterfaceChangeBegin() had
been called), the interface will be brought back down (and then
undefined) if virInterfaceChangeRollback() is called.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>pointer to a defined interface</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceDefineXML"/>virInterfaceDefineXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	virInterfaceDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Define an interface (or modify existing interface configuration).

Normally this change in the interface configuration is immediately
permanent/persistent, but if virInterfaceChangeBegin() has been
previously called (i.e. if an interface config transaction is
open), the new interface definition will only become permanent if
virInterfaceChangeCommit() is called prior to the next reboot of
the system running libvirtd. Prior to that time, it can be
explicitly removed using virInterfaceChangeRollback(), or will be
automatically removed during the next reboot of the system running
libvirtd.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the interface, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a pointer to the interface otherwise</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceDestroy"/>virInterfaceDestroy ()</h3><pre class="programlisting">int	virInterfaceDestroy		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br/>					 unsigned int flags)<br/>
</pre><p>deactivate an interface (ie call "ifdown")
This does not remove the interface from the config, and
does not free the associated <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> object.

If there is an open network config transaction at the time this
interface is destroyed (that is, if virInterfaceChangeBegin() had
been called), and if the interface is later undefined and then
virInterfaceChangeRollback() is called, the restoral of the
interface definition will also bring the interface back up.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceFree"/>virInterfaceFree ()</h3><pre class="programlisting">int	virInterfaceFree		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br/>
</pre><p>Free the interface object. The interface itself is unaltered.
The data structure is freed and should not be used thereafter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceGetConnect"/>virInterfaceGetConnect ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virInterfaceGetConnect	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br/>
</pre><p>Provides the connection pointer associated with an interface. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the interface object together.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>pointer to an interface</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceGetMACString"/>virInterfaceGetMACString ()</h3><pre class="programlisting">const char *	virInterfaceGetMACString	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br/>
</pre><p>Get the MAC for an interface as string. For more information about
MAC see RFC4122.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the MAC address (in null-terminated ASCII format) or NULL, the string need not be deallocated its lifetime will be the same as the interface object.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceGetName"/>virInterfaceGetName ()</h3><pre class="programlisting">const char *	virInterfaceGetName	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br/>
</pre><p>Get the public name for that interface</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the interface object.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceGetXMLDesc"/>virInterfaceGetXMLDesc ()</h3><pre class="programlisting">char *	virInterfaceGetXMLDesc		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br/>					 unsigned int flags)<br/>
</pre><p><a href="libvirt-libvirt.html#VIR_INTERFACE_XML_INACTIVE">VIR_INTERFACE_XML_INACTIVE</a> - return the static configuration,
 suitable for use redefining the
 interface via virInterfaceDefineXML()

Provide an XML description of the interface. If
VIR_INTERFACE_XML_INACTIVE is set, the description may be reused
later to redefine the interface with virInterfaceDefineXML(). If it
is not set, the ip address and netmask will be the current live
setting of the interface, not the settings from the config files.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of extraction flags. Current valid bits:</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceIsActive"/>virInterfaceIsActive ()</h3><pre class="programlisting">int	virInterfaceIsActive		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br/>
</pre><p>Determine if the interface is currently running</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>pointer to the interface object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceLookupByMACString"/>virInterfaceLookupByMACString ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	virInterfaceLookupByMACString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * macstr)<br/>
</pre><p>Try to lookup an interface on the given hypervisor based on its MAC.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>macstr</tt></i>:</span></td><td>the MAC for the interface (null-terminated ASCII format)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new interface object or NULL in case of failure. If the interface cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_INTERFACE">VIR_ERR_NO_INTERFACE</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceLookupByName"/>virInterfaceLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	virInterfaceLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * name)<br/>
</pre><p>Try to lookup an interface on the given hypervisor based on its name.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the interface</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new interface object or NULL in case of failure. If the interface cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_INTERFACE">VIR_ERR_NO_INTERFACE</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceRef"/>virInterfaceRef ()</h3><pre class="programlisting">int	virInterfaceRef			(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br/>
</pre><p>Increment the reference count on the interface. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virInterfaceFree">virInterfaceFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an interface would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>the interface to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virInterfaceUndefine"/>virInterfaceUndefine ()</h3><pre class="programlisting">int	virInterfaceUndefine		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br/>
</pre><p>Undefine an interface, ie remove it from the config.
This does not free the associated <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> object.

Normally this change in the interface configuration is
permanent/persistent, but if virInterfaceChangeBegin() has been
previously called (i.e. if an interface config transaction is
open), the removal of the interface definition will only become
permanent if virInterfaceChangeCommit() is called prior to the next
reboot of the system running libvirtd. Prior to that time, the
definition can be explicitly restored using
virInterfaceChangeRollback(), or will be automatically restored
during the next reboot of the system running libvirtd.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>pointer to a defined interface</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterDefineXML"/>virNWFilterDefineXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	virNWFilterDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc)<br/>
</pre><p>Define a new network filter, based on an XML description
similar to the one returned by virNWFilterGetXMLDesc()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>an XML description of the nwfilter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new nwfilter object or NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterFree"/>virNWFilterFree ()</h3><pre class="programlisting">int	virNWFilterFree			(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)<br/>
</pre><p>Free the nwfilter object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterGetName"/>virNWFilterGetName ()</h3><pre class="programlisting">const char *	virNWFilterGetName	(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)<br/>
</pre><p>Get the public name for the network filter</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the nwfilter object.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterGetUUID"/>virNWFilterGetUUID ()</h3><pre class="programlisting">int	virNWFilterGetUUID		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br/>					 unsigned char * uuid)<br/>
</pre><p>Get the UUID for a network filter</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterGetUUIDString"/>virNWFilterGetUUIDString ()</h3><pre class="programlisting">int	virNWFilterGetUUIDString	(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br/>					 char * buf)<br/>
</pre><p>Get the UUID for a network filter as string. For more information about
UUID see RFC4122.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterGetXMLDesc"/>virNWFilterGetXMLDesc ()</h3><pre class="programlisting">char *	virNWFilterGetXMLDesc		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br/>					 unsigned int flags)<br/>
</pre><p>Provide an XML description of the network filter. The description may be
reused later to redefine the network filter with virNWFilterCreateXML().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterLookupByName"/>virNWFilterLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	virNWFilterLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * name)<br/>
</pre><p>Try to lookup a network filter on the given hypervisor based on its name.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the network filter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new nwfilter object or NULL in case of failure. If the network filter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterLookupByUUID"/>virNWFilterLookupByUUID ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	virNWFilterLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid)<br/>
</pre><p>Try to lookup a network filter on the given hypervisor based on its UUID.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the network filter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new nwfilter object or NULL in case of failure. If the nwfdilter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterLookupByUUIDString"/>virNWFilterLookupByUUIDString ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	virNWFilterLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr)<br/>
</pre><p>Try to lookup an nwfilter on the given hypervisor based on its UUID.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the nwfilter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new nwfilter object or NULL in case of failure. If the nwfilter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterRef"/>virNWFilterRef ()</h3><pre class="programlisting">int	virNWFilterRef			(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)<br/>
</pre><p>Increment the reference count on the nwfilter. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virNWFilterFree">virNWFilterFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an nwfilter would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>the nwfilter to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNWFilterUndefine"/>virNWFilterUndefine ()</h3><pre class="programlisting">int	virNWFilterUndefine		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)<br/>
</pre><p>Undefine the nwfilter object. This call will not succeed if
a running VM is referencing the filter. This does not free the
associated <a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> object.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkCreate"/>virNetworkCreate ()</h3><pre class="programlisting">int	virNetworkCreate		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br/>
</pre><p>Create and start a defined network. If the call succeed the network
moves from the defined to the running networks pools.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>pointer to a defined network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkCreateXML"/>virNetworkCreateXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkCreateXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc)<br/>
</pre><p>Create and start a new virtual network, based on an XML description
similar to the one returned by virNetworkGetXMLDesc()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>an XML description of the network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new network object or NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkDefineXML"/>virNetworkDefineXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml)<br/>
</pre><p>Define a network, but does not create it</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the network, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a pointer to the network otherwise</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkDestroy"/>virNetworkDestroy ()</h3><pre class="programlisting">int	virNetworkDestroy		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br/>
</pre><p>Destroy the network object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated <a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> object.
This function may require privileged access</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkFree"/>virNetworkFree ()</h3><pre class="programlisting">int	virNetworkFree			(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br/>
</pre><p>Free the network object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkGetAutostart"/>virNetworkGetAutostart ()</h3><pre class="programlisting">int	virNetworkGetAutostart		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 int * autostart)<br/>
</pre><p>Provides a boolean value indicating whether the network
configured to be automatically started when the host
machine boots.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>the value returned</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkGetBridgeName"/>virNetworkGetBridgeName ()</h3><pre class="programlisting">char *	virNetworkGetBridgeName		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br/>
</pre><p>Provides a bridge interface name to which a domain may connect
a network interface in order to join the network.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated interface name, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkGetConnect"/>virNetworkGetConnect ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virNetworkGetConnect	(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)<br/>
</pre><p>Provides the connection pointer associated with a network. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the network object together.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>net</tt></i>:</span></td><td>pointer to a network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkGetName"/>virNetworkGetName ()</h3><pre class="programlisting">const char *	virNetworkGetName	(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br/>
</pre><p>Get the public name for that network</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the network object.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkGetUUID"/>virNetworkGetUUID ()</h3><pre class="programlisting">int	virNetworkGetUUID		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 unsigned char * uuid)<br/>
</pre><p>Get the UUID for a network</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkGetUUIDString"/>virNetworkGetUUIDString ()</h3><pre class="programlisting">int	virNetworkGetUUIDString		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 char * buf)<br/>
</pre><p>Get the UUID for a network as string. For more information about
UUID see RFC4122.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkGetXMLDesc"/>virNetworkGetXMLDesc ()</h3><pre class="programlisting">char *	virNetworkGetXMLDesc		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 unsigned int flags)<br/>
</pre><p>Provide an XML description of the network. The description may be reused
later to relaunch the network with virNetworkCreateXML().

Normally, if a network included a physical function, the output includes
all virtual functions tied to that physical interface. If @flags includes
VIR_NETWORK_XML_INACTIVE, then the expansion of virtual interfaces is
not performed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virNetworkXMLFlags">virNetworkXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkIsActive"/>virNetworkIsActive ()</h3><pre class="programlisting">int	virNetworkIsActive		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)<br/>
</pre><p>Determine if the network is currently running</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>net</tt></i>:</span></td><td>pointer to the network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkIsPersistent"/>virNetworkIsPersistent ()</h3><pre class="programlisting">int	virNetworkIsPersistent		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)<br/>
</pre><p>Determine if the network has a persistent configuration
which means it will still exist after shutting down</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>net</tt></i>:</span></td><td>pointer to the network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if persistent, 0 if transient, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkLookupByName"/>virNetworkLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * name)<br/>
</pre><p>Try to lookup a network on the given hypervisor based on its name.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkLookupByUUID"/>virNetworkLookupByUUID ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid)<br/>
</pre><p>Try to lookup a network on the given hypervisor based on its UUID.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkLookupByUUIDString"/>virNetworkLookupByUUIDString ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr)<br/>
</pre><p>Try to lookup a network on the given hypervisor based on its UUID.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkRef"/>virNetworkRef ()</h3><pre class="programlisting">int	virNetworkRef			(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br/>
</pre><p>Increment the reference count on the network. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virNetworkFree">virNetworkFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a network would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>the network to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkSetAutostart"/>virNetworkSetAutostart ()</h3><pre class="programlisting">int	virNetworkSetAutostart		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 int autostart)<br/>
</pre><p>Configure the network to be automatically started
when the host machine boots.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>whether the network should be automatically started 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkUndefine"/>virNetworkUndefine ()</h3><pre class="programlisting">int	virNetworkUndefine		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br/>
</pre><p>Undefine a network but does not stop it if it is running</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>pointer to a defined network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNetworkUpdate"/>virNetworkUpdate ()</h3><pre class="programlisting">int	virNetworkUpdate		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br/>					 unsigned int command, <br/>					 unsigned int section, <br/>					 int parentIndex, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Update the definition of an existing network, either its live
running state, its persistent configuration, or both.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>pointer to a defined network</td></tr><tr><td><span class="term"><i><tt>command</tt></i>:</span></td><td>what action to perform (add/delete/modify) (see <a href="libvirt-libvirt.html#virNetworkUpdateCommand">virNetworkUpdateCommand</a> for descriptions)</td></tr><tr><td><span class="term"><i><tt>section</tt></i>:</span></td><td>which section of the network to update (see <a href="libvirt-libvirt.html#virNetworkUpdateSection">virNetworkUpdateSection</a> for descriptions)</td></tr><tr><td><span class="term"><i><tt>parentIndex</tt></i>:</span></td><td>which parent element, if there are multiple parents of the same type (e.g. which &lt;ip&gt; element when modifying a &lt;dhcp&gt;/&lt;host&gt; element), or "-1" for "don't care" or "automatically find appropriate one".</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the network, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise OR of virNetworkUpdateFlags.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error <a href="libvirt-libvirt.html#virNetworkUpdateCommand">virNetworkUpdateCommand</a> <a href="libvirt-libvirt.html#virNetworkUpdateSection">virNetworkUpdateSection</a></td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceCreateXML"/>virNodeDeviceCreateXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	virNodeDeviceCreateXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int flags)<br/>
</pre><p>Create a new device on the VM host machine, for example, virtual
HBAs created using vport_create.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the device to be created</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a node device object if successful, NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceDestroy"/>virNodeDeviceDestroy ()</h3><pre class="programlisting">int	virNodeDeviceDestroy		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Destroy the device object. The virtual device is removed from the host operating system.
This function may require privileged access</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>a device object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceDetachFlags"/>virNodeDeviceDetachFlags ()</h3><pre class="programlisting">int	virNodeDeviceDetachFlags	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 const char * driverName, <br/>					 unsigned int flags)<br/>
</pre><p>Detach the node device from the node itself so that it may be
assigned to a guest domain.

Depending on the hypervisor, this may involve operations such as
unbinding any device drivers from the device, binding the device to
a dummy device driver and resetting the device. Different backend
drivers expect the device to be bound to different dummy
devices. For example, QEMU's "kvm" backend driver (the default)
expects the device to be bound to "pci-stub", but its "vfio"
backend driver expects the device to be bound to "vfio-pci".

If the device is currently in use by the node, this method may
fail.

Once the device is not assigned to any guest, it may be re-attached
to the node using the virNodeDeviceReAttach() method.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>driverName</tt></i>:</span></td><td>name of backend driver that will be used for later device assignment to a domain. NULL means "use the hypervisor default driver"</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceDettach"/>virNodeDeviceDettach ()</h3><pre class="programlisting">int	virNodeDeviceDettach		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Dettach the node device from the node itself so that it may be
assigned to a guest domain.

Depending on the hypervisor, this may involve operations such
as unbinding any device drivers from the device, binding the
device to a dummy device driver and resetting the device.

If the device is currently in use by the node, this method may
fail.

Once the device is not assigned to any guest, it may be re-attached
to the node using the virNodeDeviceReattach() method.

If the caller needs control over which backend driver will be used
during PCI device assignment (to use something other than the
default, for example VFIO), the newer virNodeDeviceDetachFlags()
API should be used instead.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceFree"/>virNodeDeviceFree ()</h3><pre class="programlisting">int	virNodeDeviceFree		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Drops a reference to the node device, freeing it if
this was the last reference.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the 0 for success, -1 for error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceGetName"/>virNodeDeviceGetName ()</h3><pre class="programlisting">const char *	virNodeDeviceGetName	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Just return the device name</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the device name or NULL in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceGetParent"/>virNodeDeviceGetParent ()</h3><pre class="programlisting">const char *	virNodeDeviceGetParent	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Accessor for the parent of the device</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the name of the device's parent, or NULL if the device has no parent.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceGetXMLDesc"/>virNodeDeviceGetXMLDesc ()</h3><pre class="programlisting">char *	virNodeDeviceGetXMLDesc		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 unsigned int flags)<br/>
</pre><p>Fetch an XML document describing all aspects of
the device.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML document, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceListCaps"/>virNodeDeviceListCaps ()</h3><pre class="programlisting">int	virNodeDeviceListCaps		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>Lists the names of the capabilities supported by the device.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of capability names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of capability names listed in @names.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceLookupByName"/>virNodeDeviceLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	virNodeDeviceLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * name)<br/>
</pre><p>Lookup a node device by its name.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>unique device name</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> if found, NULL otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceLookupSCSIHostByWWN"/>virNodeDeviceLookupSCSIHostByWWN ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	virNodeDeviceLookupSCSIHostByWWN	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * wwnn, <br/>							 const char * wwpn, <br/>							 unsigned int flags)<br/>
</pre><p>Lookup SCSI Host which is capable with 'fc_host' by its WWNN and WWPN.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>wwnn</tt></i>:</span></td><td>WWNN of the SCSI Host.</td></tr><tr><td><span class="term"><i><tt>wwpn</tt></i>:</span></td><td>WWPN of the SCSI Host.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> if found, NULL otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceNumOfCaps"/>virNodeDeviceNumOfCaps ()</h3><pre class="programlisting">int	virNodeDeviceNumOfCaps		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Accessor for the number of capabilities supported by the device.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of capabilities supported by the device.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceReAttach"/>virNodeDeviceReAttach ()</h3><pre class="programlisting">int	virNodeDeviceReAttach		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Re-attach a previously dettached node device to the node so that it
may be used by the node again.

Depending on the hypervisor, this may involve operations such
as resetting the device, unbinding it from a dummy device driver
and binding it to its appropriate driver.

If the device is currently in use by a guest, this method may fail.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceRef"/>virNodeDeviceRef ()</h3><pre class="programlisting">int	virNodeDeviceRef		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Increment the reference count on the dev. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virNodeDeviceFree">virNodeDeviceFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a dev would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the dev to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceReset"/>virNodeDeviceReset ()</h3><pre class="programlisting">int	virNodeDeviceReset		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Reset a previously dettached node device to the node before or
after assigning it to a guest.

The exact reset semantics depends on the hypervisor and device
type but, for example, KVM will attempt to reset PCI devices with
a Function Level Reset, Secondary Bus Reset or a Power Management
D-State reset.

If the reset will affect other devices which are currently in use,
this function may fail.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetCPUMap"/>virNodeGetCPUMap ()</h3><pre class="programlisting">int	virNodeGetCPUMap		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned char ** cpumap, <br/>					 unsigned int * online, <br/>					 unsigned int flags)<br/>
</pre><p>Get CPU map of host node CPUs.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>optional pointer to a bit map of real CPUs on the host node (in 8-bit bytes) (OUT) In case of success each bit set to 1 means that corresponding CPU is online. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit. The bit map is allocated by <a href="libvirt-libvirt.html#virNodeGetCPUMap">virNodeGetCPUMap</a> and needs to be released using free() by the caller.</td></tr><tr><td><span class="term"><i><tt>online</tt></i>:</span></td><td>optional number of online CPUs in cpumap (OUT) Contains the number of online CPUs if the call was successful.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>number of CPUs present on the host node, or -1 if there was an error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetCPUStats"/>virNodeGetCPUStats ()</h3><pre class="programlisting">int	virNodeGetCPUStats		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int cpuNum, <br/>					 <a href="libvirt-libvirt.html#virNodeCPUStatsPtr">virNodeCPUStatsPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>This function provides individual cpu statistics of the node.
If you want to get total cpu statistics of the node, you must specify
VIR_NODE_CPU_STATS_ALL_CPUS to @cpuNum.
The @params array will be filled with the values equal to the number of
parameters suggested by @nparams

As the value of @nparams is dynamic, call the API setting @nparams to 0 and
@params as NULL, the API returns the number of parameters supported by the
HV by updating @nparams on SUCCESS. The caller should then allocate @params
array, i.e. (sizeof(@virNodeCPUStats) * @nparams) bytes and call
the API again.

Here is a sample code snippet:

if ((virNodeGetCPUStats(conn, cpuNum, NULL, &amp;nparams, 0) == 0) &amp;&amp;
 (nparams != 0)) {
 if ((params = malloc(sizeof(virNodeCPUStats) * nparams)) == NULL)
 goto error;
 memset(params, 0, sizeof(virNodeCPUStats) * nparams);
 if (virNodeGetCPUStats(conn, cpuNum, params, &amp;nparams, 0))
 goto error;
}

This function doesn't require privileged access to the hypervisor.
This function expects the caller to allocate the @params.

CPU time Statistics:

VIR_NODE_CPU_STATS_KERNEL:
 The cumulative CPU time which spends by kernel,
 when the node booting up.(nanoseconds)
VIR_NODE_CPU_STATS_USER:
 The cumulative CPU time which spends by user processes,
 when the node booting up.(nanoseconds)
VIR_NODE_CPU_STATS_IDLE:
 The cumulative idle CPU time, when the node booting up.(nanoseconds)
VIR_NODE_CPU_STATS_IOWAIT:
 The cumulative I/O wait CPU time, when the node booting up.(nanoseconds)
VIR_NODE_CPU_STATS_UTILIZATION:
 The CPU utilization. The usage value is in percent and 100%
 represents all CPUs on the server.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>cpuNum</tt></i>:</span></td><td>number of node cpu. (VIR_NODE_CPU_STATS_ALL_CPUS means total cpu statistics)</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to node cpu time parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of node cpu time parameter (this value should be same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetCellsFreeMemory"/>virNodeGetCellsFreeMemory ()</h3><pre class="programlisting">int	virNodeGetCellsFreeMemory	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned long long * freeMems, <br/>					 int startCell, <br/>					 int maxCells)<br/>
</pre><p>This call returns the amount of free memory in one or more NUMA cells.
The @freeMems array must be allocated by the caller and will be filled
with the amount of free memory in bytes for each cell requested,
starting with startCell (in freeMems[0]), up to either
(startCell + maxCells), or the number of additional cells in the node,
whichever is smaller.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>freeMems</tt></i>:</span></td><td>pointer to the array of unsigned long long</td></tr><tr><td><span class="term"><i><tt>startCell</tt></i>:</span></td><td>index of first cell to return freeMems info on.</td></tr><tr><td><span class="term"><i><tt>maxCells</tt></i>:</span></td><td>Maximum number of cells for which freeMems information can be returned.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of entries filled in freeMems, or -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetFreeMemory"/>virNodeGetFreeMemory ()</h3><pre class="programlisting">unsigned long long	virNodeGetFreeMemory	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>provides the free memory available on the Node
Note: most libvirt APIs provide memory sizes in kibibytes, but in this
function the returned value is in bytes. Divide by 1024 as necessary.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the available free memory in bytes or 0 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetInfo"/>virNodeGetInfo ()</h3><pre class="programlisting">int	virNodeGetInfo			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virNodeInfoPtr">virNodeInfoPtr</a> info)<br/>
</pre><p>Extract hardware information about the node.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetMemoryParameters"/>virNodeGetMemoryParameters ()</h3><pre class="programlisting">int	virNodeGetMemoryParameters	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all node memory parameters (parameters unsupported by OS will be
omitted). On input, @nparams gives the size of the @params array;
on output, @nparams gives how many slots were filled with parameter
information, which might be less but will not exceed the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again. See virDomainGetMemoryParameters() for an equivalent usage
example.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to memory parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of memory parameters; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetMemoryStats"/>virNodeGetMemoryStats ()</h3><pre class="programlisting">int	virNodeGetMemoryStats		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int cellNum, <br/>					 <a href="libvirt-libvirt.html#virNodeMemoryStatsPtr">virNodeMemoryStatsPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>This function provides memory stats of the node.
If you want to get total memory statistics of the node, you must specify
VIR_NODE_MEMORY_STATS_ALL_CELLS to @cellNum.
The @params array will be filled with the values equal to the number of
stats suggested by @nparams

As the value of @nparams is dynamic, call the API setting @nparams to 0 and
@params as NULL, the API returns the number of parameters supported by the
HV by updating @nparams on SUCCESS. The caller should then allocate @params
array, i.e. (sizeof(@virNodeMemoryStats) * @nparams) bytes and call
the API again.

Here is the sample code snippet:

if ((virNodeGetMemoryStats(conn, cellNum, NULL, &amp;nparams, 0) == 0) &amp;&amp;
 (nparams != 0)) {
 if ((params = malloc(sizeof(virNodeMemoryStats) * nparams)) == NULL)
 goto error;
 memset(params, cellNum, 0, sizeof(virNodeMemoryStats) * nparams);
 if (virNodeGetMemoryStats(conn, params, &amp;nparams, 0))
 goto error;
}

This function doesn't require privileged access to the hypervisor.
This function expects the caller to allocate the @params.

Memory Stats:

VIR_NODE_MEMORY_STATS_TOTAL:
 The total memory usage.(KB)
VIR_NODE_MEMORY_STATS_FREE:
 The free memory usage.(KB)
 On linux, this usage includes buffers and cached.
VIR_NODE_MEMORY_STATS_BUFFERS:
 The buffers memory usage.(KB)
VIR_NODE_MEMORY_STATS_CACHED:
 The cached memory usage.(KB)</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>cellNum</tt></i>:</span></td><td>number of node cell. (VIR_NODE_MEMORY_STATS_ALL_CELLS means total cell statistics)</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to node memory stats objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of node memory stats (this value should be same or less than the number of stats supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeGetSecurityModel"/>virNodeGetSecurityModel ()</h3><pre class="programlisting">int	virNodeGetSecurityModel		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virSecurityModelPtr">virSecurityModelPtr</a> secmodel)<br/>
</pre><p>Extract the security model of a hypervisor. The 'model' field
in the @secmodel argument may be initialized to the empty
string if the driver has not activated a security model.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>a connection object</td></tr><tr><td><span class="term"><i><tt>secmodel</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeListDevices"/>virNodeListDevices ()</h3><pre class="programlisting">int	virNodeListDevices		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * cap, <br/>					 char ** const names, <br/>					 int maxnames, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of node devices, and store their names in @names

For more control over the results, see virConnectListAllNodeDevices().

If the optional 'cap' argument is non-NULL, then the count
will be restricted to devices with the specified capability</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>cap</tt></i>:</span></td><td>capability name</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of node device names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of node devices found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeNumOfDevices"/>virNodeNumOfDevices ()</h3><pre class="programlisting">int	virNodeNumOfDevices		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * cap, <br/>					 unsigned int flags)<br/>
</pre><p>Provides the number of node devices.

If the optional 'cap' argument is non-NULL, then the count
will be restricted to devices with the specified capability</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>cap</tt></i>:</span></td><td>capability name</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of node devices or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeSetMemoryParameters"/>virNodeSetMemoryParameters ()</h3><pre class="programlisting">int	virNodeSetMemoryParameters	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the node memory tunables. The function
fails if not all of the tunables are supported.

Note that it's not recommended to use this function while the
outside tuning program is running (such as ksmtuned under Linux),
as they could change the tunables in parallel, which could cause
conflicts.

This function may require privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeSuspendForDuration"/>virNodeSuspendForDuration ()</h3><pre class="programlisting">int	virNodeSuspendForDuration	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int target, <br/>					 unsigned long long duration, <br/>					 unsigned int flags)<br/>
</pre><p>Attempt to suspend the node (host machine) for the given duration of
time in the specified state (Suspend-to-RAM, Suspend-to-Disk or
Hybrid-Suspend). Schedule the node's Real-Time-Clock interrupt to
resume the node after the duration is complete.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>target</tt></i>:</span></td><td>the state to which the host must be suspended to, such as: <a href="libvirt-libvirt.html#VIR_NODE_SUSPEND_TARGET_MEM">VIR_NODE_SUSPEND_TARGET_MEM</a> (Suspend-to-RAM) <a href="libvirt-libvirt.html#VIR_NODE_SUSPEND_TARGET_DISK">VIR_NODE_SUSPEND_TARGET_DISK</a> (Suspend-to-Disk) <a href="libvirt-libvirt.html#VIR_NODE_SUSPEND_TARGET_HYBRID">VIR_NODE_SUSPEND_TARGET_HYBRID</a> (Hybrid-Suspend, which is a combination of the former modes).</td></tr><tr><td><span class="term"><i><tt>duration</tt></i>:</span></td><td>the time duration in seconds for which the host has to be suspended</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success (i.e., the node will be suspended after a short delay), -1 on failure (the operation is not supported, or an attempted suspend is already underway).</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretDefineXML"/>virSecretDefineXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	virSecretDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>If XML specifies a UUID, locates the specified secret and replaces all
attributes of the secret specified by UUID by attributes specified in xml
(any attributes not specified in xml are discarded).

Otherwise, creates a new secret with an automatically chosen UUID, and
initializes its attributes from xml.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>XML describing the secret.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a the secret on success, NULL on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretFree"/>virSecretFree ()</h3><pre class="programlisting">int	virSecretFree			(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br/>
</pre><p>Release the secret handle. The underlying secret continues to exist.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>pointer to a secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretGetConnect"/>virSecretGetConnect ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virSecretGetConnect	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br/>
</pre><p>Provides the connection pointer associated with a secret. The reference
counter on the connection is not increased by this call.

WARNING: When writing libvirt bindings in other languages, do not use this
function. Instead, store the connection and the secret object together.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretGetUUID"/>virSecretGetUUID ()</h3><pre class="programlisting">int	virSecretGetUUID		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 unsigned char * uuid)<br/>
</pre><p>Fetches the UUID of the secret.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>buffer of <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes in size</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success with the uuid buffer being filled, or -1 upon failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretGetUUIDString"/>virSecretGetUUIDString ()</h3><pre class="programlisting">int	virSecretGetUUIDString		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 char * buf)<br/>
</pre><p>Get the UUID for a secret as string. For more information about
UUID see RFC4122.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>a secret object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretGetUsageID"/>virSecretGetUsageID ()</h3><pre class="programlisting">const char *	virSecretGetUsageID	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br/>
</pre><p>Get the unique identifier of the object with which this
secret is to be used. The format of the identifier is
dependant on the usage type of the secret. For a secret
with a usage type of <a href="libvirt-libvirt.html#VIR_SECRET_USAGE_TYPE_VOLUME">VIR_SECRET_USAGE_TYPE_VOLUME</a> the
identifier will be a fully qualfied path name. The
identifiers are intended to be unique within the set of
all secrets sharing the same usage type. ie, there shall
only ever be one secret for each volume path.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>a secret object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a string identifying the object using the secret, or NULL upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretGetUsageType"/>virSecretGetUsageType ()</h3><pre class="programlisting">int	virSecretGetUsageType		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br/>
</pre><p>Get the type of object which uses this secret. The returned
value is one of the constants defined in the virSecretUsageType
enumeration. More values may be added to this enumeration in
the future, so callers should expect to see usage types they
do not explicitly know about.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>a secret object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a positive integer identifying the type of object, or -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretGetValue"/>virSecretGetValue ()</h3><pre class="programlisting">unsigned char *	virSecretGetValue	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 size_t * value_size, <br/>					 unsigned int flags)<br/>
</pre><p>Fetches the value of a secret.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> connection</td></tr><tr><td><span class="term"><i><tt>value_size</tt></i>:</span></td><td>Place for storing size of the secret value</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the secret value on success, NULL on failure. The caller must free() the secret value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretGetXMLDesc"/>virSecretGetXMLDesc ()</h3><pre class="programlisting">char *	virSecretGetXMLDesc		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 unsigned int flags)<br/>
</pre><p>Fetches an XML document describing attributes of the secret.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML document on success, NULL on failure. The caller must free() the XML.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretLookupByUUID"/>virSecretLookupByUUID ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	virSecretLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid)<br/>
</pre><p>Try to lookup a secret on the given hypervisor based on its UUID.
Uses the 16 bytes of raw data to describe the UUID</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretLookupByUUIDString"/>virSecretLookupByUUIDString ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	virSecretLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr)<br/>
</pre><p>Try to lookup a secret on the given hypervisor based on its UUID.
Uses the printable string value to describe the UUID</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretLookupByUsage"/>virSecretLookupByUsage ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	virSecretLookupByUsage	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int usageType, <br/>					 const char * usageID)<br/>
</pre><p>Try to lookup a secret on the given hypervisor based on its usage
The usageID is unique within the set of secrets sharing the
same usageType value.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>usageType</tt></i>:</span></td><td>the type of secret usage</td></tr><tr><td><span class="term"><i><tt>usageID</tt></i>:</span></td><td>identifier of the object using the secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretRef"/>virSecretRef ()</h3><pre class="programlisting">int	virSecretRef			(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br/>
</pre><p>Increment the reference count on the secret. For each additional call to
this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virSecretFree">virSecretFree</a> to release
the reference count, once the caller no longer needs the reference to this
object.

This method is typically useful for applications where multiple threads are
using a connection, and it is required that the connection remain open until
all threads have finished using it. ie, each new thread using a secret would
increment the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>the secret to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretSetValue"/>virSecretSetValue ()</h3><pre class="programlisting">int	virSecretSetValue		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br/>					 const unsigned char * value, <br/>					 size_t value_size, <br/>					 unsigned int flags)<br/>
</pre><p>Sets the value of a secret.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>Value of the secret</td></tr><tr><td><span class="term"><i><tt>value_size</tt></i>:</span></td><td>Size of the value</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSecretUndefine"/>virSecretUndefine ()</h3><pre class="programlisting">int	virSecretUndefine		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br/>
</pre><p>Deletes the specified secret. This does not free the associated
virSecretPtr object.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolBuild"/>virStoragePoolBuild ()</h3><pre class="programlisting">int	virStoragePoolBuild		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags)<br/>
</pre><p>Currently only filesystem pool accepts flags VIR_STORAGE_POOL_BUILD_OVERWRITE
and VIR_STORAGE_POOL_BUILD_NO_OVERWRITE.

Build the underlying storage pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virStoragePoolBuildFlags">virStoragePoolBuildFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 upon failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolCreate"/>virStoragePoolCreate ()</h3><pre class="programlisting">int	virStoragePoolCreate		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags)<br/>
</pre><p>Starts an inactive storage pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 if it could not be started</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolCreateXML"/>virStoragePoolCreateXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolCreateXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int flags)<br/>
</pre><p>Create a new storage based on its XML description. The
pool is not persistent, so its definition will disappear
when it is destroyed, or if the host is restarted</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>XML description for new pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if creation failed</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolDefineXML"/>virStoragePoolDefineXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xml, <br/>						 unsigned int flags)<br/>
</pre><p>Define a new inactive storage pool based on its XML description. The
pool is persistent, until explicitly undefined.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>XML description for new pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if creation failed</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolDelete"/>virStoragePoolDelete ()</h3><pre class="programlisting">int	virStoragePoolDelete		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags)<br/>
</pre><p>Delete the underlying pool resources. This is
a non-recoverable operation. The <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object
itself is not free'd.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virStoragePoolDeleteFlags">virStoragePoolDeleteFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 if it could not be obliterate</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolDestroy"/>virStoragePoolDestroy ()</h3><pre class="programlisting">int	virStoragePoolDestroy		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Destroy an active storage pool. This will deactivate the
pool on the host, but keep any persistent config associated
with it. If it has a persistent config it can later be
restarted with virStoragePoolCreate(). This does not free
the associated <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 if it could not be destroyed</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolFree"/>virStoragePoolFree ()</h3><pre class="programlisting">int	virStoragePoolFree		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Free a storage pool object, releasing all memory associated with
it. Does not change the state of the pool on the host.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 if it could not be free'd.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolGetAutostart"/>virStoragePoolGetAutostart ()</h3><pre class="programlisting">int	virStoragePoolGetAutostart	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 int * autostart)<br/>
</pre><p>Fetches the value of the autostart flag, which determines
whether the pool is automatically started at boot time</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>location in which to store autostart flag</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolGetConnect"/>virStoragePoolGetConnect ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virStoragePoolGetConnect	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Provides the connection pointer associated with a storage pool. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the pool object together.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to a pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolGetInfo"/>virStoragePoolGetInfo ()</h3><pre class="programlisting">int	virStoragePoolGetInfo		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 <a href="libvirt-libvirt.html#virStoragePoolInfoPtr">virStoragePoolInfoPtr</a> info)<br/>
</pre><p>Get volatile information about the storage pool
such as free space / usage summary</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer at which to store info</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolGetName"/>virStoragePoolGetName ()</h3><pre class="programlisting">const char *	virStoragePoolGetName	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Fetch the locally unique name of the storage pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the name of the pool, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolGetUUID"/>virStoragePoolGetUUID ()</h3><pre class="programlisting">int	virStoragePoolGetUUID		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned char * uuid)<br/>
</pre><p>Fetch the globally unique ID of the storage pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>buffer of <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes in size</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error;</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolGetUUIDString"/>virStoragePoolGetUUIDString ()</h3><pre class="programlisting">int	virStoragePoolGetUUIDString	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 char * buf)<br/>
</pre><p>Fetch the globally unique ID of the storage pool as a string</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>buffer of <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes in size</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error;</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolGetXMLDesc"/>virStoragePoolGetXMLDesc ()</h3><pre class="programlisting">char *	virStoragePoolGetXMLDesc	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags)<br/>
</pre><p>Fetch an XML document describing all aspects of the
storage pool. This is suitable for later feeding back
into the <a href="libvirt-libvirt.html#virStoragePoolCreateXML">virStoragePoolCreateXML</a> method.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virStorageXMLFlags">virStorageXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a XML document, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolIsActive"/>virStoragePoolIsActive ()</h3><pre class="programlisting">int	virStoragePoolIsActive		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Determine if the storage pool is currently running</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to the storage pool object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolIsPersistent"/>virStoragePoolIsPersistent ()</h3><pre class="programlisting">int	virStoragePoolIsPersistent	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Determine if the storage pool has a persistent configuration
which means it will still exist after shutting down</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to the storage pool object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if persistent, 0 if transient, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolListAllVolumes"/>virStoragePoolListAllVolumes ()</h3><pre class="programlisting">int	virStoragePoolListAllVolumes	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 <a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> ** vols, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of storage volumes, and allocate an array to store those
objects.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>Pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>vols</tt></i>:</span></td><td>Pointer to a variable to store the array containing storage volume objects or NULL if the list is not required (just returns number of volumes).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of storage volumes found or -1 and sets @vols to NULL in case of error. On success, the array stored into @vols is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virStorageVolFree() on each array element, then calling free() on @vols.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolListVolumes"/>virStoragePoolListVolumes ()</h3><pre class="programlisting">int	virStoragePoolListVolumes	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>Fetch list of storage volume names, limiting to
at most maxnames.

To list the volume objects directly, see virStoragePoolListAllVolumes().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array in which to storage volume names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of names array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names fetched, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolLookupByName"/>virStoragePoolLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * name)<br/>
</pre><p>Fetch a storage pool based on its unique name</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of pool to fetch</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolLookupByUUID"/>virStoragePoolLookupByUUID ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const unsigned char * uuid)<br/>
</pre><p>Fetch a storage pool based on its globally unique id</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>globally unique id of pool to fetch</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolLookupByUUIDString"/>virStoragePoolLookupByUUIDString ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * uuidstr)<br/>
</pre><p>Fetch a storage pool based on its globally unique id</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>globally unique id of pool to fetch</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolLookupByVolume"/>virStoragePoolLookupByVolume ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolLookupByVolume	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br/>
</pre><p>Fetch a storage pool which contains a particular volume</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolNumOfVolumes"/>virStoragePoolNumOfVolumes ()</h3><pre class="programlisting">int	virStoragePoolNumOfVolumes	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Fetch the number of storage volumes within a pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of storage pools, or -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolRef"/>virStoragePoolRef ()</h3><pre class="programlisting">int	virStoragePoolRef		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Increment the reference count on the pool. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virStoragePoolFree">virStoragePoolFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a pool would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>the pool to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolRefresh"/>virStoragePoolRefresh ()</h3><pre class="programlisting">int	virStoragePoolRefresh		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 unsigned int flags)<br/>
</pre><p>Request that the pool refresh its list of volumes. This may
involve communicating with a remote server, and/or initializing
new devices at the OS layer</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the volume list was refreshed, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolSetAutostart"/>virStoragePoolSetAutostart ()</h3><pre class="programlisting">int	virStoragePoolSetAutostart	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>					 int autostart)<br/>
</pre><p>Sets the autostart flag</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>new flag setting</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStoragePoolUndefine"/>virStoragePoolUndefine ()</h3><pre class="programlisting">int	virStoragePoolUndefine		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br/>
</pre><p>Undefine an inactive storage pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolCreateXML"/>virStorageVolCreateXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolCreateXML	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>						 const char * xmlDesc, <br/>						 unsigned int flags)<br/>
</pre><p>Create a storage volume within a pool based
on an XML description. Not all pools support
creation of volumes.

Since 1.0.1 VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA
in flags can be used to get higher performance with
qcow2 image files which don't support full preallocation,
by creating a sparse image file with metadata.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>description of volume to create</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virStorageVolCreateFlags">virStorageVolCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the storage volume, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolCreateXMLFrom"/>virStorageVolCreateXMLFrom ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolCreateXMLFrom	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>							 const char * xmlDesc, <br/>							 <a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> clonevol, <br/>							 unsigned int flags)<br/>
</pre><p>Create a storage volume in the parent pool, using the
'clonevol' volume as input. Information for the new
volume (name, perms) are passed via a typical volume
XML description.

Since 1.0.1 VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA
in flags can be used to get higher performance with
qcow2 image files which don't support full preallocation,
by creating a sparse image file with metadata.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to parent pool for the new volume</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>description of volume to create</td></tr><tr><td><span class="term"><i><tt>clonevol</tt></i>:</span></td><td>storage volume to use as input</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virStorageVolCreateFlags">virStorageVolCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the storage volume, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolDelete"/>virStorageVolDelete ()</h3><pre class="programlisting">int	virStorageVolDelete		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned int flags)<br/>
</pre><p>Delete the storage volume from the pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolDownload"/>virStorageVolDownload ()</h3><pre class="programlisting">int	virStorageVolDownload		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 unsigned long long offset, <br/>					 unsigned long long length, <br/>					 unsigned int flags)<br/>
</pre><p>Download the content of the volume as a stream. If @length
is zero, then the remaining contents of the volume after
@offset will be downloaded.

This call sets up an asynchronous stream; subsequent use of
stream APIs is necessary to transfer the actual data,
determine how much data is successfully transferred, and
detect any errors. The results will be unpredictable if
another active stream is writing to the storage volume.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to volume to download from</td></tr><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>stream to use as output</td></tr><tr><td><span class="term"><i><tt>offset</tt></i>:</span></td><td>position in @vol to start reading from</td></tr><tr><td><span class="term"><i><tt>length</tt></i>:</span></td><td>limit on amount of data to download</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0, or -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolFree"/>virStorageVolFree ()</h3><pre class="programlisting">int	virStorageVolFree		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br/>
</pre><p>Release the storage volume handle. The underlying
storage volume continues to exist.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolGetConnect"/>virStorageVolGetConnect ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virStorageVolGetConnect	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br/>
</pre><p>Provides the connection pointer associated with a storage volume. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the volume object together.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to a pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolGetInfo"/>virStorageVolGetInfo ()</h3><pre class="programlisting">int	virStorageVolGetInfo		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 <a href="libvirt-libvirt.html#virStorageVolInfoPtr">virStorageVolInfoPtr</a> info)<br/>
</pre><p>Fetches volatile information about the storage
volume such as its current allocation</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer at which to store info</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolGetKey"/>virStorageVolGetKey ()</h3><pre class="programlisting">const char *	virStorageVolGetKey	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br/>
</pre><p>Fetch the storage volume key. This is globally
unique, so the same volume will have the same
key no matter what host it is accessed from</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the volume key, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolGetName"/>virStorageVolGetName ()</h3><pre class="programlisting">const char *	virStorageVolGetName	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br/>
</pre><p>Fetch the storage volume name. This is unique
within the scope of a pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the volume name, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolGetPath"/>virStorageVolGetPath ()</h3><pre class="programlisting">char *	virStorageVolGetPath		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br/>
</pre><p>Fetch the storage volume path. Depending on the pool
configuration this is either persistent across hosts,
or dynamically assigned at pool startup. Consult
pool documentation for information on getting the
persistent naming</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the storage volume path, or NULL on error. The caller must free() the returned path after use.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolGetXMLDesc"/>virStorageVolGetXMLDesc ()</h3><pre class="programlisting">char *	virStorageVolGetXMLDesc		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned int flags)<br/>
</pre><p>Fetch an XML document describing all aspects of
the storage volume</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML document, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolLookupByKey"/>virStorageVolLookupByKey ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolLookupByKey	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * key)<br/>
</pre><p>Fetch a pointer to a storage volume based on its
globally unique key</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>key</tt></i>:</span></td><td>globally unique key</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a storage volume, or NULL if not found / error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolLookupByName"/>virStorageVolLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolLookupByName	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br/>							 const char * name)<br/>
</pre><p>Fetch a pointer to a storage volume based on its name
within a pool</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a storage volume, or NULL if not found / error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolLookupByPath"/>virStorageVolLookupByPath ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolLookupByPath	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * path)<br/>
</pre><p>Fetch a pointer to a storage volume based on its
locally (host) unique path</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>path</tt></i>:</span></td><td>locally unique path</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a storage volume, or NULL if not found / error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolRef"/>virStorageVolRef ()</h3><pre class="programlisting">int	virStorageVolRef		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br/>
</pre><p>Increment the reference count on the vol. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virStorageVolFree">virStorageVolFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a vol would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>the vol to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolResize"/>virStorageVolResize ()</h3><pre class="programlisting">int	virStorageVolResize		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned long long capacity, <br/>					 unsigned int flags)<br/>
</pre><p>Changes the capacity of the storage volume @vol to @capacity. The
operation will fail if the new capacity requires allocation that would
exceed the remaining free space in the parent pool. The contents of
the new capacity will appear as all zero bytes. The capacity value will
be rounded to the granularity supported by the hypervisor.

Normally, the operation will attempt to affect capacity with a minimum
impact on allocation (that is, the default operation favors a sparse
resize). If @flags contains VIR_STORAGE_VOL_RESIZE_ALLOCATE, then the
operation will ensure that allocation is sufficient for the new
capacity; this may make the operation take noticeably longer.

Normally, the operation treats @capacity as the new size in bytes;
but if @flags contains VIR_STORAGE_VOL_RESIZE_DELTA, then @capacity
represents the size difference to add to the current size. It is
up to the storage pool implementation whether unaligned requests are
rounded up to the next valid boundary, or rejected.

Normally, this operation should only be used to enlarge capacity;
but if @flags contains VIR_STORAGE_VOL_RESIZE_SHRINK, it is possible to
attempt a reduction in capacity even though it might cause data loss.
If <a href="libvirt-libvirt.html#VIR_STORAGE_VOL_RESIZE_DELTA">VIR_STORAGE_VOL_RESIZE_DELTA</a> is also present, then @capacity is
subtracted from the current size; without it, @capacity represents
the absolute new size regardless of whether it is larger or smaller
than the current size.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>capacity</tt></i>:</span></td><td>new capacity, in bytes</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virStorageVolResizeFlags">virStorageVolResizeFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolUpload"/>virStorageVolUpload ()</h3><pre class="programlisting">int	virStorageVolUpload		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 unsigned long long offset, <br/>					 unsigned long long length, <br/>					 unsigned int flags)<br/>
</pre><p>Upload new content to the volume from a stream. This call
will fail if @offset + @length exceeds the size of the
volume. Otherwise, if @length is non-zero, an error
will be raised if an attempt is made to upload greater
than @length bytes of data.

This call sets up an asynchronous stream; subsequent use of
stream APIs is necessary to transfer the actual data,
determine how much data is successfully transferred, and
detect any errors. The results will be unpredictable if
another active stream is writing to the storage volume.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to volume to upload</td></tr><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>stream to use as input</td></tr><tr><td><span class="term"><i><tt>offset</tt></i>:</span></td><td>position to start writing to</td></tr><tr><td><span class="term"><i><tt>length</tt></i>:</span></td><td>limit on amount of data to upload</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0, or -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolWipe"/>virStorageVolWipe ()</h3><pre class="programlisting">int	virStorageVolWipe		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned int flags)<br/>
</pre><p>Ensure data previously on a volume is not accessible to future reads</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStorageVolWipePattern"/>virStorageVolWipePattern ()</h3><pre class="programlisting">int	virStorageVolWipePattern	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br/>					 unsigned int algorithm, <br/>					 unsigned int flags)<br/>
</pre><p>Similar to virStorageVolWipe, but one can choose
between different wiping algorithms.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>algorithm</tt></i>:</span></td><td>one of <a href="libvirt-libvirt.html#virStorageVolWipeAlgorithm">virStorageVolWipeAlgorithm</a></td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>future flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamAbort"/>virStreamAbort ()</h3><pre class="programlisting">int	virStreamAbort			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Request that the in progress data transfer be cancelled
abnormally before the end of the stream has been reached.
For output streams this can be used to inform the driver
that the stream is being terminated early. For input
streams this can be used to inform the driver that it
should stop sending data.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventAddCallback"/>virStreamEventAddCallback ()</h3><pre class="programlisting">int	virStreamEventAddCallback	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events, <br/>					 <a href="libvirt-libvirt.html#virStreamEventCallback">virStreamEventCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)<br/>
</pre><p>Register a callback to be notified when a stream
becomes writable, or readable. This is most commonly
used in conjunction with non-blocking data streams
to integrate into an event loop</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>set of events to monitor</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to invoke when an event occurs</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>callback to free @opaque data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventRemoveCallback"/>virStreamEventRemoveCallback ()</h3><pre class="programlisting">int	virStreamEventRemoveCallback	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Remove an event callback from the stream</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventUpdateCallback"/>virStreamEventUpdateCallback ()</h3><pre class="programlisting">int	virStreamEventUpdateCallback	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events)<br/>
</pre><p>Changes the set of events to monitor for a stream. This allows
for event notification to be changed without having to
unregister &amp; register the callback completely. This method
is guaranteed to succeed if a callback is already registered</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>set of events to monitor</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 if no callback is registered</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamFinish"/>virStreamFinish ()</h3><pre class="programlisting">int	virStreamFinish			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Indicate that there is no further data is to be transmitted
on the stream. For output streams this should be called once
all data has been written. For input streams this should be
called once <a href="libvirt-libvirt.html#virStreamRecv">virStreamRecv</a> returns end-of-file.

This method is a synchronization point for all asynchronous
errors, so if this returns a success code the application can
be sure that all data has been successfully processed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamFree"/>virStreamFree ()</h3><pre class="programlisting">int	virStreamFree			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Decrement the reference count on a stream, releasing
the stream object if the reference count has hit zero.

There must not be an active data transfer in progress
when releasing the stream. If a stream needs to be
disposed of prior to end of stream being reached, then
the <a href="libvirt-libvirt.html#virStreamAbort">virStreamAbort</a> function should be called first.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 upon success, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamNew"/>virStreamNew ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a>	virStreamNew		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags)<br/>
</pre><p>Creates a new stream object which can be used to perform
streamed I/O with other public API function.

When no longer needed, a stream object must be released
with virStreamFree. If a data stream has been used,
then the application must call <a href="libvirt-libvirt.html#virStreamFinish">virStreamFinish</a> or
virStreamAbort before free'ing to, in order to notify
the driver of termination.

If a non-blocking data stream is required passed
VIR_STREAM_NONBLOCK for flags, otherwise pass 0.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt.html#virStreamFlags">virStreamFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new stream, or NULL upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRecv"/>virStreamRecv ()</h3><pre class="programlisting">int	virStreamRecv			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 char * data, <br/>					 size_t nbytes)<br/>
</pre><p>Reads a series of bytes from the stream. This method may
block the calling application for an arbitrary amount
of time.

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file download
API looks like

 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_WRONLY, 0600)

 virConnectDownloadFile(conn, "demo.iso", st);

 while (1) {
 char buf[1024];
 int got = virStreamRecv(st, buf, 1024);
 if (got &lt; 0)
 break;
 if (got == 0) {
 virStreamFinish(st);
 break;
 }
 int offset = 0;
 while (offset &lt; got) {
 int sent = write(fd, buf+offset, got-offset)
 if (sent &lt; 0) {
 virStreamAbort(st);
 goto done;
 }
 offset += sent;
 }
 }
 if (virStreamFinish(st) &lt; 0)
 ... report an error ....
 done:
 virStreamFree(st);
 close(fd);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>buffer to read into from stream</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of @data buffer</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes read, which may be less than requested. Returns 0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree. Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRecvAll"/>virStreamRecvAll ()</h3><pre class="programlisting">int	virStreamRecvAll		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a> handler, <br/>					 void * opaque)<br/>
</pre><p>Receive the entire data stream, sending the data to the
requested data sink. This is simply a convenient alternative
to virStreamRecv, for apps that do blocking-I/o.

An example using this with a hypothetical file download
API looks like

 int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
 int *fd = opaque;

 return write(*fd, buf, nbytes);
 }

 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_WRONLY)

 virConnectUploadFile(conn, st);
 if (virStreamRecvAll(st, mysink, &amp;fd) &lt; 0) {
 ...report an error ...
 goto done;
 }
 if (virStreamFinish(st) &lt; 0)
 ...report an error...
 virStreamFree(st);
 close(fd);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>handler</tt></i>:</span></td><td>sink callback for writing data to application</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree()</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRef"/>virStreamRef ()</h3><pre class="programlisting">int	virStreamRef			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Increment the reference count on the stream. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> to release the reference count, once
the caller no longer needs the reference to this object.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSend"/>virStreamSend ()</h3><pre class="programlisting">int	virStreamSend			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 const char * data, <br/>					 size_t nbytes)<br/>
</pre><p>Write a series of bytes to the stream. This method may
block the calling application for an arbitrary amount
of time. Once an application has finished sending data
it should call <a href="libvirt-libvirt.html#virStreamFinish">virStreamFinish</a> to wait for successful
confirmation from the driver, or detect any error.

This method may not be used if a stream source has been
registered.

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file upload
API looks like

 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_RDONLY)

 virConnectUploadFile(conn, "demo.iso", st);

 while (1) {
 char buf[1024];
 int got = read(fd, buf, 1024);
 if (got &lt; 0) {
 virStreamAbort(st);
 break;
 }
 if (got == 0) {
 virStreamFinish(st);
 break;
 }
 int offset = 0;
 while (offset &lt; got) {
 int sent = virStreamSend(st, buf+offset, got-offset)
 if (sent &lt; 0) {
 virStreamAbort(st);
 goto done;
 }
 offset += sent;
 }
 }
 if (virStreamFinish(st) &lt; 0)
 ... report an error ....
 done:
 virStreamFree(st);
 close(fd);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>buffer to write to stream</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of @data buffer</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes written, which may be less than requested. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree. Returns -2 if the outgoing transmit buffers are full &amp; the stream is marked as non-blocking.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSendAll"/>virStreamSendAll ()</h3><pre class="programlisting">int	virStreamSendAll		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a> handler, <br/>					 void * opaque)<br/>
</pre><p>Send the entire data stream, reading the data from the
requested data source. This is simply a convenient alternative
to virStreamSend, for apps that do blocking-I/o.

An example using this with a hypothetical file upload
API looks like

 int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
 int *fd = opaque;

 return read(*fd, buf, nbytes);
 }

 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_RDONLY)

 virConnectUploadFile(conn, st);
 if (virStreamSendAll(st, mysource, &amp;fd) &lt; 0) {
 ...report an error ...
 goto done;
 }
 if (virStreamFinish(st) &lt; 0)
 ...report an error...
 virStreamFree(st);
 close(fd);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>handler</tt></i>:</span></td><td>source callback for reading data from application</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree()</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsAddBoolean"/>virTypedParamsAddBoolean ()</h3><pre class="programlisting">int	virTypedParamsAddBoolean	(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 int value)<br/>
</pre><p>Adds new parameter called @name with boolean type and sets its value to
@value. If @params array points to NULL or to a space that is not large
enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the
function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>maxparams</tt></i>:</span></td><td>maximum number of parameters that can be stored in @params array without allocating more memory</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the value to store into the new parameter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsAddDouble"/>virTypedParamsAddDouble ()</h3><pre class="programlisting">int	virTypedParamsAddDouble		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 double value)<br/>
</pre><p>Adds new parameter called @name with double type and sets its value to
@value. If @params array points to NULL or to a space that is not large
enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the
function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>maxparams</tt></i>:</span></td><td>maximum number of parameters that can be stored in @params array without allocating more memory</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the value to store into the new parameter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsAddFromString"/>virTypedParamsAddFromString ()</h3><pre class="programlisting">int	virTypedParamsAddFromString	(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 int type, <br/>					 const char * value)<br/>
</pre><p>Adds new parameter called @name with the requested @type and parses its
value from the @value string. If the requested type is string, the function
creates its own copy of the @value string, which needs to be freed using
virTypedParamsFree or virTypedParamsClear. If @params array points to NULL
or to a space that is not large enough to accommodate the new parameter
(@maxparams &lt; @nparams + 1), the function allocates more space for it and
updates @maxparams. On success, @nparams is incremented by one. The
function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already
exists in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>maxparams</tt></i>:</span></td><td>maximum number of parameters that can be stored in @params array without allocating more memory</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of the parameter</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the value to store into the new parameter encoded as a string</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsAddInt"/>virTypedParamsAddInt ()</h3><pre class="programlisting">int	virTypedParamsAddInt		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 int value)<br/>
</pre><p>Adds new parameter called @name with int type and sets its value to @value.
If @params array points to NULL or to a space that is not large enough to
accommodate the new parameter (@maxparams &lt; @nparams + 1), the function
allocates more space for it and updates @maxparams. On success, @nparams
is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error
if the parameter already exists in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>maxparams</tt></i>:</span></td><td>maximum number of parameters that can be stored in @params array without allocating more memory</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the value to store into the new parameter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsAddLLong"/>virTypedParamsAddLLong ()</h3><pre class="programlisting">int	virTypedParamsAddLLong		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 long long value)<br/>
</pre><p>Adds new parameter called @name with long long int type and sets its value
to @value. If @params array points to NULL or to a space that is not large
enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the
function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>maxparams</tt></i>:</span></td><td>maximum number of parameters that can be stored in @params array without allocating more memory</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the value to store into the new parameter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsAddString"/>virTypedParamsAddString ()</h3><pre class="programlisting">int	virTypedParamsAddString		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 const char * value)<br/>
</pre><p>Adds new parameter called @name with char * type and sets its value to
@value. The function creates its own copy of @value string, which needs to
be freed using <a href="libvirt-libvirt.html#virTypedParamsFree">virTypedParamsFree</a> or virTypedParamsClear. If @params array
points to NULL or to a space that is not large enough to accommodate the
new parameter (@maxparams &lt; @nparams + 1), the function allocates more
space for it and updates @maxparams. On success, @nparams is incremented
by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter
already exists in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>maxparams</tt></i>:</span></td><td>maximum number of parameters that can be stored in @params array without allocating more memory</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the value to store into the new parameter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsAddUInt"/>virTypedParamsAddUInt ()</h3><pre class="programlisting">int	virTypedParamsAddUInt		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 unsigned int value)<br/>
</pre><p>Adds new parameter called @name with unsigned int type and sets its value
to @value. If @params array points to NULL or to a space that is not large
enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the
function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>maxparams</tt></i>:</span></td><td>maximum number of parameters that can be stored in @params array without allocating more memory</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the value to store into the new parameter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsAddULLong"/>virTypedParamsAddULLong ()</h3><pre class="programlisting">int	virTypedParamsAddULLong		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 int * maxparams, <br/>					 const char * name, <br/>					 unsigned long long value)<br/>
</pre><p>Adds new parameter called @name with unsigned long long type and sets its
value to @value. If @params array points to NULL or to a space that is not
large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1),
the function allocates more space for it and updates @maxparams. On success,
@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG
error if the parameter already exists in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>maxparams</tt></i>:</span></td><td>maximum number of parameters that can be stored in @params array without allocating more memory</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the value to store into the new parameter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsClear"/>virTypedParamsClear ()</h3><pre class="programlisting">void	virTypedParamsClear		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams)<br/>
</pre><p>Frees all memory used by string parameters. The memory occupied by @params
is not freed; use <a href="libvirt-libvirt.html#virTypedParamsFree">virTypedParamsFree</a> if you want it to be freed too.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsFree"/>virTypedParamsFree ()</h3><pre class="programlisting">void	virTypedParamsFree		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams)<br/>
</pre><p>Frees all memory used by string parameters and the memory occupied by
@params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>the array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsGet"/>virTypedParamsGet ()</h3><pre class="programlisting"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a>	virTypedParamsGet	(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int nparams, <br/>						 const char * name)<br/>
</pre><p>Finds typed parameter called @name.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>pointer to the parameter or NULL if it does not exist in @params.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsGetBoolean"/>virTypedParamsGetBoolean ()</h3><pre class="programlisting">int	virTypedParamsGetBoolean	(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 int * value)<br/>
</pre><p>Finds typed parameter called @name and store its boolean value in @value.
The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not
have the expected type. By passing NULL as @value, the function may be used
to check presence and type of the parameter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>where to store the parameter's value</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsGetDouble"/>virTypedParamsGetDouble ()</h3><pre class="programlisting">int	virTypedParamsGetDouble		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 double * value)<br/>
</pre><p>Finds typed parameter called @name and store its double value in @value.
The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not
have the expected type. By passing NULL as @value, the function may be used
to check presence and type of the parameter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>where to store the parameter's value</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsGetInt"/>virTypedParamsGetInt ()</h3><pre class="programlisting">int	virTypedParamsGetInt		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 int * value)<br/>
</pre><p>Finds typed parameter called @name and store its int value in @value. The
function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not
have the expected type. By passing NULL as @value, the function may be
used to check presence and type of the parameter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>where to store the parameter's value</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsGetLLong"/>virTypedParamsGetLLong ()</h3><pre class="programlisting">int	virTypedParamsGetLLong		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 long long * value)<br/>
</pre><p>Finds typed parameter called @name and store its long long int value in
@value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter
does not have the expected type. By passing NULL as @value, the function
may be used to check presence and type of the parameter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>where to store the parameter's value</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsGetString"/>virTypedParamsGetString ()</h3><pre class="programlisting">int	virTypedParamsGetString		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 const char ** value)<br/>
</pre><p>Finds typed parameter called @name and store its char * value in @value.
The function does not create a copy of the string and the caller must not
free the string @value points to. The function fails with
VIR_ERR_INVALID_ARG error if the parameter does not have the expected type.
By passing NULL as @value, the function may be used to check presence and
type of the parameter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>where to store the parameter's value</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsGetUInt"/>virTypedParamsGetUInt ()</h3><pre class="programlisting">int	virTypedParamsGetUInt		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 unsigned int * value)<br/>
</pre><p>Finds typed parameter called @name and store its unsigned int value in
@value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter
does not have the expected type. By passing NULL as @value, the function
may be used to check presence and type of the parameter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>where to store the parameter's value</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virTypedParamsGetULLong"/>virTypedParamsGetULLong ()</h3><pre class="programlisting">int	virTypedParamsGetULLong		(<a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 const char * name, <br/>					 unsigned long long * value)<br/>
</pre><p>Finds typed parameter called @name and store its unsigned long long int
value in @value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the
parameter does not have the expected type. By passing NULL as @value, the
function may be used to check presence and type of the parameter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters in the @params array</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of the parameter to find</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>where to store the parameter's value</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
      </div>
    </div>
  </body>
</html>
