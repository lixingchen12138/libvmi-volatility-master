<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--
        This file is autogenerated from html/libvirt-libvirt.html.in
        Do not edit this file. Changes will be lost.
      --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><link rel="stylesheet" type="text/css" href="../main.css" /><link rel="SHORTCUT ICON" href="../32favicon.png" /><title>libvirt: Module libvirt from libvirt</title><meta name="description" content="libvirt, virtualization, virtualization API" /></head><body><div id="header"><div id="headerLogo"></div><div id="headerSearch"><form action="../search.php" enctype="application/x-www-form-urlencoded" method="get"><div><input id="query" name="query" type="text" size="12" value="" /><input id="submit" name="submit" type="submit" value="Search" /></div></form></div></div><div id="body"><div id="menu"><ul class="l0"><li><div><a title="Front page of the libvirt website" class="inactive" href="../index.html">Home</a></div></li><li><div><a title="Details of new features and bugs fixed in each release" class="inactive" href="../news.html">News</a></div></li><li><div><a title="Applications known to use libvirt" class="inactive" href="../apps.html">Applications</a></div></li><li><div><a title="Get the latest source releases, binary builds and get access to the source repository" class="inactive" href="../downloads.html">Downloads</a></div></li><li><div><a title="Information for users, administrators and developers" class="active" href="../docs.html">Documentation</a><ul class="l1"><li><div><a title="How to compile libvirt" class="inactive" href="../compiling.html">Compiling</a></div></li><li><div><a title="Information about deploying and using libvirt" class="inactive" href="../deployment.html">Deployment</a></div></li><li><div><a title="Overview of the logical subsystems in the libvirt API" class="inactive" href="../intro.html">Architecture</a></div></li><li><div><a title="Description of the XML formats used in libvirt" class="inactive" href="../format.html">XML format</a></div></li><li><div><a title="Hypervisor specific driver information" class="inactive" href="../drivers.html">Drivers</a></div></li><li><div><a title="Reference manual for the C public API" class="active" href="../html/index.html">API reference</a><ul class="l2"><li><div><span class="active">libvirt</span></div></li><li><div><a title="error handling interfaces for the libvirt library" class="inactive" href="../html/libvirt-virterror.html">virterror</a></div></li><li><div><a title="matrix of API support per hypervisor per release" class="inactive" href="../hvsupport.html">Driver support</a></div></li></ul></div></li><li><div><a title="Bindings of the libvirt API for other languages" class="inactive" href="../bindings.html">Language bindings</a></div></li><li><div><a title="Working on the internals of libvirt API, driver and daemon code" class="inactive" href="../internals.html">Internals</a></div></li><li><div><a title="A guide and reference for developing with libvirt" class="inactive" href="../devguide.html">Development Guide</a></div></li><li><div><a title="Command reference for virsh" class="inactive" href="../virshcmdref.html">Virsh Commands</a></div></li></ul></div></li><li><div><a title="User contributed content" class="inactive" href="http://wiki.libvirt.org">Wiki</a></div></li><li><div><a title="Frequently asked questions" class="inactive" href="http://wiki.libvirt.org/page/FAQ">FAQ</a></div></li><li><div><a title="How and where to report bugs and request features" class="inactive" href="../bugs.html">Bug reports</a></div></li><li><div><a title="How to contact the developers via email and IRC" class="inactive" href="../contact.html">Contact</a></div></li><li><div><a title="Available test suites for libvirt" class="inactive" href="../testsuites.html">Test suites</a></div></li><li><div><a title="Miscellaneous links of interest related to libvirt" class="inactive" href="../relatedlinks.html">Related Links</a></div></li><li><div><a title="Overview of all content on the website" class="inactive" href="../sitemap.html">Sitemap</a></div></li></ul></div><div id="content"><h1>Module libvirt from libvirt</h1><p>Provides the interfaces of the libvirt library to handle virtualized domains Copyright (C) 2005-2006, 2010-2013 Red Hat, Inc. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><h2>Table of Contents</h2><h3><a href="#macros">Macros</a></h3><pre class="api"><span class="directive">#define</span> <a href="#LIBVIR_CHECK_VERSION">LIBVIR_CHECK_VERSION</a>
<span class="directive">#define</span> <a href="#LIBVIR_VERSION_NUMBER">LIBVIR_VERSION_NUMBER</a>
<span class="directive">#define</span> <a href="#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a>
<span class="directive">#define</span> <a href="#VIR_CPU_MAPLEN">VIR_CPU_MAPLEN</a>
<span class="directive">#define</span> <a href="#VIR_CPU_USABLE">VIR_CPU_USABLE</a>
<span class="directive">#define</span> <a href="#VIR_CPU_USED">VIR_CPU_USED</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BANDWIDTH_IN_AVERAGE">VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BANDWIDTH_IN_BURST">VIR_DOMAIN_BANDWIDTH_IN_BURST</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BANDWIDTH_IN_PEAK">VIR_DOMAIN_BANDWIDTH_IN_PEAK</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE">VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BANDWIDTH_OUT_BURST">VIR_DOMAIN_BANDWIDTH_OUT_BURST</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BANDWIDTH_OUT_PEAK">VIR_DOMAIN_BANDWIDTH_OUT_PEAK</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLKIO_DEVICE_WEIGHT">VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLKIO_FIELD_LENGTH">VIR_DOMAIN_BLKIO_FIELD_LENGTH</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLKIO_WEIGHT">VIR_DOMAIN_BLKIO_WEIGHT</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_ERRS">VIR_DOMAIN_BLOCK_STATS_ERRS</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH">VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ">VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_READ_BYTES">VIR_DOMAIN_BLOCK_STATS_READ_BYTES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_READ_REQ">VIR_DOMAIN_BLOCK_STATS_READ_REQ</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES">VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_REQ">VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_CPU_STATS_CPUTIME">VIR_DOMAIN_CPU_STATS_CPUTIME</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_CPU_STATS_SYSTEMTIME">VIR_DOMAIN_CPU_STATS_SYSTEMTIME</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_CPU_STATS_USERTIME">VIR_DOMAIN_CPU_STATS_USERTIME</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_CPU_STATS_VCPUTIME">VIR_DOMAIN_CPU_STATS_VCPUTIME</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_EVENT_CALLBACK">VIR_DOMAIN_EVENT_CALLBACK</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_COMPRESSION_BYTES">VIR_DOMAIN_JOB_COMPRESSION_BYTES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE">VIR_DOMAIN_JOB_COMPRESSION_CACHE</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES">VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW">VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_COMPRESSION_PAGES">VIR_DOMAIN_JOB_COMPRESSION_PAGES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_DISK_PROCESSED">VIR_DOMAIN_JOB_DISK_PROCESSED</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_DISK_REMAINING">VIR_DOMAIN_JOB_DISK_REMAINING</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_DISK_TOTAL">VIR_DOMAIN_JOB_DISK_TOTAL</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_DOWNTIME">VIR_DOMAIN_JOB_DOWNTIME</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_MEMORY_CONSTANT">VIR_DOMAIN_JOB_MEMORY_CONSTANT</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL">VIR_DOMAIN_JOB_MEMORY_NORMAL</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES">VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_MEMORY_PROCESSED">VIR_DOMAIN_JOB_MEMORY_PROCESSED</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_MEMORY_REMAINING">VIR_DOMAIN_JOB_MEMORY_REMAINING</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_MEMORY_TOTAL">VIR_DOMAIN_JOB_MEMORY_TOTAL</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_TIME_ELAPSED">VIR_DOMAIN_JOB_TIME_ELAPSED</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_JOB_TIME_REMAINING">VIR_DOMAIN_JOB_TIME_REMAINING</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_MEMORY_FIELD_LENGTH">VIR_DOMAIN_MEMORY_FIELD_LENGTH</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_MEMORY_HARD_LIMIT">VIR_DOMAIN_MEMORY_HARD_LIMIT</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_MEMORY_MIN_GUARANTEE">VIR_DOMAIN_MEMORY_MIN_GUARANTEE</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_MEMORY_PARAM_UNLIMITED">VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_MEMORY_SOFT_LIMIT">VIR_DOMAIN_MEMORY_SOFT_LIMIT</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT">VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_NUMA_MODE">VIR_DOMAIN_NUMA_MODE</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_NUMA_NODESET">VIR_DOMAIN_NUMA_NODESET</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_CAP">VIR_DOMAIN_SCHEDULER_CAP</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_CPU_SHARES">VIR_DOMAIN_SCHEDULER_CPU_SHARES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD">VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA">VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_LIMIT">VIR_DOMAIN_SCHEDULER_LIMIT</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_RESERVATION">VIR_DOMAIN_SCHEDULER_RESERVATION</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_SHARES">VIR_DOMAIN_SCHEDULER_SHARES</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_VCPU_PERIOD">VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_VCPU_QUOTA">VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHEDULER_WEIGHT">VIR_DOMAIN_SCHEDULER_WEIGHT</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SCHED_FIELD_LENGTH">VIR_DOMAIN_SCHED_FIELD_LENGTH</a>
<span class="directive">#define</span> <a href="#VIR_DOMAIN_SEND_KEY_MAX_KEYS">VIR_DOMAIN_SEND_KEY_MAX_KEYS</a>
<span class="directive">#define</span> <a href="#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a>
<span class="directive">#define</span> <a href="#VIR_MIGRATE_PARAM_BANDWIDTH">VIR_MIGRATE_PARAM_BANDWIDTH</a>
<span class="directive">#define</span> <a href="#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a>
<span class="directive">#define</span> <a href="#VIR_MIGRATE_PARAM_DEST_XML">VIR_MIGRATE_PARAM_DEST_XML</a>
<span class="directive">#define</span> <a href="#VIR_MIGRATE_PARAM_GRAPHICS_URI">VIR_MIGRATE_PARAM_GRAPHICS_URI</a>
<span class="directive">#define</span> <a href="#VIR_MIGRATE_PARAM_LISTEN_ADDRESS">VIR_MIGRATE_PARAM_LISTEN_ADDRESS</a>
<span class="directive">#define</span> <a href="#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a>
<span class="directive">#define</span> <a href="#VIR_NODEINFO_MAXCPUS">VIR_NODEINFO_MAXCPUS</a>
<span class="directive">#define</span> <a href="#VIR_NODE_CPU_STATS_FIELD_LENGTH">VIR_NODE_CPU_STATS_FIELD_LENGTH</a>
<span class="directive">#define</span> <a href="#VIR_NODE_CPU_STATS_IDLE">VIR_NODE_CPU_STATS_IDLE</a>
<span class="directive">#define</span> <a href="#VIR_NODE_CPU_STATS_IOWAIT">VIR_NODE_CPU_STATS_IOWAIT</a>
<span class="directive">#define</span> <a href="#VIR_NODE_CPU_STATS_KERNEL">VIR_NODE_CPU_STATS_KERNEL</a>
<span class="directive">#define</span> <a href="#VIR_NODE_CPU_STATS_USER">VIR_NODE_CPU_STATS_USER</a>
<span class="directive">#define</span> <a href="#VIR_NODE_CPU_STATS_UTILIZATION">VIR_NODE_CPU_STATS_UTILIZATION</a>
<span class="directive">#define</span> <a href="#VIR_NODE_MEMORY_STATS_BUFFERS">VIR_NODE_MEMORY_STATS_BUFFERS</a>
<span class="directive">#define</span> <a href="#VIR_NODE_MEMORY_STATS_CACHED">VIR_NODE_MEMORY_STATS_CACHED</a>
<span class="directive">#define</span> <a href="#VIR_NODE_MEMORY_STATS_FIELD_LENGTH">VIR_NODE_MEMORY_STATS_FIELD_LENGTH</a>
<span class="directive">#define</span> <a href="#VIR_NODE_MEMORY_STATS_FREE">VIR_NODE_MEMORY_STATS_FREE</a>
<span class="directive">#define</span> <a href="#VIR_NODE_MEMORY_STATS_TOTAL">VIR_NODE_MEMORY_STATS_TOTAL</a>
<span class="directive">#define</span> <a href="#VIR_SECURITY_DOI_BUFLEN">VIR_SECURITY_DOI_BUFLEN</a>
<span class="directive">#define</span> <a href="#VIR_SECURITY_LABEL_BUFLEN">VIR_SECURITY_LABEL_BUFLEN</a>
<span class="directive">#define</span> <a href="#VIR_SECURITY_MODEL_BUFLEN">VIR_SECURITY_MODEL_BUFLEN</a>
<span class="directive">#define</span> <a href="#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a>
<span class="directive">#define</span> <a href="#VIR_UNUSE_CPU">VIR_UNUSE_CPU</a>
<span class="directive">#define</span> <a href="#VIR_USE_CPU">VIR_USE_CPU</a>
<span class="directive">#define</span> <a href="#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a>
<span class="directive">#define</span> <a href="#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a>
<span class="directive">#define</span> <a href="#_virBlkioParameter">_virBlkioParameter</a>
<span class="directive">#define</span> <a href="#_virMemoryParameter">_virMemoryParameter</a>
<span class="directive">#define</span> <a href="#_virSchedParameter">_virSchedParameter</a>
</pre><h3><a href="#types">Types</a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">struct _virTypedParameter</span> <a href="#virBlkioParameter">virBlkioParameter</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virBlkioParameter">virBlkioParameter</a> *</span> <a name="virBlkioParameterPtr" id="virBlkioParameterPtr">virBlkioParameterPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virBlkioParameterType">virBlkioParameterType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virCPUCompareResult">virCPUCompareResult</a>
<span class="keyword">typedef</span> <span class="type">struct _virConnect</span> <a href="#virConnect">virConnect</a>
<span class="keyword">typedef</span> <span class="type">struct _virConnectAuth</span> <a href="#virConnectAuth">virConnectAuth</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virConnectAuth">virConnectAuth</a> *</span> <a name="virConnectAuthPtr" id="virConnectAuthPtr">virConnectAuthPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectBaselineCPUFlags">virConnectBaselineCPUFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectCloseReason">virConnectCloseReason</a>
<span class="keyword">typedef</span> <span class="type">struct _virConnectCredential</span> <a href="#virConnectCredential">virConnectCredential</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virConnectCredential">virConnectCredential</a> *</span> <a name="virConnectCredentialPtr" id="virConnectCredentialPtr">virConnectCredentialPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectCredentialType">virConnectCredentialType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectDomainEventBlockJobStatus">virConnectDomainEventBlockJobStatus</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectFlags">virConnectFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectListAllDomainsFlags">virConnectListAllDomainsFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectListAllInterfacesFlags">virConnectListAllInterfacesFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectListAllNetworksFlags">virConnectListAllNetworksFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectListAllNodeDeviceFlags">virConnectListAllNodeDeviceFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectListAllSecretsFlags">virConnectListAllSecretsFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virConnectListAllStoragePoolsFlags">virConnectListAllStoragePoolsFlags</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virConnect">virConnect</a> *</span> <a name="virConnectPtr" id="virConnectPtr">virConnectPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomain</span> <a href="#virDomain">virDomain</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainBlockCommitFlags">virDomainBlockCommitFlags</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainBlockInfo</span> <a href="#virDomainBlockInfo">virDomainBlockInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainBlockInfo">virDomainBlockInfo</a> *</span> <a name="virDomainBlockInfoPtr" id="virDomainBlockInfoPtr">virDomainBlockInfoPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainBlockJobAbortFlags">virDomainBlockJobAbortFlags</a>
<span class="keyword">typedef</span> <span class="type">unsigned long long</span> <a name="virDomainBlockJobCursor" id="virDomainBlockJobCursor">virDomainBlockJobCursor</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainBlockJobInfo</span> <a href="#virDomainBlockJobInfo">virDomainBlockJobInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a> *</span> <a name="virDomainBlockJobInfoPtr" id="virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainBlockJobType">virDomainBlockJobType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainBlockRebaseFlags">virDomainBlockRebaseFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainBlockResizeFlags">virDomainBlockResizeFlags</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a> *</span> <a name="virDomainBlockStatsPtr" id="virDomainBlockStatsPtr">virDomainBlockStatsPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainBlockStats</span> <a href="#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainBlockedReason">virDomainBlockedReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainChannelFlags">virDomainChannelFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainConsoleFlags">virDomainConsoleFlags</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainControlInfo</span> <a href="#virDomainControlInfo">virDomainControlInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainControlInfo">virDomainControlInfo</a> *</span> <a name="virDomainControlInfoPtr" id="virDomainControlInfoPtr">virDomainControlInfoPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainControlState">virDomainControlState</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainCrashedReason">virDomainCrashedReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainCreateFlags">virDomainCreateFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainDestroyFlagsValues">virDomainDestroyFlagsValues</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainDiskError</span> <a href="#virDomainDiskError">virDomainDiskError</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainDiskErrorCode">virDomainDiskErrorCode</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainDiskError">virDomainDiskError</a> *</span> <a name="virDomainDiskErrorPtr" id="virDomainDiskErrorPtr">virDomainDiskErrorPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventCrashedDetailType">virDomainEventCrashedDetailType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventDefinedDetailType">virDomainEventDefinedDetailType</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainEventGraphicsAddress</span> <a href="#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> *</span> <a name="virDomainEventGraphicsAddressPtr" id="virDomainEventGraphicsAddressPtr">virDomainEventGraphicsAddressPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventGraphicsPhase">virDomainEventGraphicsPhase</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainEventGraphicsSubject</span> <a href="#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainEventGraphicsSubjectIdentity</span> <a href="#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a> *</span> <a name="virDomainEventGraphicsSubjectIdentityPtr" id="virDomainEventGraphicsSubjectIdentityPtr">virDomainEventGraphicsSubjectIdentityPtr</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> *</span> <a name="virDomainEventGraphicsSubjectPtr" id="virDomainEventGraphicsSubjectPtr">virDomainEventGraphicsSubjectPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventID">virDomainEventID</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventIOErrorAction">virDomainEventIOErrorAction</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventPMSuspendedDetailType">virDomainEventPMSuspendedDetailType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventResumedDetailType">virDomainEventResumedDetailType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventShutdownDetailType">virDomainEventShutdownDetailType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventStartedDetailType">virDomainEventStartedDetailType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventStoppedDetailType">virDomainEventStoppedDetailType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventSuspendedDetailType">virDomainEventSuspendedDetailType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventTrayChangeReason">virDomainEventTrayChangeReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventType">virDomainEventType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventUndefinedDetailType">virDomainEventUndefinedDetailType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainEventWatchdogAction">virDomainEventWatchdogAction</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainInfo</span> <a href="#virDomainInfo">virDomainInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainInfo">virDomainInfo</a> *</span> <a name="virDomainInfoPtr" id="virDomainInfoPtr">virDomainInfoPtr</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a> *</span> <a name="virDomainInterfaceStatsPtr" id="virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainInterfaceStats</span> <a href="#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainJobInfo</span> <a href="#virDomainJobInfo">virDomainJobInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a> *</span> <a name="virDomainJobInfoPtr" id="virDomainJobInfoPtr">virDomainJobInfoPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainJobType">virDomainJobType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainMemoryFlags">virDomainMemoryFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainMemoryModFlags">virDomainMemoryModFlags</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a> *</span> <a name="virDomainMemoryStatPtr" id="virDomainMemoryStatPtr">virDomainMemoryStatPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainMemoryStat</span> <a href="#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainMemoryStatTags">virDomainMemoryStatTags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainMetadataType">virDomainMetadataType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainMigrateFlags">virDomainMigrateFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainModificationImpact">virDomainModificationImpact</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainNostateReason">virDomainNostateReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainNumatuneMemMode">virDomainNumatuneMemMode</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainPMSuspendedDiskReason">virDomainPMSuspendedDiskReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainPMSuspendedReason">virDomainPMSuspendedReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainPausedReason">virDomainPausedReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainProcessSignal">virDomainProcessSignal</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomain">virDomain</a> *</span> <a name="virDomainPtr" id="virDomainPtr">virDomainPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainRebootFlagValues">virDomainRebootFlagValues</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainRunningReason">virDomainRunningReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainShutdownReason">virDomainShutdownReason</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainShutoffReason">virDomainShutoffReason</a>
<span class="keyword">typedef</span> <span class="type">struct _virDomainSnapshot</span> <a href="#virDomainSnapshot">virDomainSnapshot</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainSnapshotCreateFlags">virDomainSnapshotCreateFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainSnapshotDeleteFlags">virDomainSnapshotDeleteFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virDomainSnapshot">virDomainSnapshot</a> *</span> <a name="virDomainSnapshotPtr" id="virDomainSnapshotPtr">virDomainSnapshotPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainSnapshotRevertFlags">virDomainSnapshotRevertFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainState">virDomainState</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainUndefineFlagsValues">virDomainUndefineFlagsValues</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainVcpuFlags">virDomainVcpuFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virDomainXMLFlags">virDomainXMLFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virEventHandleType">virEventHandleType</a>
<span class="keyword">typedef</span> <span class="type">struct _virInterface</span> <a href="#virInterface">virInterface</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virInterface">virInterface</a> *</span> <a name="virInterfacePtr" id="virInterfacePtr">virInterfacePtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virInterfaceXMLFlags">virInterfaceXMLFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virKeycodeSet">virKeycodeSet</a>
<span class="keyword">typedef</span> <span class="type">struct _virTypedParameter</span> <a href="#virMemoryParameter">virMemoryParameter</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a> *</span> <a name="virMemoryParameterPtr" id="virMemoryParameterPtr">virMemoryParameterPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virMemoryParameterType">virMemoryParameterType</a>
<span class="keyword">typedef</span> <span class="type">struct _virNWFilter</span> <a href="#virNWFilter">virNWFilter</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virNWFilter">virNWFilter</a> *</span> <a name="virNWFilterPtr" id="virNWFilterPtr">virNWFilterPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virNetwork</span> <a href="#virNetwork">virNetwork</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virNetwork">virNetwork</a> *</span> <a name="virNetworkPtr" id="virNetworkPtr">virNetworkPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virNetworkUpdateCommand">virNetworkUpdateCommand</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virNetworkUpdateFlags">virNetworkUpdateFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virNetworkUpdateSection">virNetworkUpdateSection</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virNetworkXMLFlags">virNetworkXMLFlags</a>
<span class="keyword">typedef</span> <span class="type">struct _virNodeCPUStats</span> <a href="#virNodeCPUStats">virNodeCPUStats</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virNodeCPUStats">virNodeCPUStats</a> *</span> <a name="virNodeCPUStatsPtr" id="virNodeCPUStatsPtr">virNodeCPUStatsPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virNodeDevice</span> <a href="#virNodeDevice">virNodeDevice</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virNodeDevice">virNodeDevice</a> *</span> <a name="virNodeDevicePtr" id="virNodeDevicePtr">virNodeDevicePtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virNodeGetCPUStatsAllCPUs">virNodeGetCPUStatsAllCPUs</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virNodeGetMemoryStatsAllCells">virNodeGetMemoryStatsAllCells</a>
<span class="keyword">typedef</span> <span class="type">struct _virNodeInfo</span> <a href="#virNodeInfo">virNodeInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> *</span> <a name="virNodeInfoPtr" id="virNodeInfoPtr">virNodeInfoPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virNodeMemoryStats</span> <a href="#virNodeMemoryStats">virNodeMemoryStats</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virNodeMemoryStats">virNodeMemoryStats</a> *</span> <a name="virNodeMemoryStatsPtr" id="virNodeMemoryStatsPtr">virNodeMemoryStatsPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virNodeSuspendTarget">virNodeSuspendTarget</a>
<span class="keyword">typedef</span> <span class="type">struct _virTypedParameter</span> <a href="#virSchedParameter">virSchedParameter</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virSchedParameter">virSchedParameter</a> *</span> <a name="virSchedParameterPtr" id="virSchedParameterPtr">virSchedParameterPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virSchedParameterType">virSchedParameterType</a>
<span class="keyword">typedef</span> <span class="type">struct _virSecret</span> <a href="#virSecret">virSecret</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virSecret">virSecret</a> *</span> <a name="virSecretPtr" id="virSecretPtr">virSecretPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virSecretUsageType">virSecretUsageType</a>
<span class="keyword">typedef</span> <span class="type">struct _virSecurityLabel</span> <a href="#virSecurityLabel">virSecurityLabel</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> *</span> <a name="virSecurityLabelPtr" id="virSecurityLabelPtr">virSecurityLabelPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virSecurityModel</span> <a href="#virSecurityModel">virSecurityModel</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> *</span> <a name="virSecurityModelPtr" id="virSecurityModelPtr">virSecurityModelPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virStoragePool</span> <a href="#virStoragePool">virStoragePool</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStoragePoolBuildFlags">virStoragePoolBuildFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStoragePoolDeleteFlags">virStoragePoolDeleteFlags</a>
<span class="keyword">typedef</span> <span class="type">struct _virStoragePoolInfo</span> <a href="#virStoragePoolInfo">virStoragePoolInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virStoragePoolInfo">virStoragePoolInfo</a> *</span> <a name="virStoragePoolInfoPtr" id="virStoragePoolInfoPtr">virStoragePoolInfoPtr</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virStoragePool">virStoragePool</a> *</span> <a name="virStoragePoolPtr" id="virStoragePoolPtr">virStoragePoolPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStoragePoolState">virStoragePoolState</a>
<span class="keyword">typedef</span> <span class="type">struct _virStorageVol</span> <a href="#virStorageVol">virStorageVol</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStorageVolCreateFlags">virStorageVolCreateFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStorageVolDeleteFlags">virStorageVolDeleteFlags</a>
<span class="keyword">typedef</span> <span class="type">struct _virStorageVolInfo</span> <a href="#virStorageVolInfo">virStorageVolInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virStorageVolInfo">virStorageVolInfo</a> *</span> <a name="virStorageVolInfoPtr" id="virStorageVolInfoPtr">virStorageVolInfoPtr</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virStorageVol">virStorageVol</a> *</span> <a name="virStorageVolPtr" id="virStorageVolPtr">virStorageVolPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStorageVolResizeFlags">virStorageVolResizeFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStorageVolType">virStorageVolType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStorageVolWipeAlgorithm">virStorageVolWipeAlgorithm</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStorageXMLFlags">virStorageXMLFlags</a>
<span class="keyword">typedef</span> <span class="type">struct _virStream</span> <a href="#virStream">virStream</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStreamEventType">virStreamEventType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStreamFlags">virStreamFlags</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virStream">virStream</a> *</span> <a name="virStreamPtr" id="virStreamPtr">virStreamPtr</a>
<span class="keyword">typedef</span> <span class="type">struct _virTypedParameter</span> <a href="#virTypedParameter">virTypedParameter</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virTypedParameterFlags">virTypedParameterFlags</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virTypedParameter">virTypedParameter</a> *</span> <a name="virTypedParameterPtr" id="virTypedParameterPtr">virTypedParameterPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virTypedParameterType">virTypedParameterType</a>
<span class="keyword">typedef</span> <span class="type">struct _virVcpuInfo</span> <a href="#virVcpuInfo">virVcpuInfo</a>
<span class="keyword">typedef</span> <span class="type"><a href="libvirt-libvirt.html#virVcpuInfo">virVcpuInfo</a> *</span> <a name="virVcpuInfoPtr" id="virVcpuInfoPtr">virVcpuInfoPtr</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virVcpuState">virVcpuState</a>
</pre><h3><a href="#functions">Functions</a></h3><pre class="api"><span class="keyword">typedef</span> <a href="#virConnectAuthCallbackPtr">virConnectAuthCallbackPtr</a>
<span class="type">int</span>	<a href="#virConnectAuthCallbackPtr">virConnectAuthCallbackPtr</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectCredentialPtr">virConnectCredentialPtr</a></span> cred, <br />					 <span class="type">unsigned int</span> ncred, <br />					 <span class="type">void *</span> cbdata)

<span class="type">char *</span>	<a href="#virConnectBaselineCPU">virConnectBaselineCPU</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char **</span> xmlCPUs, <br />					 <span class="type">unsigned int</span> ncpus, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectClose">virConnectClose</a>			(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="keyword">typedef</span> <a href="#virConnectCloseFunc">virConnectCloseFunc</a>
<span class="type">void</span>	<a href="#virConnectCloseFunc">virConnectCloseFunc</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">int</span> reason, <br />					 <span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virConnectCompareCPU">virConnectCompareCPU</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xmlDesc, <br />					 <span class="type">unsigned int</span> flags)
<span class="keyword">typedef</span> <a href="#virConnectDomainEventBalloonChangeCallback">virConnectDomainEventBalloonChangeCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventBalloonChangeCallback">virConnectDomainEventBalloonChangeCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />							 <span class="type">unsigned long long</span> actual, <br />							 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventBlockJobCallback">virConnectDomainEventBlockJobCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventBlockJobCallback">virConnectDomainEventBlockJobCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">const char *</span> disk, <br />						 <span class="type">int</span> type, <br />						 <span class="type">int</span> status, <br />						 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventCallback">virConnectDomainEventCallback</a>
<span class="type">int</span>	<a href="#virConnectDomainEventCallback">virConnectDomainEventCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">int</span> event, <br />					 <span class="type">int</span> detail, <br />					 <span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virConnectDomainEventDeregister">virConnectDomainEventDeregister</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a></span> cb)
<span class="type">int</span>	<a href="#virConnectDomainEventDeregisterAny">virConnectDomainEventDeregisterAny</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">int</span> callbackID)
<span class="keyword">typedef</span> <a href="#virConnectDomainEventDeviceRemovedCallback">virConnectDomainEventDeviceRemovedCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventDeviceRemovedCallback">virConnectDomainEventDeviceRemovedCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />							 <span class="type">const char *</span> devAlias, <br />							 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventDiskChangeCallback">virConnectDomainEventDiskChangeCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventDiskChangeCallback">virConnectDomainEventDiskChangeCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">const char *</span> oldSrcPath, <br />						 <span class="type">const char *</span> newSrcPath, <br />						 <span class="type">const char *</span> devAlias, <br />						 <span class="type">int</span> reason, <br />						 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventGraphicsCallback">virConnectDomainEventGraphicsCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventGraphicsCallback">virConnectDomainEventGraphicsCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">int</span> phase, <br />						 <span class="type">const <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> *</span> local, <br />						 <span class="type">const <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> *</span> remote, <br />						 <span class="type">const char *</span> authScheme, <br />						 <span class="type">const <a href="libvirt-libvirt.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> *</span> subject, <br />						 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventIOErrorCallback">virConnectDomainEventIOErrorCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventIOErrorCallback">virConnectDomainEventIOErrorCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">const char *</span> srcPath, <br />						 <span class="type">const char *</span> devAlias, <br />						 <span class="type">int</span> action, <br />						 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventIOErrorReasonCallback">virConnectDomainEventIOErrorReasonCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventIOErrorReasonCallback">virConnectDomainEventIOErrorReasonCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />							 <span class="type">const char *</span> srcPath, <br />							 <span class="type">const char *</span> devAlias, <br />							 <span class="type">int</span> action, <br />							 <span class="type">const char *</span> reason, <br />							 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventPMSuspendCallback">virConnectDomainEventPMSuspendCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventPMSuspendCallback">virConnectDomainEventPMSuspendCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">int</span> reason, <br />						 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventPMSuspendDiskCallback">virConnectDomainEventPMSuspendDiskCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventPMSuspendDiskCallback">virConnectDomainEventPMSuspendDiskCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />							 <span class="type">int</span> reason, <br />							 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventPMWakeupCallback">virConnectDomainEventPMWakeupCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventPMWakeupCallback">virConnectDomainEventPMWakeupCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">int</span> reason, <br />						 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventRTCChangeCallback">virConnectDomainEventRTCChangeCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventRTCChangeCallback">virConnectDomainEventRTCChangeCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">long long</span> utcoffset, <br />						 <span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virConnectDomainEventRegister">virConnectDomainEventRegister</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a></span> cb, <br />					 <span class="type">void *</span> opaque, <br />					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> freecb)
<span class="type">int</span>	<a href="#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">int</span> eventID, <br />						 <span class="type"><a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a></span> cb, <br />						 <span class="type">void *</span> opaque, <br />						 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> freecb)
<span class="keyword">typedef</span> <a href="#virConnectDomainEventTrayChangeCallback">virConnectDomainEventTrayChangeCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventTrayChangeCallback">virConnectDomainEventTrayChangeCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">const char *</span> devAlias, <br />						 <span class="type">int</span> reason, <br />						 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virConnectDomainEventWatchdogCallback">virConnectDomainEventWatchdogCallback</a>
<span class="type">void</span>	<a href="#virConnectDomainEventWatchdogCallback">virConnectDomainEventWatchdogCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />						 <span class="type">int</span> action, <br />						 <span class="type">void *</span> opaque)

<span class="type">char *</span>	<a href="#virConnectDomainXMLFromNative">virConnectDomainXMLFromNative</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> nativeFormat, <br />					 <span class="type">const char *</span> nativeConfig, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virConnectDomainXMLToNative">virConnectDomainXMLToNative</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> nativeFormat, <br />					 <span class="type">const char *</span> domainXml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virConnectFindStoragePoolSources">virConnectFindStoragePoolSources</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> type, <br />						 <span class="type">const char *</span> srcSpec, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectGetCPUModelNames">virConnectGetCPUModelNames</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> arch, <br />					 <span class="type">char ** *</span> models, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virConnectGetCapabilities">virConnectGetCapabilities</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">char *</span>	<a href="#virConnectGetHostname">virConnectGetHostname</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectGetLibVersion">virConnectGetLibVersion</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned long *</span> libVer)
<span class="type">int</span>	<a href="#virConnectGetMaxVcpus">virConnectGetMaxVcpus</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> type)
<span class="type">char *</span>	<a href="#virConnectGetSysinfo">virConnectGetSysinfo</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">const char *</span>	<a href="#virConnectGetType">virConnectGetType</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">char *</span>	<a href="#virConnectGetURI">virConnectGetURI</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectGetVersion">virConnectGetVersion</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned long *</span> hvVer)
<span class="type">int</span>	<a href="#virConnectIsAlive">virConnectIsAlive</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectIsEncrypted">virConnectIsEncrypted</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectIsSecure">virConnectIsSecure</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectListAllDomains">virConnectListAllDomains</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> **</span> domains, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectListAllInterfaces">virConnectListAllInterfaces</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> **</span> ifaces, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectListAllNWFilters">virConnectListAllNWFilters</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> **</span> filters, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectListAllNetworks">virConnectListAllNetworks</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> **</span> nets, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectListAllNodeDevices">virConnectListAllNodeDevices</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> **</span> devices, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectListAllSecrets">virConnectListAllSecrets</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> **</span> secrets, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectListAllStoragePools">virConnectListAllStoragePools</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> **</span> pools, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virConnectListDefinedDomains">virConnectListDefinedDomains</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type">int</span>	<a href="#virConnectListDefinedInterfaces">virConnectListDefinedInterfaces</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type">int</span>	<a href="#virConnectListDefinedNetworks">virConnectListDefinedNetworks</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type">int</span>	<a href="#virConnectListDefinedStoragePools">virConnectListDefinedStoragePools</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">char ** const</span> names, <br />						 <span class="type">int</span> maxnames)
<span class="type">int</span>	<a href="#virConnectListDomains">virConnectListDomains</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">int *</span> ids, <br />					 <span class="type">int</span> maxids)
<span class="type">int</span>	<a href="#virConnectListInterfaces">virConnectListInterfaces</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type">int</span>	<a href="#virConnectListNWFilters">virConnectListNWFilters</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type">int</span>	<a href="#virConnectListNetworks">virConnectListNetworks</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type">int</span>	<a href="#virConnectListSecrets">virConnectListSecrets</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">char **</span> uuids, <br />					 <span class="type">int</span> maxuuids)
<span class="type">int</span>	<a href="#virConnectListStoragePools">virConnectListStoragePools</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type">int</span>	<a href="#virConnectNumOfDefinedDomains">virConnectNumOfDefinedDomains</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfDefinedInterfaces">virConnectNumOfDefinedInterfaces</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfDefinedNetworks">virConnectNumOfDefinedNetworks</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfDefinedStoragePools">virConnectNumOfDefinedStoragePools</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfDomains">virConnectNumOfDomains</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfInterfaces">virConnectNumOfInterfaces</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfNWFilters">virConnectNumOfNWFilters</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfNetworks">virConnectNumOfNetworks</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfSecrets">virConnectNumOfSecrets</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectNumOfStoragePools">virConnectNumOfStoragePools</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virConnectOpen">virConnectOpen</a>		(<span class="type">const char *</span> name)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virConnectOpenAuth">virConnectOpenAuth</a>	(<span class="type">const char *</span> name, <br />					 <span class="type"><a href="libvirt-libvirt.html#virConnectAuthPtr">virConnectAuthPtr</a></span> auth, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virConnectOpenReadOnly">virConnectOpenReadOnly</a>	(<span class="type">const char *</span> name)
<span class="type">int</span>	<a href="#virConnectRef">virConnectRef</a>			(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virConnectRegisterCloseCallback">virConnectRegisterCloseCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virConnectCloseFunc">virConnectCloseFunc</a></span> cb, <br />					 <span class="type">void *</span> opaque, <br />					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> freecb)
<span class="type">int</span>	<a href="#virConnectSetKeepAlive">virConnectSetKeepAlive</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">int</span> interval, <br />					 <span class="type">unsigned int</span> count)
<span class="type">int</span>	<a href="#virConnectUnregisterCloseCallback">virConnectUnregisterCloseCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type"><a href="libvirt-libvirt.html#virConnectCloseFunc">virConnectCloseFunc</a></span> cb)
<span class="type">int</span>	<a href="#virDomainAbortJob">virDomainAbortJob</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainAttachDevice">virDomainAttachDevice</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> xml)
<span class="type">int</span>	<a href="#virDomainAttachDeviceFlags">virDomainAttachDeviceFlags</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> xml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainBlockCommit">virDomainBlockCommit</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type">const char *</span> base, <br />					 <span class="type">const char *</span> top, <br />					 <span class="type">unsigned long</span> bandwidth, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainBlockJobAbort">virDomainBlockJobAbort</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainBlockJobSetSpeed">virDomainBlockJobSetSpeed</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type">unsigned long</span> bandwidth, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainBlockPeek">virDomainBlockPeek</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type">unsigned long long</span> offset, <br />					 <span class="type">size_t</span> size, <br />					 <span class="type">void *</span> buffer, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainBlockPull">virDomainBlockPull</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type">unsigned long</span> bandwidth, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainBlockRebase">virDomainBlockRebase</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type">const char *</span> base, <br />					 <span class="type">unsigned long</span> bandwidth, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainBlockResize">virDomainBlockResize</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type">unsigned long long</span> size, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainBlockStats">virDomainBlockStats</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a></span> stats, <br />					 <span class="type">size_t</span> size)
<span class="type">int</span>	<a href="#virDomainBlockStatsFlags">virDomainBlockStatsFlags</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainCoreDump">virDomainCoreDump</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> to, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainCreate">virDomainCreate</a>			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainCreateLinux">virDomainCreateLinux</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xmlDesc, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainCreateWithFiles">virDomainCreateWithFiles</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> nfiles, <br />					 <span class="type">int *</span> files, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainCreateWithFlags">virDomainCreateWithFlags</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainCreateXML">virDomainCreateXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xmlDesc, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainCreateXMLWithFiles">virDomainCreateXMLWithFiles</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> xmlDesc, <br />						 <span class="type">unsigned int</span> nfiles, <br />						 <span class="type">int *</span> files, <br />						 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainDefineXML">virDomainDefineXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xml)
<span class="type">int</span>	<a href="#virDomainDestroy">virDomainDestroy</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainDestroyFlags">virDomainDestroyFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainDetachDevice">virDomainDetachDevice</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> xml)
<span class="type">int</span>	<a href="#virDomainDetachDeviceFlags">virDomainDetachDeviceFlags</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> xml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainFSTrim">virDomainFSTrim</a>			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> mountPoint, <br />					 <span class="type">unsigned long long</span> minimum, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainFree">virDomainFree</a>			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainGetAutostart">virDomainGetAutostart</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int *</span> autostart)
<span class="type">int</span>	<a href="#virDomainGetBlkioParameters">virDomainGetBlkioParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetBlockInfo">virDomainGetBlockInfo</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a></span> info, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetBlockIoTune">virDomainGetBlockIoTune</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetBlockJobInfo">virDomainGetBlockJobInfo</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a></span> info, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetCPUStats">virDomainGetCPUStats</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">unsigned int</span> nparams, <br />					 <span class="type">int</span> start_cpu, <br />					 <span class="type">unsigned int</span> ncpus, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virDomainGetConnect">virDomainGetConnect</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom)
<span class="type">int</span>	<a href="#virDomainGetControlInfo">virDomainGetControlInfo</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainControlInfoPtr">virDomainControlInfoPtr</a></span> info, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetDiskErrors">virDomainGetDiskErrors</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainDiskErrorPtr">virDomainDiskErrorPtr</a></span> errors, <br />					 <span class="type">unsigned int</span> maxerrors, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetEmulatorPinInfo">virDomainGetEmulatorPinInfo</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned char *</span> cpumap, <br />					 <span class="type">int</span> maplen, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virDomainGetHostname">virDomainGetHostname</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">unsigned int</span>	<a href="#virDomainGetID">virDomainGetID</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainGetInfo">virDomainGetInfo</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainInfoPtr">virDomainInfoPtr</a></span> info)
<span class="type">int</span>	<a href="#virDomainGetInterfaceParameters">virDomainGetInterfaceParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> device, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetJobInfo">virDomainGetJobInfo</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainJobInfoPtr">virDomainJobInfoPtr</a></span> info)
<span class="type">int</span>	<a href="#virDomainGetJobStats">virDomainGetJobStats</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int *</span> type, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">unsigned long</span>	<a href="#virDomainGetMaxMemory">virDomainGetMaxMemory</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainGetMaxVcpus">virDomainGetMaxVcpus</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virDomainGetMetadata">virDomainGetMetadata</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int</span> type, <br />					 <span class="type">const char *</span> uri, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">const char *</span>	<a href="#virDomainGetName">virDomainGetName</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainGetNumaParameters">virDomainGetNumaParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virDomainGetOSType">virDomainGetOSType</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainGetSchedulerParameters">virDomainGetSchedulerParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int *</span> nparams)
<span class="type">int</span>	<a href="#virDomainGetSchedulerParametersFlags">virDomainGetSchedulerParametersFlags</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />						 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />						 <span class="type">int *</span> nparams, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virDomainGetSchedulerType">virDomainGetSchedulerType</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int *</span> nparams)
<span class="type">int</span>	<a href="#virDomainGetSecurityLabel">virDomainGetSecurityLabel</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a></span> seclabel)
<span class="type">int</span>	<a href="#virDomainGetSecurityLabelList">virDomainGetSecurityLabelList</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> *</span> seclabels)
<span class="type">int</span>	<a href="#virDomainGetState">virDomainGetState</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int *</span> state, <br />					 <span class="type">int *</span> reason, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetUUID">virDomainGetUUID</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned char *</span> uuid)
<span class="type">int</span>	<a href="#virDomainGetUUIDString">virDomainGetUUIDString</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">char *</span> buf)
<span class="type">int</span>	<a href="#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int</span> ncpumaps, <br />					 <span class="type">unsigned char *</span> cpumaps, <br />					 <span class="type">int</span> maplen, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainGetVcpus">virDomainGetVcpus</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virVcpuInfoPtr">virVcpuInfoPtr</a></span> info, <br />					 <span class="type">int</span> maxinfo, <br />					 <span class="type">unsigned char *</span> cpumaps, <br />					 <span class="type">int</span> maplen)
<span class="type">int</span>	<a href="#virDomainGetVcpusFlags">virDomainGetVcpusFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virDomainGetXMLDesc">virDomainGetXMLDesc</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainHasCurrentSnapshot">virDomainHasCurrentSnapshot</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainHasManagedSaveImage">virDomainHasManagedSaveImage</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainInjectNMI">virDomainInjectNMI</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainInterfaceStats">virDomainInterfaceStats</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> path, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a></span> stats, <br />					 <span class="type">size_t</span> size)
<span class="type">int</span>	<a href="#virDomainIsActive">virDomainIsActive</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom)
<span class="type">int</span>	<a href="#virDomainIsPersistent">virDomainIsPersistent</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom)
<span class="type">int</span>	<a href="#virDomainIsUpdated">virDomainIsUpdated</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom)
<span class="type">int</span>	<a href="#virDomainListAllSnapshots">virDomainListAllSnapshots</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> **</span> snaps, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainLookupByID">virDomainLookupByID</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">int</span> id)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainLookupByName">virDomainLookupByName</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> name)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainLookupByUUID">virDomainLookupByUUID</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const unsigned char *</span> uuid)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainLookupByUUIDString">virDomainLookupByUUIDString</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> uuidstr)
<span class="type">int</span>	<a href="#virDomainManagedSave">virDomainManagedSave</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainManagedSaveRemove">virDomainManagedSaveRemove</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainMemoryPeek">virDomainMemoryPeek</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">unsigned long long</span> start, <br />					 <span class="type">size_t</span> size, <br />					 <span class="type">void *</span> buffer, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainMemoryStats">virDomainMemoryStats</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type"><a href="libvirt-libvirt.html#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a></span> stats, <br />					 <span class="type">unsigned int</span> nr_stats, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainMigrate">virDomainMigrate</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> dconn, <br />					 <span class="type">unsigned long</span> flags, <br />					 <span class="type">const char *</span> dname, <br />					 <span class="type">const char *</span> uri, <br />					 <span class="type">unsigned long</span> bandwidth)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainMigrate2">virDomainMigrate2</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> dconn, <br />					 <span class="type">const char *</span> dxml, <br />					 <span class="type">unsigned long</span> flags, <br />					 <span class="type">const char *</span> dname, <br />					 <span class="type">const char *</span> uri, <br />					 <span class="type">unsigned long</span> bandwidth)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainMigrate3">virDomainMigrate3</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> dconn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">unsigned int</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainMigrateGetCompressionCache">virDomainMigrateGetCompressionCache</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />						 <span class="type">unsigned long long *</span> cacheSize, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainMigrateGetMaxSpeed">virDomainMigrateGetMaxSpeed</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned long *</span> bandwidth, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainMigrateSetCompressionCache">virDomainMigrateSetCompressionCache</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />						 <span class="type">unsigned long long</span> cacheSize, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainMigrateSetMaxDowntime">virDomainMigrateSetMaxDowntime</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned long long</span> downtime, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainMigrateSetMaxSpeed">virDomainMigrateSetMaxSpeed</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned long</span> bandwidth, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainMigrateToURI">virDomainMigrateToURI</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> duri, <br />					 <span class="type">unsigned long</span> flags, <br />					 <span class="type">const char *</span> dname, <br />					 <span class="type">unsigned long</span> bandwidth)
<span class="type">int</span>	<a href="#virDomainMigrateToURI2">virDomainMigrateToURI2</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> dconnuri, <br />					 <span class="type">const char *</span> miguri, <br />					 <span class="type">const char *</span> dxml, <br />					 <span class="type">unsigned long</span> flags, <br />					 <span class="type">const char *</span> dname, <br />					 <span class="type">unsigned long</span> bandwidth)
<span class="type">int</span>	<a href="#virDomainMigrateToURI3">virDomainMigrateToURI3</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> dconnuri, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">unsigned int</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainOpenChannel">virDomainOpenChannel</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> st, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainOpenConsole">virDomainOpenConsole</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> dev_name, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> st, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainOpenGraphics">virDomainOpenGraphics</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">unsigned int</span> idx, <br />					 <span class="type">int</span> fd, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainPMSuspendForDuration">virDomainPMSuspendForDuration</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">unsigned int</span> target, <br />					 <span class="type">unsigned long long</span> duration, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainPMWakeup">virDomainPMWakeup</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainPinEmulator">virDomainPinEmulator</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned char *</span> cpumap, <br />					 <span class="type">int</span> maplen, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainPinVcpu">virDomainPinVcpu</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> vcpu, <br />					 <span class="type">unsigned char *</span> cpumap, <br />					 <span class="type">int</span> maplen)
<span class="type">int</span>	<a href="#virDomainPinVcpuFlags">virDomainPinVcpuFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> vcpu, <br />					 <span class="type">unsigned char *</span> cpumap, <br />					 <span class="type">int</span> maplen, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainReboot">virDomainReboot</a>			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainRef">virDomainRef</a>			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainReset">virDomainReset</a>			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainRestore">virDomainRestore</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> from)
<span class="type">int</span>	<a href="#virDomainRestoreFlags">virDomainRestoreFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> from, <br />					 <span class="type">const char *</span> dxml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainResume">virDomainResume</a>			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainRevertToSnapshot">virDomainRevertToSnapshot</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSave">virDomainSave</a>			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> to)
<span class="type">int</span>	<a href="#virDomainSaveFlags">virDomainSaveFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> to, <br />					 <span class="type">const char *</span> dxml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSaveImageDefineXML">virDomainSaveImageDefineXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> file, <br />					 <span class="type">const char *</span> dxml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virDomainSaveImageGetXMLDesc">virDomainSaveImageGetXMLDesc</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> file, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virDomainScreenshot">virDomainScreenshot</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type">unsigned int</span> screen, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSendKey">virDomainSendKey</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> codeset, <br />					 <span class="type">unsigned int</span> holdtime, <br />					 <span class="type">unsigned int *</span> keycodes, <br />					 <span class="type">int</span> nkeycodes, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSendProcessSignal">virDomainSendProcessSignal</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">long long</span> pid_value, <br />					 <span class="type">unsigned int</span> signum, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetAutostart">virDomainSetAutostart</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int</span> autostart)
<span class="type">int</span>	<a href="#virDomainSetBlkioParameters">virDomainSetBlkioParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetBlockIoTune">virDomainSetBlockIoTune</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom, <br />					 <span class="type">const char *</span> disk, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetInterfaceParameters">virDomainSetInterfaceParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> device, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetMaxMemory">virDomainSetMaxMemory</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned long</span> memory)
<span class="type">int</span>	<a href="#virDomainSetMemory">virDomainSetMemory</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned long</span> memory)
<span class="type">int</span>	<a href="#virDomainSetMemoryFlags">virDomainSetMemoryFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned long</span> memory, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetMemoryParameters">virDomainSetMemoryParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetMemoryStatsPeriod">virDomainSetMemoryStatsPeriod</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int</span> period, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetMetadata">virDomainSetMetadata</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">int</span> type, <br />					 <span class="type">const char *</span> metadata, <br />					 <span class="type">const char *</span> key, <br />					 <span class="type">const char *</span> uri, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetNumaParameters">virDomainSetNumaParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetSchedulerParameters">virDomainSetSchedulerParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams)
<span class="type">int</span>	<a href="#virDomainSetSchedulerParametersFlags">virDomainSetSchedulerParametersFlags</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />						 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />						 <span class="type">int</span> nparams, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSetVcpus">virDomainSetVcpus</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> nvcpus)
<span class="type">int</span>	<a href="#virDomainSetVcpusFlags">virDomainSetVcpusFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> nvcpus, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainShutdown">virDomainShutdown</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainShutdownFlags">virDomainShutdownFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span>	<a href="#virDomainSnapshotCreateXML">virDomainSnapshotCreateXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />							 <span class="type">const char *</span> xmlDesc, <br />							 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span>	<a href="#virDomainSnapshotCurrent">virDomainSnapshotCurrent</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />							 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotDelete">virDomainSnapshotDelete</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotFree">virDomainSnapshotFree</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virDomainSnapshotGetConnect">virDomainSnapshotGetConnect</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)
<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	<a href="#virDomainSnapshotGetDomain">virDomainSnapshotGetDomain</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)
<span class="type">const char *</span>	<a href="#virDomainSnapshotGetName">virDomainSnapshotGetName</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)
<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span>	<a href="#virDomainSnapshotGetParent">virDomainSnapshotGetParent</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />							 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virDomainSnapshotGetXMLDesc">virDomainSnapshotGetXMLDesc</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotHasMetadata">virDomainSnapshotHasMetadata</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotIsCurrent">virDomainSnapshotIsCurrent</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotListAllChildren">virDomainSnapshotListAllChildren</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />						 <span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> **</span> snaps, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotListChildrenNames">virDomainSnapshotListChildrenNames</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />						 <span class="type">char **</span> names, <br />						 <span class="type">int</span> nameslen, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotListNames">virDomainSnapshotListNames</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">char **</span> names, <br />					 <span class="type">int</span> nameslen, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span>	<a href="#virDomainSnapshotLookupByName">virDomainSnapshotLookupByName</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />							 <span class="type">const char *</span> name, <br />							 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotNum">virDomainSnapshotNum</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotNumChildren">virDomainSnapshotNumChildren</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainSnapshotRef">virDomainSnapshotRef</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)
<span class="type">int</span>	<a href="#virDomainSuspend">virDomainSuspend</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainUndefine">virDomainUndefine</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)
<span class="type">int</span>	<a href="#virDomainUndefineFlags">virDomainUndefineFlags</a>		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virDomainUpdateDeviceFlags">virDomainUpdateDeviceFlags</a>	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain, <br />					 <span class="type">const char *</span> xml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virEventAddHandle">virEventAddHandle</a>		(<span class="type">int</span> fd, <br />					 <span class="type">int</span> events, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a></span> cb, <br />					 <span class="type">void *</span> opaque, <br />					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)
<span class="keyword">typedef</span> <a href="#virEventAddHandleFunc">virEventAddHandleFunc</a>
<span class="type">int</span>	<a href="#virEventAddHandleFunc">virEventAddHandleFunc</a>		(<span class="type">int</span> fd, <br />					 <span class="type">int</span> event, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a></span> cb, <br />					 <span class="type">void *</span> opaque, <br />					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)

<span class="type">int</span>	<a href="#virEventAddTimeout">virEventAddTimeout</a>		(<span class="type">int</span> timeout, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a></span> cb, <br />					 <span class="type">void *</span> opaque, <br />					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)
<span class="keyword">typedef</span> <a href="#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a>
<span class="type">int</span>	<a href="#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a>		(<span class="type">int</span> timeout, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a></span> cb, <br />					 <span class="type">void *</span> opaque, <br />					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)

<span class="keyword">typedef</span> <a href="#virEventHandleCallback">virEventHandleCallback</a>
<span class="type">void</span>	<a href="#virEventHandleCallback">virEventHandleCallback</a>		(<span class="type">int</span> watch, <br />					 <span class="type">int</span> fd, <br />					 <span class="type">int</span> events, <br />					 <span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virEventRegisterDefaultImpl">virEventRegisterDefaultImpl</a>	(<span class="type">void</span>)
<span class="type">void</span>	<a href="#virEventRegisterImpl">virEventRegisterImpl</a>		(<span class="type"><a href="libvirt-libvirt.html#virEventAddHandleFunc">virEventAddHandleFunc</a></span> addHandle, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a></span> updateHandle, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a></span> removeHandle, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a></span> addTimeout, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a></span> updateTimeout, <br />					 <span class="type"><a href="libvirt-libvirt.html#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a></span> removeTimeout)
<span class="type">int</span>	<a href="#virEventRemoveHandle">virEventRemoveHandle</a>		(<span class="type">int</span> watch)
<span class="keyword">typedef</span> <a href="#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a>
<span class="type">int</span>	<a href="#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a>	(<span class="type">int</span> watch)

<span class="type">int</span>	<a href="#virEventRemoveTimeout">virEventRemoveTimeout</a>		(<span class="type">int</span> timer)
<span class="keyword">typedef</span> <a href="#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a>
<span class="type">int</span>	<a href="#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a>	(<span class="type">int</span> timer)

<span class="type">int</span>	<a href="#virEventRunDefaultImpl">virEventRunDefaultImpl</a>		(<span class="type">void</span>)
<span class="keyword">typedef</span> <a href="#virEventTimeoutCallback">virEventTimeoutCallback</a>
<span class="type">void</span>	<a href="#virEventTimeoutCallback">virEventTimeoutCallback</a>		(<span class="type">int</span> timer, <br />					 <span class="type">void *</span> opaque)

<span class="type">void</span>	<a href="#virEventUpdateHandle">virEventUpdateHandle</a>		(<span class="type">int</span> watch, <br />					 <span class="type">int</span> events)
<span class="keyword">typedef</span> <a href="#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a>
<span class="type">void</span>	<a href="#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a>	(<span class="type">int</span> watch, <br />					 <span class="type">int</span> event)

<span class="type">void</span>	<a href="#virEventUpdateTimeout">virEventUpdateTimeout</a>		(<span class="type">int</span> timer, <br />					 <span class="type">int</span> timeout)
<span class="keyword">typedef</span> <a href="#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a>
<span class="type">void</span>	<a href="#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a>	(<span class="type">int</span> timer, <br />					 <span class="type">int</span> timeout)

<span class="keyword">typedef</span> <a href="#virFreeCallback">virFreeCallback</a>
<span class="type">void</span>	<a href="#virFreeCallback">virFreeCallback</a>			(<span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virGetVersion">virGetVersion</a>			(<span class="type">unsigned long *</span> libVer, <br />					 <span class="type">const char *</span> type, <br />					 <span class="type">unsigned long *</span> typeVer)
<span class="type">int</span>	<a href="#virInitialize">virInitialize</a>			(<span class="type">void</span>)
<span class="type">int</span>	<a href="#virInterfaceChangeBegin">virInterfaceChangeBegin</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virInterfaceChangeCommit">virInterfaceChangeCommit</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virInterfaceChangeRollback">virInterfaceChangeRollback</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virInterfaceCreate">virInterfaceCreate</a>		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span>	<a href="#virInterfaceDefineXML">virInterfaceDefineXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virInterfaceDestroy">virInterfaceDestroy</a>		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virInterfaceFree">virInterfaceFree</a>		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virInterfaceGetConnect">virInterfaceGetConnect</a>	(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)
<span class="type">const char *</span>	<a href="#virInterfaceGetMACString">virInterfaceGetMACString</a>	(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)
<span class="type">const char *</span>	<a href="#virInterfaceGetName">virInterfaceGetName</a>	(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)
<span class="type">char *</span>	<a href="#virInterfaceGetXMLDesc">virInterfaceGetXMLDesc</a>		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virInterfaceIsActive">virInterfaceIsActive</a>		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)
<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span>	<a href="#virInterfaceLookupByMACString">virInterfaceLookupByMACString</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> macstr)
<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span>	<a href="#virInterfaceLookupByName">virInterfaceLookupByName</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> name)
<span class="type">int</span>	<a href="#virInterfaceRef">virInterfaceRef</a>			(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)
<span class="type">int</span>	<a href="#virInterfaceUndefine">virInterfaceUndefine</a>		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)
<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span>	<a href="#virNWFilterDefineXML">virNWFilterDefineXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xmlDesc)
<span class="type">int</span>	<a href="#virNWFilterFree">virNWFilterFree</a>			(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter)
<span class="type">const char *</span>	<a href="#virNWFilterGetName">virNWFilterGetName</a>	(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter)
<span class="type">int</span>	<a href="#virNWFilterGetUUID">virNWFilterGetUUID</a>		(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter, <br />					 <span class="type">unsigned char *</span> uuid)
<span class="type">int</span>	<a href="#virNWFilterGetUUIDString">virNWFilterGetUUIDString</a>	(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter, <br />					 <span class="type">char *</span> buf)
<span class="type">char *</span>	<a href="#virNWFilterGetXMLDesc">virNWFilterGetXMLDesc</a>		(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span>	<a href="#virNWFilterLookupByName">virNWFilterLookupByName</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> name)
<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span>	<a href="#virNWFilterLookupByUUID">virNWFilterLookupByUUID</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const unsigned char *</span> uuid)
<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span>	<a href="#virNWFilterLookupByUUIDString">virNWFilterLookupByUUIDString</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> uuidstr)
<span class="type">int</span>	<a href="#virNWFilterRef">virNWFilterRef</a>			(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter)
<span class="type">int</span>	<a href="#virNWFilterUndefine">virNWFilterUndefine</a>		(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter)
<span class="type">int</span>	<a href="#virNetworkCreate">virNetworkCreate</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)
<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	<a href="#virNetworkCreateXML">virNetworkCreateXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xmlDesc)
<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	<a href="#virNetworkDefineXML">virNetworkDefineXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xml)
<span class="type">int</span>	<a href="#virNetworkDestroy">virNetworkDestroy</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)
<span class="type">int</span>	<a href="#virNetworkFree">virNetworkFree</a>			(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)
<span class="type">int</span>	<a href="#virNetworkGetAutostart">virNetworkGetAutostart</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network, <br />					 <span class="type">int *</span> autostart)
<span class="type">char *</span>	<a href="#virNetworkGetBridgeName">virNetworkGetBridgeName</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virNetworkGetConnect">virNetworkGetConnect</a>	(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> net)
<span class="type">const char *</span>	<a href="#virNetworkGetName">virNetworkGetName</a>	(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)
<span class="type">int</span>	<a href="#virNetworkGetUUID">virNetworkGetUUID</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network, <br />					 <span class="type">unsigned char *</span> uuid)
<span class="type">int</span>	<a href="#virNetworkGetUUIDString">virNetworkGetUUIDString</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network, <br />					 <span class="type">char *</span> buf)
<span class="type">char *</span>	<a href="#virNetworkGetXMLDesc">virNetworkGetXMLDesc</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNetworkIsActive">virNetworkIsActive</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> net)
<span class="type">int</span>	<a href="#virNetworkIsPersistent">virNetworkIsPersistent</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> net)
<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	<a href="#virNetworkLookupByName">virNetworkLookupByName</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> name)
<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	<a href="#virNetworkLookupByUUID">virNetworkLookupByUUID</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const unsigned char *</span> uuid)
<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	<a href="#virNetworkLookupByUUIDString">virNetworkLookupByUUIDString</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> uuidstr)
<span class="type">int</span>	<a href="#virNetworkRef">virNetworkRef</a>			(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)
<span class="type">int</span>	<a href="#virNetworkSetAutostart">virNetworkSetAutostart</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network, <br />					 <span class="type">int</span> autostart)
<span class="type">int</span>	<a href="#virNetworkUndefine">virNetworkUndefine</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)
<span class="type">int</span>	<a href="#virNetworkUpdate">virNetworkUpdate</a>		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network, <br />					 <span class="type">unsigned int</span> command, <br />					 <span class="type">unsigned int</span> section, <br />					 <span class="type">int</span> parentIndex, <br />					 <span class="type">const char *</span> xml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span>	<a href="#virNodeDeviceCreateXML">virNodeDeviceCreateXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> xmlDesc, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeDeviceDestroy">virNodeDeviceDestroy</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">int</span>	<a href="#virNodeDeviceDetachFlags">virNodeDeviceDetachFlags</a>	(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev, <br />					 <span class="type">const char *</span> driverName, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeDeviceDettach">virNodeDeviceDettach</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">int</span>	<a href="#virNodeDeviceFree">virNodeDeviceFree</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">const char *</span>	<a href="#virNodeDeviceGetName">virNodeDeviceGetName</a>	(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">const char *</span>	<a href="#virNodeDeviceGetParent">virNodeDeviceGetParent</a>	(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">char *</span>	<a href="#virNodeDeviceGetXMLDesc">virNodeDeviceGetXMLDesc</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeDeviceListCaps">virNodeDeviceListCaps</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span>	<a href="#virNodeDeviceLookupByName">virNodeDeviceLookupByName</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type">const char *</span> name)
<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span>	<a href="#virNodeDeviceLookupSCSIHostByWWN">virNodeDeviceLookupSCSIHostByWWN</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type">const char *</span> wwnn, <br />							 <span class="type">const char *</span> wwpn, <br />							 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeDeviceNumOfCaps">virNodeDeviceNumOfCaps</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">int</span>	<a href="#virNodeDeviceReAttach">virNodeDeviceReAttach</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">int</span>	<a href="#virNodeDeviceRef">virNodeDeviceRef</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">int</span>	<a href="#virNodeDeviceReset">virNodeDeviceReset</a>		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)
<span class="type">int</span>	<a href="#virNodeGetCPUMap">virNodeGetCPUMap</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned char **</span> cpumap, <br />					 <span class="type">unsigned int *</span> online, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeGetCPUStats">virNodeGetCPUStats</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">int</span> cpuNum, <br />					 <span class="type"><a href="libvirt-libvirt.html#virNodeCPUStatsPtr">virNodeCPUStatsPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeGetCellsFreeMemory">virNodeGetCellsFreeMemory</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned long long *</span> freeMems, <br />					 <span class="type">int</span> startCell, <br />					 <span class="type">int</span> maxCells)
<span class="type">unsigned long long</span>	<a href="#virNodeGetFreeMemory">virNodeGetFreeMemory</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)
<span class="type">int</span>	<a href="#virNodeGetInfo">virNodeGetInfo</a>			(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virNodeInfoPtr">virNodeInfoPtr</a></span> info)
<span class="type">int</span>	<a href="#virNodeGetMemoryParameters">virNodeGetMemoryParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeGetMemoryStats">virNodeGetMemoryStats</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">int</span> cellNum, <br />					 <span class="type"><a href="libvirt-libvirt.html#virNodeMemoryStatsPtr">virNodeMemoryStatsPtr</a></span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeGetSecurityModel">virNodeGetSecurityModel</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virSecurityModelPtr">virSecurityModelPtr</a></span> secmodel)
<span class="type">int</span>	<a href="#virNodeListDevices">virNodeListDevices</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> cap, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeNumOfDevices">virNodeNumOfDevices</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> cap, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeSetMemoryParameters">virNodeSetMemoryParameters</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virNodeSuspendForDuration">virNodeSuspendForDuration</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned int</span> target, <br />					 <span class="type">unsigned long long</span> duration, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span>	<a href="#virSecretDefineXML">virSecretDefineXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const char *</span> xml, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virSecretFree">virSecretFree</a>			(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virSecretGetConnect">virSecretGetConnect</a>	(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)
<span class="type">int</span>	<a href="#virSecretGetUUID">virSecretGetUUID</a>		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret, <br />					 <span class="type">unsigned char *</span> uuid)
<span class="type">int</span>	<a href="#virSecretGetUUIDString">virSecretGetUUIDString</a>		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret, <br />					 <span class="type">char *</span> buf)
<span class="type">const char *</span>	<a href="#virSecretGetUsageID">virSecretGetUsageID</a>	(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)
<span class="type">int</span>	<a href="#virSecretGetUsageType">virSecretGetUsageType</a>		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)
<span class="type">unsigned char *</span>	<a href="#virSecretGetValue">virSecretGetValue</a>	(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret, <br />					 <span class="type">size_t *</span> value_size, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">char *</span>	<a href="#virSecretGetXMLDesc">virSecretGetXMLDesc</a>		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span>	<a href="#virSecretLookupByUUID">virSecretLookupByUUID</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">const unsigned char *</span> uuid)
<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span>	<a href="#virSecretLookupByUUIDString">virSecretLookupByUUIDString</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> uuidstr)
<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span>	<a href="#virSecretLookupByUsage">virSecretLookupByUsage</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">int</span> usageType, <br />					 <span class="type">const char *</span> usageID)
<span class="type">int</span>	<a href="#virSecretRef">virSecretRef</a>			(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)
<span class="type">int</span>	<a href="#virSecretSetValue">virSecretSetValue</a>		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret, <br />					 <span class="type">const unsigned char *</span> value, <br />					 <span class="type">size_t</span> value_size, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virSecretUndefine">virSecretUndefine</a>		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)
<span class="type">int</span>	<a href="#virStoragePoolBuild">virStoragePoolBuild</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStoragePoolCreate">virStoragePoolCreate</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	<a href="#virStoragePoolCreateXML">virStoragePoolCreateXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> xmlDesc, <br />						 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	<a href="#virStoragePoolDefineXML">virStoragePoolDefineXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />						 <span class="type">const char *</span> xml, <br />						 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStoragePoolDelete">virStoragePoolDelete</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStoragePoolDestroy">virStoragePoolDestroy</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type">int</span>	<a href="#virStoragePoolFree">virStoragePoolFree</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type">int</span>	<a href="#virStoragePoolGetAutostart">virStoragePoolGetAutostart</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">int *</span> autostart)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virStoragePoolGetConnect">virStoragePoolGetConnect</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type">int</span>	<a href="#virStoragePoolGetInfo">virStoragePoolGetInfo</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStoragePoolInfoPtr">virStoragePoolInfoPtr</a></span> info)
<span class="type">const char *</span>	<a href="#virStoragePoolGetName">virStoragePoolGetName</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type">int</span>	<a href="#virStoragePoolGetUUID">virStoragePoolGetUUID</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">unsigned char *</span> uuid)
<span class="type">int</span>	<a href="#virStoragePoolGetUUIDString">virStoragePoolGetUUIDString</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">char *</span> buf)
<span class="type">char *</span>	<a href="#virStoragePoolGetXMLDesc">virStoragePoolGetXMLDesc</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStoragePoolIsActive">virStoragePoolIsActive</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type">int</span>	<a href="#virStoragePoolIsPersistent">virStoragePoolIsPersistent</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type">int</span>	<a href="#virStoragePoolListAllVolumes">virStoragePoolListAllVolumes</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> **</span> vols, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStoragePoolListVolumes">virStoragePoolListVolumes</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">char ** const</span> names, <br />					 <span class="type">int</span> maxnames)
<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	<a href="#virStoragePoolLookupByName">virStoragePoolLookupByName</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type">const char *</span> name)
<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	<a href="#virStoragePoolLookupByUUID">virStoragePoolLookupByUUID</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type">const unsigned char *</span> uuid)
<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	<a href="#virStoragePoolLookupByUUIDString">virStoragePoolLookupByUUIDString</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type">const char *</span> uuidstr)
<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	<a href="#virStoragePoolLookupByVolume">virStoragePoolLookupByVolume</a>	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)
<span class="type">int</span>	<a href="#virStoragePoolNumOfVolumes">virStoragePoolNumOfVolumes</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type">int</span>	<a href="#virStoragePoolRef">virStoragePoolRef</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type">int</span>	<a href="#virStoragePoolRefresh">virStoragePoolRefresh</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStoragePoolSetAutostart">virStoragePoolSetAutostart</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />					 <span class="type">int</span> autostart)
<span class="type">int</span>	<a href="#virStoragePoolUndefine">virStoragePoolUndefine</a>		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)
<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	<a href="#virStorageVolCreateXML">virStorageVolCreateXML</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />						 <span class="type">const char *</span> xmlDesc, <br />						 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	<a href="#virStorageVolCreateXMLFrom">virStorageVolCreateXMLFrom</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />							 <span class="type">const char *</span> xmlDesc, <br />							 <span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> clonevol, <br />							 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStorageVolDelete">virStorageVolDelete</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStorageVolDownload">virStorageVolDownload</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type">unsigned long long</span> offset, <br />					 <span class="type">unsigned long long</span> length, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStorageVolFree">virStorageVolFree</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)
<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	<a href="#virStorageVolGetConnect">virStorageVolGetConnect</a>	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)
<span class="type">int</span>	<a href="#virStorageVolGetInfo">virStorageVolGetInfo</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStorageVolInfoPtr">virStorageVolInfoPtr</a></span> info)
<span class="type">const char *</span>	<a href="#virStorageVolGetKey">virStorageVolGetKey</a>	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)
<span class="type">const char *</span>	<a href="#virStorageVolGetName">virStorageVolGetName</a>	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)
<span class="type">char *</span>	<a href="#virStorageVolGetPath">virStorageVolGetPath</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)
<span class="type">char *</span>	<a href="#virStorageVolGetXMLDesc">virStorageVolGetXMLDesc</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol, <br />					 <span class="type">unsigned int</span> flags)
<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	<a href="#virStorageVolLookupByKey">virStorageVolLookupByKey</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type">const char *</span> key)
<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	<a href="#virStorageVolLookupByName">virStorageVolLookupByName</a>	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool, <br />							 <span class="type">const char *</span> name)
<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	<a href="#virStorageVolLookupByPath">virStorageVolLookupByPath</a>	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />							 <span class="type">const char *</span> path)
<span class="type">int</span>	<a href="#virStorageVolRef">virStorageVolRef</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)
<span class="type">int</span>	<a href="#virStorageVolResize">virStorageVolResize</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol, <br />					 <span class="type">unsigned long long</span> capacity, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStorageVolUpload">virStorageVolUpload</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type">unsigned long long</span> offset, <br />					 <span class="type">unsigned long long</span> length, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStorageVolWipe">virStorageVolWipe</a>		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStorageVolWipePattern">virStorageVolWipePattern</a>	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol, <br />					 <span class="type">unsigned int</span> algorithm, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStreamAbort">virStreamAbort</a>			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type">int</span>	<a href="#virStreamEventAddCallback">virStreamEventAddCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type">int</span> events, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStreamEventCallback">virStreamEventCallback</a></span> cb, <br />					 <span class="type">void *</span> opaque, <br />					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)
<span class="keyword">typedef</span> <a href="#virStreamEventCallback">virStreamEventCallback</a>
<span class="type">void</span>	<a href="#virStreamEventCallback">virStreamEventCallback</a>		(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type">int</span> events, <br />					 <span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virStreamEventRemoveCallback">virStreamEventRemoveCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type">int</span>	<a href="#virStreamEventUpdateCallback">virStreamEventUpdateCallback</a>	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type">int</span> events)
<span class="type">int</span>	<a href="#virStreamFinish">virStreamFinish</a>			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type">int</span>	<a href="#virStreamFree">virStreamFree</a>			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span>	<a href="#virStreamNew">virStreamNew</a>		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn, <br />					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStreamRecv">virStreamRecv</a>			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type">char *</span> data, <br />					 <span class="type">size_t</span> nbytes)
<span class="type">int</span>	<a href="#virStreamRecvAll">virStreamRecvAll</a>		(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a></span> handler, <br />					 <span class="type">void *</span> opaque)
<span class="type">int</span>	<a href="#virStreamRef">virStreamRef</a>			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type">int</span>	<a href="#virStreamSend">virStreamSend</a>			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type">const char *</span> data, <br />					 <span class="type">size_t</span> nbytes)
<span class="type">int</span>	<a href="#virStreamSendAll">virStreamSendAll</a>		(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream, <br />					 <span class="type"><a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a></span> handler, <br />					 <span class="type">void *</span> opaque)
<span class="keyword">typedef</span> <a href="#virStreamSinkFunc">virStreamSinkFunc</a>
<span class="type">int</span>	<a href="#virStreamSinkFunc">virStreamSinkFunc</a>		(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> st, <br />					 <span class="type">const char *</span> data, <br />					 <span class="type">size_t</span> nbytes, <br />					 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virStreamSourceFunc">virStreamSourceFunc</a>
<span class="type">int</span>	<a href="#virStreamSourceFunc">virStreamSourceFunc</a>		(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> st, <br />					 <span class="type">char *</span> data, <br />					 <span class="type">size_t</span> nbytes, <br />					 <span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virTypedParamsAddBoolean">virTypedParamsAddBoolean</a>	(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">int *</span> maxparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">int</span> value)
<span class="type">int</span>	<a href="#virTypedParamsAddDouble">virTypedParamsAddDouble</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">int *</span> maxparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">double</span> value)
<span class="type">int</span>	<a href="#virTypedParamsAddFromString">virTypedParamsAddFromString</a>	(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">int *</span> maxparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">int</span> type, <br />					 <span class="type">const char *</span> value)
<span class="type">int</span>	<a href="#virTypedParamsAddInt">virTypedParamsAddInt</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">int *</span> maxparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">int</span> value)
<span class="type">int</span>	<a href="#virTypedParamsAddLLong">virTypedParamsAddLLong</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">int *</span> maxparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">long long</span> value)
<span class="type">int</span>	<a href="#virTypedParamsAddString">virTypedParamsAddString</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">int *</span> maxparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">const char *</span> value)
<span class="type">int</span>	<a href="#virTypedParamsAddUInt">virTypedParamsAddUInt</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">int *</span> maxparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">unsigned int</span> value)
<span class="type">int</span>	<a href="#virTypedParamsAddULLong">virTypedParamsAddULLong</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params, <br />					 <span class="type">int *</span> nparams, <br />					 <span class="type">int *</span> maxparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">unsigned long long</span> value)
<span class="type">void</span>	<a href="#virTypedParamsClear">virTypedParamsClear</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams)
<span class="type">void</span>	<a href="#virTypedParamsFree">virTypedParamsFree</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams)
<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span>	<a href="#virTypedParamsGet">virTypedParamsGet</a>	(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />						 <span class="type">int</span> nparams, <br />						 <span class="type">const char *</span> name)
<span class="type">int</span>	<a href="#virTypedParamsGetBoolean">virTypedParamsGetBoolean</a>	(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">int *</span> value)
<span class="type">int</span>	<a href="#virTypedParamsGetDouble">virTypedParamsGetDouble</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">double *</span> value)
<span class="type">int</span>	<a href="#virTypedParamsGetInt">virTypedParamsGetInt</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">int *</span> value)
<span class="type">int</span>	<a href="#virTypedParamsGetLLong">virTypedParamsGetLLong</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">long long *</span> value)
<span class="type">int</span>	<a href="#virTypedParamsGetString">virTypedParamsGetString</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">const char **</span> value)
<span class="type">int</span>	<a href="#virTypedParamsGetUInt">virTypedParamsGetUInt</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">unsigned int *</span> value)
<span class="type">int</span>	<a href="#virTypedParamsGetULLong">virTypedParamsGetULLong</a>		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params, <br />					 <span class="type">int</span> nparams, <br />					 <span class="type">const char *</span> name, <br />					 <span class="type">unsigned long long *</span> value)
</pre><h2>Description</h2><h3><a name="macros" id="macros">Macros</a></h3><h3><a name="LIBVIR_CHECK_VERSION" id="LIBVIR_CHECK_VERSION"><code>LIBVIR_CHECK_VERSION</code></a></h3><pre class="api"><span class="directive">#define</span> LIBVIR_CHECK_VERSION</pre><div class="description"><p>Macro for developers to easily check what version of the library their code is compiling against. e.g. #if LIBVIR_CHECK_VERSION(1,1,3) // some code that only works in 1.1.3 and newer #endif</p></div><h3><a name="LIBVIR_VERSION_NUMBER" id="LIBVIR_VERSION_NUMBER"><code>LIBVIR_VERSION_NUMBER</code></a></h3><pre class="api"><span class="directive">#define</span> LIBVIR_VERSION_NUMBER</pre><div class="description"><p>Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro</p></div><h3><a name="VIR_COPY_CPUMAP" id="VIR_COPY_CPUMAP"><code>VIR_COPY_CPUMAP</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_COPY_CPUMAP</pre><div class="description"><p>This macro is to be used in conjunction with <a href="libvirt-libvirt.html#virDomainGetVcpus">virDomainGetVcpus</a>() and <a href="libvirt-libvirt.html#virDomainPinVcpu">virDomainPinVcpu</a>() APIs. <a href="libvirt-libvirt.html#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a> macro extracts the cpumap of the specified vcpu from cpumaps array and copies it into cpumap to be used later by <a href="libvirt-libvirt.html#virDomainPinVcpu">virDomainPinVcpu</a>() API.</p></div><h3><a name="VIR_CPU_MAPLEN" id="VIR_CPU_MAPLEN"><code>VIR_CPU_MAPLEN</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_CPU_MAPLEN</pre><div class="description"><p>This macro is to be used in conjunction with <a href="libvirt-libvirt.html#virDomainPinVcpu">virDomainPinVcpu</a>() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual &amp; all physical CPUs of a domain.</p></div><h3><a name="VIR_CPU_USABLE" id="VIR_CPU_USABLE"><code>VIR_CPU_USABLE</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_CPU_USABLE</pre><div class="description"><p>This macro is to be used in conjunction with <a href="libvirt-libvirt.html#virDomainGetVcpus">virDomainGetVcpus</a>() API. <a href="libvirt-libvirt.html#VIR_CPU_USABLE">VIR_CPU_USABLE</a> macro returns a non-zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.</p></div><h3><a name="VIR_CPU_USED" id="VIR_CPU_USED"><code>VIR_CPU_USED</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_CPU_USED</pre><div class="description"><p>This macro can be used in conjunction with <a href="libvirt-libvirt.html#virNodeGetCPUMap">virNodeGetCPUMap</a>() API. It returns non-zero if the bit of the related CPU is set.</p></div><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_AVERAGE" id="VIR_DOMAIN_BANDWIDTH_IN_AVERAGE"><code>VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</pre><div class="description"><p>Macro represents the inbound average of NIC bandwidth, as a uint.</p></div><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_BURST" id="VIR_DOMAIN_BANDWIDTH_IN_BURST"><code>VIR_DOMAIN_BANDWIDTH_IN_BURST</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BANDWIDTH_IN_BURST</pre><div class="description"><p>Macro represents the inbound burst of NIC bandwidth, as a uint.</p></div><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_PEAK" id="VIR_DOMAIN_BANDWIDTH_IN_PEAK"><code>VIR_DOMAIN_BANDWIDTH_IN_PEAK</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BANDWIDTH_IN_PEAK</pre><div class="description"><p>Macro represents the inbound peak of NIC bandwidth, as a uint.</p></div><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE" id="VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE"><code>VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</pre><div class="description"><p>Macro represents the outbound average of NIC bandwidth, as a uint.</p></div><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_BURST" id="VIR_DOMAIN_BANDWIDTH_OUT_BURST"><code>VIR_DOMAIN_BANDWIDTH_OUT_BURST</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BANDWIDTH_OUT_BURST</pre><div class="description"><p>Macro represents the outbound burst of NIC bandwidth, as a uint.</p></div><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_PEAK" id="VIR_DOMAIN_BANDWIDTH_OUT_PEAK"><code>VIR_DOMAIN_BANDWIDTH_OUT_PEAK</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BANDWIDTH_OUT_PEAK</pre><div class="description"><p>Macro represents the outbound peak of NIC bandwidth, as a uint.</p></div><h3><a name="VIR_DOMAIN_BLKIO_DEVICE_WEIGHT" id="VIR_DOMAIN_BLKIO_DEVICE_WEIGHT"><code>VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</pre><div class="description"><p>Macro for the blkio tunable weight_device: it represents the per-device weight, as a string. The string is parsed as a series of /path/to/device,weight elements, separated by ','.</p></div><h3><a name="VIR_DOMAIN_BLKIO_FIELD_LENGTH" id="VIR_DOMAIN_BLKIO_FIELD_LENGTH"><code>VIR_DOMAIN_BLKIO_FIELD_LENGTH</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLKIO_FIELD_LENGTH</pre><div class="description"><p>Macro providing the field length of <a href="libvirt-libvirt.html#virBlkioParameter">virBlkioParameter</a>. Provided for backwards compatibility; <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p></div><h3><a name="VIR_DOMAIN_BLKIO_WEIGHT" id="VIR_DOMAIN_BLKIO_WEIGHT"><code>VIR_DOMAIN_BLKIO_WEIGHT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLKIO_WEIGHT</pre><div class="description"><p>Macro for the Blkio tunable weight: it represents the io weight the guest can use, as a uint.</p></div><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC" id="VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC"><code>VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</pre><div class="description"><p>Macro for the BlockIoTune tunable weight: it represents the read bytes per second permitted through a block device, as a ullong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC" id="VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC"><code>VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</pre><div class="description"><p>Macro for the BlockIoTune tunable weight: it represents the read I/O operations per second permitted through a block device, as a ullong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC" id="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC"><code>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</pre><div class="description"><p>Macro for the BlockIoTune tunable weight: it represents the total bytes per second permitted through a block device, as a ullong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC" id="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC"><code>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</pre><div class="description"><p>Macro for the BlockIoTune tunable weight: it represents the total I/O operations per second permitted through a block device, as a ullong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC" id="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC"><code>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</pre><div class="description"><p>Macro for the BlockIoTune tunable weight: it represents the write bytes per second permitted through a block device, as a ullong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC" id="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC"><code>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</pre><div class="description"><p>Macro for the BlockIoTune tunable weight: it represents the write I/O operations per second permitted through a block device, as a ullong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_ERRS" id="VIR_DOMAIN_BLOCK_STATS_ERRS"><code>VIR_DOMAIN_BLOCK_STATS_ERRS</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_ERRS</pre><div class="description"><p>In Xen this returns the mysterious 'oo_req', as an llong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH" id="VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH"><code>VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</pre><div class="description"><p>Macro providing the field length of parameter names when using <a href="libvirt-libvirt.html#virDomainBlockStatsFlags">virDomainBlockStatsFlags</a>().</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ" id="VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ"><code>VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</pre><div class="description"><p>Macro represents the total flush requests of the block device, as an llong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES" id="VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES"><code>VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</pre><div class="description"><p>Macro represents the total time spend on cache flushing in nano-seconds of the block device, as an llong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_BYTES" id="VIR_DOMAIN_BLOCK_STATS_READ_BYTES"><code>VIR_DOMAIN_BLOCK_STATS_READ_BYTES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_READ_BYTES</pre><div class="description"><p>Macro represents the total number of read bytes of the block device, as an llong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_REQ" id="VIR_DOMAIN_BLOCK_STATS_READ_REQ"><code>VIR_DOMAIN_BLOCK_STATS_READ_REQ</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_READ_REQ</pre><div class="description"><p>Macro represents the total read requests of the block device, as an llong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES" id="VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES"><code>VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</pre><div class="description"><p>Macro represents the total time spend on cache reads in nano-seconds of the block device, as an llong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES" id="VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES"><code>VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</pre><div class="description"><p>Macro represents the total number of write bytes of the block device, as an llong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_REQ" id="VIR_DOMAIN_BLOCK_STATS_WRITE_REQ"><code>VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</pre><div class="description"><p>Macro represents the total write requests of the block device, as an llong.</p></div><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES" id="VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES"><code>VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</pre><div class="description"><p>Macro represents the total time spend on cache writes in nano-seconds of the block device, as an llong.</p></div><h3><a name="VIR_DOMAIN_CPU_STATS_CPUTIME" id="VIR_DOMAIN_CPU_STATS_CPUTIME"><code>VIR_DOMAIN_CPU_STATS_CPUTIME</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_CPU_STATS_CPUTIME</pre><div class="description"><p>cpu usage (sum of both vcpu and hypervisor usage) in nanoseconds, as a ullong</p></div><h3><a name="VIR_DOMAIN_CPU_STATS_SYSTEMTIME" id="VIR_DOMAIN_CPU_STATS_SYSTEMTIME"><code>VIR_DOMAIN_CPU_STATS_SYSTEMTIME</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_CPU_STATS_SYSTEMTIME</pre><div class="description"><p>cpu time charged to system instructions in nanoseconds, as a ullong</p></div><h3><a name="VIR_DOMAIN_CPU_STATS_USERTIME" id="VIR_DOMAIN_CPU_STATS_USERTIME"><code>VIR_DOMAIN_CPU_STATS_USERTIME</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_CPU_STATS_USERTIME</pre><div class="description"><p>cpu time charged to user instructions in nanoseconds, as a ullong</p></div><h3><a name="VIR_DOMAIN_CPU_STATS_VCPUTIME" id="VIR_DOMAIN_CPU_STATS_VCPUTIME"><code>VIR_DOMAIN_CPU_STATS_VCPUTIME</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_CPU_STATS_VCPUTIME</pre><div class="description"><p>vcpu usage in nanoseconds (cpu_time excluding hypervisor time), as a ullong</p></div><h3><a name="VIR_DOMAIN_EVENT_CALLBACK" id="VIR_DOMAIN_EVENT_CALLBACK"><code>VIR_DOMAIN_EVENT_CALLBACK</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_EVENT_CALLBACK</pre><div class="description"><p>Used to cast the event specific callback into the generic one for use for virDomainEventRegister</p></div><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_BYTES" id="VIR_DOMAIN_JOB_COMPRESSION_BYTES"><code>VIR_DOMAIN_JOB_COMPRESSION_BYTES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_COMPRESSION_BYTES</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of compressed bytes transferred since the beginning of migration, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_CACHE" id="VIR_DOMAIN_JOB_COMPRESSION_CACHE"><code>VIR_DOMAIN_JOB_COMPRESSION_CACHE</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_COMPRESSION_CACHE</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: size of the cache (in bytes) used for compressing repeatedly transferred memory pages during live migration, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES" id="VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES"><code>VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of repeatedly changing pages that were not found in compression cache and thus could not be compressed, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW" id="VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW"><code>VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of repeatedly changing pages that were found in compression cache but were sent uncompressed because the result of compression was larger than the original page as a whole, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_PAGES" id="VIR_DOMAIN_JOB_COMPRESSION_PAGES"><code>VIR_DOMAIN_JOB_COMPRESSION_PAGES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_COMPRESSION_PAGES</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of compressed pages transferred since the beginning of migration, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_DATA_PROCESSED" id="VIR_DOMAIN_JOB_DATA_PROCESSED"><code>VIR_DOMAIN_JOB_DATA_PROCESSED</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_DATA_PROCESSED</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes transferred from the beginning of the job, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to dataProcessed field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_DATA_REMAINING" id="VIR_DOMAIN_JOB_DATA_REMAINING"><code>VIR_DOMAIN_JOB_DATA_REMAINING</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_DATA_REMAINING</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes that still need to be transferred, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to dataRemaining field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_DATA_TOTAL" id="VIR_DOMAIN_JOB_DATA_TOTAL"><code>VIR_DOMAIN_JOB_DATA_TOTAL</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_DATA_TOTAL</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: total number of bytes supposed to be transferred, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. For <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_UNBOUNDED">VIR_DOMAIN_JOB_UNBOUNDED</a> jobs, this may be less than the sum of <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> in the event that the hypervisor has to repeat some data, e.g., due to dirtied pages during migration. For <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> jobs, <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> shall always equal <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> + <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a>. This field corresponds to dataTotal field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_DISK_PROCESSED" id="VIR_DOMAIN_JOB_DISK_PROCESSED"><code>VIR_DOMAIN_JOB_DISK_PROCESSED</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_DISK_PROCESSED</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> but only tracking guest disk progress, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to fileProcessed field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_DISK_REMAINING" id="VIR_DOMAIN_JOB_DISK_REMAINING"><code>VIR_DOMAIN_JOB_DISK_REMAINING</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_DISK_REMAINING</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> but only tracking guest disk progress, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to fileRemaining field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_DISK_TOTAL" id="VIR_DOMAIN_JOB_DISK_TOTAL"><code>VIR_DOMAIN_JOB_DISK_TOTAL</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_DISK_TOTAL</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> but only tracking guest disk progress, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to fileTotal field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_DOWNTIME" id="VIR_DOMAIN_JOB_DOWNTIME"><code>VIR_DOMAIN_JOB_DOWNTIME</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_DOWNTIME</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: downtime (ms) that is expected to happen during migration, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_MEMORY_CONSTANT" id="VIR_DOMAIN_JOB_MEMORY_CONSTANT"><code>VIR_DOMAIN_JOB_MEMORY_CONSTANT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_MEMORY_CONSTANT</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of pages filled with a constant byte (all bytes in a single page are identical) transferred since the beginning of the migration job, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. The most common example of such pages are zero pages, i.e., pages filled with zero bytes.</p></div><h3><a name="VIR_DOMAIN_JOB_MEMORY_NORMAL" id="VIR_DOMAIN_JOB_MEMORY_NORMAL"><code>VIR_DOMAIN_JOB_MEMORY_NORMAL</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_MEMORY_NORMAL</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of pages that were transferred without any kind of compression (i.e., pages which were not filled with a constant byte and which could not be compressed) transferred since the beginning of the migration job, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES" id="VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES"><code>VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes transferred as normal pages, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. See <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_MEMORY_NORMAL">VIR_DOMAIN_JOB_MEMORY_NORMAL</a> for more details.</p></div><h3><a name="VIR_DOMAIN_JOB_MEMORY_PROCESSED" id="VIR_DOMAIN_JOB_MEMORY_PROCESSED"><code>VIR_DOMAIN_JOB_MEMORY_PROCESSED</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_MEMORY_PROCESSED</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> but only tracking guest memory progress, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to memProcessed field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_MEMORY_REMAINING" id="VIR_DOMAIN_JOB_MEMORY_REMAINING"><code>VIR_DOMAIN_JOB_MEMORY_REMAINING</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_MEMORY_REMAINING</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> but only tracking guest memory progress, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to memRemaining field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_MEMORY_TOTAL" id="VIR_DOMAIN_JOB_MEMORY_TOTAL"><code>VIR_DOMAIN_JOB_MEMORY_TOTAL</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_MEMORY_TOTAL</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> but only tracking guest memory progress, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to memTotal field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_TIME_ELAPSED" id="VIR_DOMAIN_JOB_TIME_ELAPSED"><code>VIR_DOMAIN_JOB_TIME_ELAPSED</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_TIME_ELAPSED</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: time (ms) since the beginning of the job, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to timeElapsed field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_JOB_TIME_REMAINING" id="VIR_DOMAIN_JOB_TIME_REMAINING"><code>VIR_DOMAIN_JOB_TIME_REMAINING</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_JOB_TIME_REMAINING</pre><div class="description"><p><a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a> field: remaining time (ms) for <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> jobs, as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. This field corresponds to timeRemaining field in <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a>.</p></div><h3><a name="VIR_DOMAIN_MEMORY_FIELD_LENGTH" id="VIR_DOMAIN_MEMORY_FIELD_LENGTH"><code>VIR_DOMAIN_MEMORY_FIELD_LENGTH</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_MEMORY_FIELD_LENGTH</pre><div class="description"><p>Macro providing the field length of <a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a>. Provided for backwards compatibility; <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p></div><h3><a name="VIR_DOMAIN_MEMORY_HARD_LIMIT" id="VIR_DOMAIN_MEMORY_HARD_LIMIT"><code>VIR_DOMAIN_MEMORY_HARD_LIMIT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_MEMORY_HARD_LIMIT</pre><div class="description"><p>Macro for the memory tunable hard_limit: it represents the maximum memory the guest can use, as a ullong.</p></div><h3><a name="VIR_DOMAIN_MEMORY_MIN_GUARANTEE" id="VIR_DOMAIN_MEMORY_MIN_GUARANTEE"><code>VIR_DOMAIN_MEMORY_MIN_GUARANTEE</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_MEMORY_MIN_GUARANTEE</pre><div class="description"><p>Macro for the memory tunable min_guarantee: it represents the minimum memory guaranteed to be reserved for the guest, as a ullong.</p></div><h3><a name="VIR_DOMAIN_MEMORY_PARAM_UNLIMITED" id="VIR_DOMAIN_MEMORY_PARAM_UNLIMITED"><code>VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</pre><div class="description"><p>Macro providing the <a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a> value that indicates "unlimited"</p></div><h3><a name="VIR_DOMAIN_MEMORY_SOFT_LIMIT" id="VIR_DOMAIN_MEMORY_SOFT_LIMIT"><code>VIR_DOMAIN_MEMORY_SOFT_LIMIT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_MEMORY_SOFT_LIMIT</pre><div class="description"><p>Macro for the memory tunable soft_limit: it represents the memory upper limit enforced during memory contention, as a ullong.</p></div><h3><a name="VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT" id="VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT"><code>VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</pre><div class="description"><p>Macro for the swap tunable swap_hard_limit: it represents the maximum swap plus memory the guest can use, as a ullong. This limit has to be more than <a href="libvirt-libvirt.html#VIR_DOMAIN_MEMORY_HARD_LIMIT">VIR_DOMAIN_MEMORY_HARD_LIMIT</a>.</p></div><h3><a name="VIR_DOMAIN_NUMA_MODE" id="VIR_DOMAIN_NUMA_MODE"><code>VIR_DOMAIN_NUMA_MODE</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_NUMA_MODE</pre><div class="description"><p>Macro for typed parameter name that lists the numa mode of a domain, as an int containing a <a href="libvirt-libvirt.html#virDomainNumatuneMemMode">virDomainNumatuneMemMode</a> value.</p></div><h3><a name="VIR_DOMAIN_NUMA_NODESET" id="VIR_DOMAIN_NUMA_NODESET"><code>VIR_DOMAIN_NUMA_NODESET</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_NUMA_NODESET</pre><div class="description"><p>Macro for typed parameter name that lists the numa nodeset of a domain, as a string.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_CAP" id="VIR_DOMAIN_SCHEDULER_CAP"><code>VIR_DOMAIN_SCHEDULER_CAP</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_CAP</pre><div class="description"><p>Macro represents the maximum scheduler cap, when using the credit scheduler, as a uint.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_CPU_SHARES" id="VIR_DOMAIN_SCHEDULER_CPU_SHARES"><code>VIR_DOMAIN_SCHEDULER_CPU_SHARES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_CPU_SHARES</pre><div class="description"><p>Macro represents proportional weight of the scheduler used on the host cpu, when using the posix scheduler, as a ullong.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD" id="VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD"><code>VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</pre><div class="description"><p>Macro represents the enforcement period for a quota in microseconds, when using the posix scheduler, for all emulator activity not tied to vcpus, as a ullong.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA" id="VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA"><code>VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</pre><div class="description"><p>Macro represents the maximum bandwidth to be used within a period for all emulator activity not tied to vcpus, when using the posix scheduler, as an llong.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_LIMIT" id="VIR_DOMAIN_SCHEDULER_LIMIT"><code>VIR_DOMAIN_SCHEDULER_LIMIT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_LIMIT</pre><div class="description"><p>Macro represents the scheduler limit value, when using the allocation scheduler, as an llong.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_RESERVATION" id="VIR_DOMAIN_SCHEDULER_RESERVATION"><code>VIR_DOMAIN_SCHEDULER_RESERVATION</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_RESERVATION</pre><div class="description"><p>Macro represents the scheduler reservation value, when using the allocation scheduler, as an llong.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_SHARES" id="VIR_DOMAIN_SCHEDULER_SHARES"><code>VIR_DOMAIN_SCHEDULER_SHARES</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_SHARES</pre><div class="description"><p>Macro represents the scheduler shares value, when using the allocation scheduler, as an int.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_VCPU_PERIOD" id="VIR_DOMAIN_SCHEDULER_VCPU_PERIOD"><code>VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</pre><div class="description"><p>Macro represents the enforcement period for a quota, in microseconds, for vcpus only, when using the posix scheduler, as a ullong.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_VCPU_QUOTA" id="VIR_DOMAIN_SCHEDULER_VCPU_QUOTA"><code>VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</pre><div class="description"><p>Macro represents the maximum bandwidth to be used within a period for vcpus only, when using the posix scheduler, as an llong.</p></div><h3><a name="VIR_DOMAIN_SCHEDULER_WEIGHT" id="VIR_DOMAIN_SCHEDULER_WEIGHT"><code>VIR_DOMAIN_SCHEDULER_WEIGHT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHEDULER_WEIGHT</pre><div class="description"><p>Macro represents the relative weight, when using the credit scheduler, as a uint.</p></div><h3><a name="VIR_DOMAIN_SCHED_FIELD_LENGTH" id="VIR_DOMAIN_SCHED_FIELD_LENGTH"><code>VIR_DOMAIN_SCHED_FIELD_LENGTH</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SCHED_FIELD_LENGTH</pre><div class="description"><p>Macro providing the field length of <a href="libvirt-libvirt.html#virSchedParameter">virSchedParameter</a>. Provided for backwards compatibility; <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p></div><h3><a name="VIR_DOMAIN_SEND_KEY_MAX_KEYS" id="VIR_DOMAIN_SEND_KEY_MAX_KEYS"><code>VIR_DOMAIN_SEND_KEY_MAX_KEYS</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_DOMAIN_SEND_KEY_MAX_KEYS</pre><div class="description"><p>Maximum number of keycodes that can be sent in one <a href="libvirt-libvirt.html#virDomainSendKey">virDomainSendKey</a>() call.</p></div><h3><a name="VIR_GET_CPUMAP" id="VIR_GET_CPUMAP"><code>VIR_GET_CPUMAP</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_GET_CPUMAP</pre><div class="description"><p>This macro is to be used in conjunction with <a href="libvirt-libvirt.html#virDomainGetVcpus">virDomainGetVcpus</a>() and <a href="libvirt-libvirt.html#virDomainPinVcpu">virDomainPinVcpu</a>() APIs. <a href="libvirt-libvirt.html#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a> macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.</p></div><h3><a name="VIR_MIGRATE_PARAM_BANDWIDTH" id="VIR_MIGRATE_PARAM_BANDWIDTH"><code>VIR_MIGRATE_PARAM_BANDWIDTH</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_MIGRATE_PARAM_BANDWIDTH</pre><div class="description"><p>virDomainMigrate* params field: the maximum bandwidth (in MiB/s) that will be used for migration as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a>. If set to 0 or omitted, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if this field is used and is not 0.</p></div><h3><a name="VIR_MIGRATE_PARAM_DEST_NAME" id="VIR_MIGRATE_PARAM_DEST_NAME"><code>VIR_MIGRATE_PARAM_DEST_NAME</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_MIGRATE_PARAM_DEST_NAME</pre><div class="description"><p>virDomainMigrate* params field: the name to be used for the domain on the destination host as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_STRING">VIR_TYPED_PARAM_STRING</a>. Omitting this parameter keeps the domain name the same. This field is only allowed to be used with hypervisors that support domain renaming during migration.</p></div><h3><a name="VIR_MIGRATE_PARAM_DEST_XML" id="VIR_MIGRATE_PARAM_DEST_XML"><code>VIR_MIGRATE_PARAM_DEST_XML</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_MIGRATE_PARAM_DEST_XML</pre><div class="description"><p>virDomainMigrate* params field: the new configuration to be used for the domain on the destination host as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_STRING">VIR_TYPED_PARAM_STRING</a>. The configuration must include an identical set of virtual devices, to ensure a stable guest ABI across migration. Only parameters related to host side configuration can be changed in the XML. Hypervisors which support this field will forbid migration if the provided XML would cause a change in the guest ABI. This field cannot be used to rename the domain during migration (use <a href="libvirt-libvirt.html#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a> field for that purpose). Domain name in the destination XML must match the original domain name. Omitting this parameter keeps the original domain configuration. Using this field with hypervisors that do not support changing domain configuration during migration will result in a failure.</p></div><h3><a name="VIR_MIGRATE_PARAM_GRAPHICS_URI" id="VIR_MIGRATE_PARAM_GRAPHICS_URI"><code>VIR_MIGRATE_PARAM_GRAPHICS_URI</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_MIGRATE_PARAM_GRAPHICS_URI</pre><div class="description"><p>virDomainMigrate* params field: URI to use for migrating client's connection to domain's graphical console as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_STRING">VIR_TYPED_PARAM_STRING</a>. If specified, the client will be asked to automatically reconnect using these parameters instead of the automatically computed ones. This can be useful if, e.g., the client does not have a direct access to the network virtualization hosts are connected to and needs to connect through a proxy. The URI is formed as follows: protocol://hostname[:port]/[?parameters] where protocol is either "spice" or "vnc" and parameters is a list of protocol specific parameters separated by '&amp;'. Currently recognized parameters are "tlsPort" and "tlsSubject". For example, spice://target.host.com:1234/?tlsPort=4567</p></div><h3><a name="VIR_MIGRATE_PARAM_LISTEN_ADDRESS" id="VIR_MIGRATE_PARAM_LISTEN_ADDRESS"><code>VIR_MIGRATE_PARAM_LISTEN_ADDRESS</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_MIGRATE_PARAM_LISTEN_ADDRESS</pre><div class="description"><p>virDomainMigrate* params field: The listen address that hypervisor on the destination side should bind to for incoming migration. Both IPv4 and IPv6 addresses are accepted as well as hostnames (the resolving is done on destination). Some hypervisors do not support this feature and will return an error if this field is used.</p></div><h3><a name="VIR_MIGRATE_PARAM_URI" id="VIR_MIGRATE_PARAM_URI"><code>VIR_MIGRATE_PARAM_URI</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_MIGRATE_PARAM_URI</pre><div class="description"><p>virDomainMigrate* params field: URI to use for initiating domain migration as <a href="libvirt-libvirt.html#VIR_TYPED_PARAM_STRING">VIR_TYPED_PARAM_STRING</a>. It takes a hypervisor specific format. The uri_transports element of the hypervisor capabilities XML includes details of the supported URI schemes. When omitted libvirt will auto-generate suitable default URI. It is typically only necessary to specify this URI if the destination host has multiple interfaces and a specific interface is required to transmit migration data. This filed may not be used when <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> flag is set.</p></div><h3><a name="VIR_NODEINFO_MAXCPUS" id="VIR_NODEINFO_MAXCPUS"><code>VIR_NODEINFO_MAXCPUS</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODEINFO_MAXCPUS</pre><div class="description"><p>This macro is to calculate the total number of CPUs supported but not necessary active in the host.</p></div><h3><a name="VIR_NODE_CPU_STATS_FIELD_LENGTH" id="VIR_NODE_CPU_STATS_FIELD_LENGTH"><code>VIR_NODE_CPU_STATS_FIELD_LENGTH</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_CPU_STATS_FIELD_LENGTH</pre><div class="description"><p>Macro providing the field length of <a href="libvirt-libvirt.html#virNodeCPUStats">virNodeCPUStats</a></p></div><h3><a name="VIR_NODE_CPU_STATS_IDLE" id="VIR_NODE_CPU_STATS_IDLE"><code>VIR_NODE_CPU_STATS_IDLE</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_CPU_STATS_IDLE</pre><div class="description"><p>The cumulative idle CPU time, since the node booting up (in nanoseconds).</p></div><h3><a name="VIR_NODE_CPU_STATS_IOWAIT" id="VIR_NODE_CPU_STATS_IOWAIT"><code>VIR_NODE_CPU_STATS_IOWAIT</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_CPU_STATS_IOWAIT</pre><div class="description"><p>The cumulative I/O wait CPU time, since the node booting up (in nanoseconds).</p></div><h3><a name="VIR_NODE_CPU_STATS_KERNEL" id="VIR_NODE_CPU_STATS_KERNEL"><code>VIR_NODE_CPU_STATS_KERNEL</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_CPU_STATS_KERNEL</pre><div class="description"><p>Macro for the cumulative CPU time which was spent by the kernel, since the node booting up (in nanoseconds).</p></div><h3><a name="VIR_NODE_CPU_STATS_USER" id="VIR_NODE_CPU_STATS_USER"><code>VIR_NODE_CPU_STATS_USER</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_CPU_STATS_USER</pre><div class="description"><p>The cumulative CPU time which was spent by user processes, since the node booting up (in nanoseconds).</p></div><h3><a name="VIR_NODE_CPU_STATS_UTILIZATION" id="VIR_NODE_CPU_STATS_UTILIZATION"><code>VIR_NODE_CPU_STATS_UTILIZATION</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_CPU_STATS_UTILIZATION</pre><div class="description"><p>The CPU utilization of a node. The usage value is in percent and 100% represents all CPUs of the node.</p></div><h3><a name="VIR_NODE_MEMORY_STATS_BUFFERS" id="VIR_NODE_MEMORY_STATS_BUFFERS"><code>VIR_NODE_MEMORY_STATS_BUFFERS</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_MEMORY_STATS_BUFFERS</pre><div class="description"><p>Macro for the buffer memory: On Linux, it is only returned in case of <a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_ALL_CELLS">VIR_NODE_MEMORY_STATS_ALL_CELLS</a>.</p></div><h3><a name="VIR_NODE_MEMORY_STATS_CACHED" id="VIR_NODE_MEMORY_STATS_CACHED"><code>VIR_NODE_MEMORY_STATS_CACHED</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_MEMORY_STATS_CACHED</pre><div class="description"><p>Macro for the cached memory: On Linux, it is only returned in case of <a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_ALL_CELLS">VIR_NODE_MEMORY_STATS_ALL_CELLS</a>.</p></div><h3><a name="VIR_NODE_MEMORY_STATS_FIELD_LENGTH" id="VIR_NODE_MEMORY_STATS_FIELD_LENGTH"><code>VIR_NODE_MEMORY_STATS_FIELD_LENGTH</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_MEMORY_STATS_FIELD_LENGTH</pre><div class="description"><p>Macro providing the field length of <a href="libvirt-libvirt.html#virNodeMemoryStats">virNodeMemoryStats</a></p></div><h3><a name="VIR_NODE_MEMORY_STATS_FREE" id="VIR_NODE_MEMORY_STATS_FREE"><code>VIR_NODE_MEMORY_STATS_FREE</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_MEMORY_STATS_FREE</pre><div class="description"><p>Macro for the free memory of specified cell: On Linux, it includes buffer and cached memory, in case of <a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_ALL_CELLS">VIR_NODE_MEMORY_STATS_ALL_CELLS</a>.</p></div><h3><a name="VIR_NODE_MEMORY_STATS_TOTAL" id="VIR_NODE_MEMORY_STATS_TOTAL"><code>VIR_NODE_MEMORY_STATS_TOTAL</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_NODE_MEMORY_STATS_TOTAL</pre><div class="description"><p>Macro for the total memory of specified cell: it represents the maximum memory.</p></div><h3><a name="VIR_SECURITY_DOI_BUFLEN" id="VIR_SECURITY_DOI_BUFLEN"><code>VIR_SECURITY_DOI_BUFLEN</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_SECURITY_DOI_BUFLEN</pre><div class="description"><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> doi string.</p></div><h3><a name="VIR_SECURITY_LABEL_BUFLEN" id="VIR_SECURITY_LABEL_BUFLEN"><code>VIR_SECURITY_LABEL_BUFLEN</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_SECURITY_LABEL_BUFLEN</pre><div class="description"><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> label string. Note that this value is based on that used by Labeled NFS.</p></div><h3><a name="VIR_SECURITY_MODEL_BUFLEN" id="VIR_SECURITY_MODEL_BUFLEN"><code>VIR_SECURITY_MODEL_BUFLEN</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_SECURITY_MODEL_BUFLEN</pre><div class="description"><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> model string.</p></div><h3><a name="VIR_TYPED_PARAM_FIELD_LENGTH" id="VIR_TYPED_PARAM_FIELD_LENGTH"><code>VIR_TYPED_PARAM_FIELD_LENGTH</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_TYPED_PARAM_FIELD_LENGTH</pre><div class="description"><p>Macro providing the field length of <a href="libvirt-libvirt.html#virTypedParameter">virTypedParameter</a> name</p></div><h3><a name="VIR_UNUSE_CPU" id="VIR_UNUSE_CPU"><code>VIR_UNUSE_CPU</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_UNUSE_CPU</pre><div class="description"><p>This macro is to be used in conjunction with <a href="libvirt-libvirt.html#virDomainPinVcpu">virDomainPinVcpu</a>() API. It resets the bit (CPU not usable) of the related cpu in cpumap.</p></div><h3><a name="VIR_USE_CPU" id="VIR_USE_CPU"><code>VIR_USE_CPU</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_USE_CPU</pre><div class="description"><p>This macro is to be used in conjunction with <a href="libvirt-libvirt.html#virDomainPinVcpu">virDomainPinVcpu</a>() API. It sets the bit (CPU usable) of the related cpu in cpumap.</p></div><h3><a name="VIR_UUID_BUFLEN" id="VIR_UUID_BUFLEN"><code>VIR_UUID_BUFLEN</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_UUID_BUFLEN</pre><div class="description"><p>This macro provides the length of the buffer required for <a href="libvirt-libvirt.html#virDomainGetUUID">virDomainGetUUID</a>()</p></div><h3><a name="VIR_UUID_STRING_BUFLEN" id="VIR_UUID_STRING_BUFLEN"><code>VIR_UUID_STRING_BUFLEN</code></a></h3><pre class="api"><span class="directive">#define</span> VIR_UUID_STRING_BUFLEN</pre><div class="description"><p>This macro provides the length of the buffer required for <a href="libvirt-libvirt.html#virDomainGetUUIDString">virDomainGetUUIDString</a>()</p></div><h3><a name="_virBlkioParameter" id="_virBlkioParameter"><code>_virBlkioParameter</code></a></h3><pre class="api"><span class="directive">#define</span> _virBlkioParameter</pre><div class="description"></div><h3><a name="_virMemoryParameter" id="_virMemoryParameter"><code>_virMemoryParameter</code></a></h3><pre class="api"><span class="directive">#define</span> _virMemoryParameter</pre><div class="description"></div><h3><a name="_virSchedParameter" id="_virSchedParameter"><code>_virSchedParameter</code></a></h3><pre class="api"><span class="directive">#define</span> _virSchedParameter</pre><div class="description"></div><h3><a name="types" id="types">Types</a></h3><h3><a name="virBlkioParameter" id="virBlkioParameter"><code>virBlkioParameter</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virBlkioParameter {
</pre><table><tr><td><span class="type">char field[VIR_TYPED_PARAM_FIELD_LENGTH]</span></td><td>field</td><td><div class="comment">parameter name</div></td></tr><tr><td><span class="type">int</span></td><td>type</td><td><div class="comment">parameter type, <a href="libvirt-libvirt.html#virTypedParameterType">virTypedParameterType</a></div></td></tr><tr><td><span class="keyword">union</span> {</td></tr><tr><td><table><tr><td><span class="type">int</span></td><td>i</td><td><div class="comment">type is INT</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>ui</td><td><div class="comment">type is UINT</div></td></tr><tr><td><span class="type">long long int</span></td><td>l</td><td><div class="comment">type is LLONG</div></td></tr><tr><td><span class="type">unsigned long long int</span></td><td>ul</td><td><div class="comment">type is ULLONG</div></td></tr><tr><td><span class="type">double</span></td><td>d</td><td><div class="comment">type is DOUBLE</div></td></tr><tr><td><span class="type">char</span></td><td>b</td><td><div class="comment">type is BOOLEAN</div></td></tr><tr><td><span class="type">char *</span></td><td>s</td><td><div class="comment">type is STRING, may not be NULL</div></td></tr></table></td><td></td></tr><tr><td>}</td><td>value</td><td><div class="comment">parameter value</div></td><td></td></tr></table><pre>
}
</pre></div><h3><a name="virBlkioParameterType" id="virBlkioParameterType"><code>virBlkioParameterType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virBlkioParameterType {
</pre><table><tr><td><a name="VIR_DOMAIN_BLKIO_PARAM_BOOLEAN" id="VIR_DOMAIN_BLKIO_PARAM_BOOLEAN">VIR_DOMAIN_BLKIO_PARAM_BOOLEAN</a></td><td> = </td><td>VIR_TYPED_PARAM_BOOLEAN</td></tr><tr><td><a name="VIR_DOMAIN_BLKIO_PARAM_DOUBLE" id="VIR_DOMAIN_BLKIO_PARAM_DOUBLE">VIR_DOMAIN_BLKIO_PARAM_DOUBLE</a></td><td> = </td><td>VIR_TYPED_PARAM_DOUBLE</td></tr><tr><td><a name="VIR_DOMAIN_BLKIO_PARAM_INT" id="VIR_DOMAIN_BLKIO_PARAM_INT">VIR_DOMAIN_BLKIO_PARAM_INT</a></td><td> = </td><td>VIR_TYPED_PARAM_INT</td></tr><tr><td><a name="VIR_DOMAIN_BLKIO_PARAM_LLONG" id="VIR_DOMAIN_BLKIO_PARAM_LLONG">VIR_DOMAIN_BLKIO_PARAM_LLONG</a></td><td> = </td><td>VIR_TYPED_PARAM_LLONG</td></tr><tr><td><a name="VIR_DOMAIN_BLKIO_PARAM_UINT" id="VIR_DOMAIN_BLKIO_PARAM_UINT">VIR_DOMAIN_BLKIO_PARAM_UINT</a></td><td> = </td><td>VIR_TYPED_PARAM_UINT</td></tr><tr><td><a name="VIR_DOMAIN_BLKIO_PARAM_ULLONG" id="VIR_DOMAIN_BLKIO_PARAM_ULLONG">VIR_DOMAIN_BLKIO_PARAM_ULLONG</a></td><td> = </td><td>VIR_TYPED_PARAM_ULLONG</td></tr></table><pre>}
</pre></div><h3><a name="virCPUCompareResult" id="virCPUCompareResult"><code>virCPUCompareResult</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virCPUCompareResult {
</pre><table><tr><td><a name="VIR_CPU_COMPARE_ERROR" id="VIR_CPU_COMPARE_ERROR">VIR_CPU_COMPARE_ERROR</a></td><td> = </td><td>-1</td></tr><tr><td><a name="VIR_CPU_COMPARE_INCOMPATIBLE" id="VIR_CPU_COMPARE_INCOMPATIBLE">VIR_CPU_COMPARE_INCOMPATIBLE</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_CPU_COMPARE_IDENTICAL" id="VIR_CPU_COMPARE_IDENTICAL">VIR_CPU_COMPARE_IDENTICAL</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_CPU_COMPARE_SUPERSET" id="VIR_CPU_COMPARE_SUPERSET">VIR_CPU_COMPARE_SUPERSET</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_CPU_COMPARE_LAST" id="VIR_CPU_COMPARE_LAST">VIR_CPU_COMPARE_LAST</a></td><td> = </td><td>3</td></tr></table><pre>}
</pre></div><h3><a name="virConnect" id="virConnect"><code>virConnect</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virConnect {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virConnectAuth" id="virConnectAuth"><code>virConnectAuth</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virConnectAuth {
</pre><table><tr><td><span class="type">int *</span></td><td>credtype</td><td><div class="comment">List of supported <a href="libvirt-libvirt.html#virConnectCredentialType">virConnectCredentialType</a> values</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>ncredtype</td></tr><tr><td><span class="type"><a href="libvirt-libvirt.html#virConnectAuthCallbackPtr">virConnectAuthCallbackPtr</a></span></td><td>cb</td><td><div class="comment">Callback used to collect credentials</div></td></tr><tr><td><span class="type">void *</span></td><td>cbdata</td></tr></table><pre>
}
</pre></div><h3><a name="virConnectBaselineCPUFlags" id="virConnectBaselineCPUFlags"><code>virConnectBaselineCPUFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectBaselineCPUFlags {
</pre><table><tr><td><a name="VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES" id="VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES">VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES</a></td><td> = </td><td>1</td><td><div class="comment">show all features</div></td></tr></table><pre>}
</pre></div><h3><a name="virConnectCloseReason" id="virConnectCloseReason"><code>virConnectCloseReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectCloseReason {
</pre><table><tr><td><a name="VIR_CONNECT_CLOSE_REASON_ERROR" id="VIR_CONNECT_CLOSE_REASON_ERROR">VIR_CONNECT_CLOSE_REASON_ERROR</a></td><td> = </td><td>0</td><td><div class="comment">Misc I/O error</div></td></tr><tr><td><a name="VIR_CONNECT_CLOSE_REASON_EOF" id="VIR_CONNECT_CLOSE_REASON_EOF">VIR_CONNECT_CLOSE_REASON_EOF</a></td><td> = </td><td>1</td><td><div class="comment">End-of-file from server</div></td></tr><tr><td><a name="VIR_CONNECT_CLOSE_REASON_KEEPALIVE" id="VIR_CONNECT_CLOSE_REASON_KEEPALIVE">VIR_CONNECT_CLOSE_REASON_KEEPALIVE</a></td><td> = </td><td>2</td><td><div class="comment">Keepalive timer triggered</div></td></tr><tr><td><a name="VIR_CONNECT_CLOSE_REASON_CLIENT" id="VIR_CONNECT_CLOSE_REASON_CLIENT">VIR_CONNECT_CLOSE_REASON_CLIENT</a></td><td> = </td><td>3</td><td><div class="comment">Client requested it</div></td></tr><tr><td><a name="VIR_CONNECT_CLOSE_REASON_LAST" id="VIR_CONNECT_CLOSE_REASON_LAST">VIR_CONNECT_CLOSE_REASON_LAST</a></td><td> = </td><td>4</td></tr></table><pre>}
</pre></div><h3><a name="virConnectCredential" id="virConnectCredential"><code>virConnectCredential</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virConnectCredential {
</pre><table><tr><td><span class="type">int</span></td><td>type</td><td><div class="comment">One of <a href="libvirt-libvirt.html#virConnectCredentialType">virConnectCredentialType</a> constants</div></td></tr><tr><td><span class="type">const char *</span></td><td>prompt</td><td><div class="comment">Prompt to show to user</div></td></tr><tr><td><span class="type">const char *</span></td><td>challenge</td><td><div class="comment">Additional challenge to show</div></td></tr><tr><td><span class="type">const char *</span></td><td>defresult</td><td><div class="comment">Optional default result</div></td></tr><tr><td><span class="type">char *</span></td><td>result</td><td><div class="comment">Result to be filled with user response (or defresult)</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>resultlen</td><td><div class="comment">Length of the result</div></td></tr></table><pre>
}
</pre></div><h3><a name="virConnectCredentialType" id="virConnectCredentialType"><code>virConnectCredentialType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectCredentialType {
</pre><table><tr><td><a name="VIR_CRED_USERNAME" id="VIR_CRED_USERNAME">VIR_CRED_USERNAME</a></td><td> = </td><td>1</td><td><div class="comment">Identity to act as</div></td></tr><tr><td><a name="VIR_CRED_AUTHNAME" id="VIR_CRED_AUTHNAME">VIR_CRED_AUTHNAME</a></td><td> = </td><td>2</td><td><div class="comment">Identify to authorize as</div></td></tr><tr><td><a name="VIR_CRED_LANGUAGE" id="VIR_CRED_LANGUAGE">VIR_CRED_LANGUAGE</a></td><td> = </td><td>3</td><td><div class="comment">RFC 1766 languages, comma separated</div></td></tr><tr><td><a name="VIR_CRED_CNONCE" id="VIR_CRED_CNONCE">VIR_CRED_CNONCE</a></td><td> = </td><td>4</td><td><div class="comment">client supplies a nonce</div></td></tr><tr><td><a name="VIR_CRED_PASSPHRASE" id="VIR_CRED_PASSPHRASE">VIR_CRED_PASSPHRASE</a></td><td> = </td><td>5</td><td><div class="comment">Passphrase secret</div></td></tr><tr><td><a name="VIR_CRED_ECHOPROMPT" id="VIR_CRED_ECHOPROMPT">VIR_CRED_ECHOPROMPT</a></td><td> = </td><td>6</td><td><div class="comment">Challenge response</div></td></tr><tr><td><a name="VIR_CRED_NOECHOPROMPT" id="VIR_CRED_NOECHOPROMPT">VIR_CRED_NOECHOPROMPT</a></td><td> = </td><td>7</td><td><div class="comment">Challenge response</div></td></tr><tr><td><a name="VIR_CRED_REALM" id="VIR_CRED_REALM">VIR_CRED_REALM</a></td><td> = </td><td>8</td><td><div class="comment">Authentication realm</div></td></tr><tr><td><a name="VIR_CRED_EXTERNAL" id="VIR_CRED_EXTERNAL">VIR_CRED_EXTERNAL</a></td><td> = </td><td>9</td><td><div class="comment">Externally managed credential</div></td></tr><tr><td><a name="VIR_CRED_LAST" id="VIR_CRED_LAST">VIR_CRED_LAST</a></td><td> = </td><td>10</td><td><div class="comment">More may be added - expect the unexpected</div></td></tr></table><pre>}
</pre></div><h3><a name="virConnectDomainEventBlockJobStatus" id="virConnectDomainEventBlockJobStatus"><code>virConnectDomainEventBlockJobStatus</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectDomainEventBlockJobStatus {
</pre><table><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_COMPLETED" id="VIR_DOMAIN_BLOCK_JOB_COMPLETED">VIR_DOMAIN_BLOCK_JOB_COMPLETED</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_FAILED" id="VIR_DOMAIN_BLOCK_JOB_FAILED">VIR_DOMAIN_BLOCK_JOB_FAILED</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_CANCELED" id="VIR_DOMAIN_BLOCK_JOB_CANCELED">VIR_DOMAIN_BLOCK_JOB_CANCELED</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_READY" id="VIR_DOMAIN_BLOCK_JOB_READY">VIR_DOMAIN_BLOCK_JOB_READY</a></td><td> = </td><td>3</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_LAST" id="VIR_DOMAIN_BLOCK_JOB_LAST">VIR_DOMAIN_BLOCK_JOB_LAST</a></td><td> = </td><td>4</td></tr></table><pre>}
</pre></div><h3><a name="virConnectDomainEventDiskChangeReason" id="virConnectDomainEventDiskChangeReason"><code>virConnectDomainEventDiskChangeReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectDomainEventDiskChangeReason {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START" id="VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START">VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START</a></td><td> = </td><td>0</td><td><div class="comment">oldSrcPath is set</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START" id="VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START">VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_DISK_CHANGE_LAST" id="VIR_DOMAIN_EVENT_DISK_CHANGE_LAST">VIR_DOMAIN_EVENT_DISK_CHANGE_LAST</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virConnectFlags" id="virConnectFlags"><code>virConnectFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectFlags {
</pre><table><tr><td><a name="VIR_CONNECT_RO" id="VIR_CONNECT_RO">VIR_CONNECT_RO</a></td><td> = </td><td>1</td><td><div class="comment">A readonly connection</div></td></tr><tr><td><a name="VIR_CONNECT_NO_ALIASES" id="VIR_CONNECT_NO_ALIASES">VIR_CONNECT_NO_ALIASES</a></td><td> = </td><td>2</td><td><div class="comment">Don't try to resolve URI aliases</div></td></tr></table><pre>}
</pre></div><h3><a name="virConnectListAllDomainsFlags" id="virConnectListAllDomainsFlags"><code>virConnectListAllDomainsFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectListAllDomainsFlags {
</pre><table><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_ACTIVE" id="VIR_CONNECT_LIST_DOMAINS_ACTIVE">VIR_CONNECT_LIST_DOMAINS_ACTIVE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_INACTIVE" id="VIR_CONNECT_LIST_DOMAINS_INACTIVE">VIR_CONNECT_LIST_DOMAINS_INACTIVE</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_PERSISTENT" id="VIR_CONNECT_LIST_DOMAINS_PERSISTENT">VIR_CONNECT_LIST_DOMAINS_PERSISTENT</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_TRANSIENT" id="VIR_CONNECT_LIST_DOMAINS_TRANSIENT">VIR_CONNECT_LIST_DOMAINS_TRANSIENT</a></td><td> = </td><td>8</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_RUNNING" id="VIR_CONNECT_LIST_DOMAINS_RUNNING">VIR_CONNECT_LIST_DOMAINS_RUNNING</a></td><td> = </td><td>16</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_PAUSED" id="VIR_CONNECT_LIST_DOMAINS_PAUSED">VIR_CONNECT_LIST_DOMAINS_PAUSED</a></td><td> = </td><td>32</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_SHUTOFF" id="VIR_CONNECT_LIST_DOMAINS_SHUTOFF">VIR_CONNECT_LIST_DOMAINS_SHUTOFF</a></td><td> = </td><td>64</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_OTHER" id="VIR_CONNECT_LIST_DOMAINS_OTHER">VIR_CONNECT_LIST_DOMAINS_OTHER</a></td><td> = </td><td>128</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE" id="VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE</a></td><td> = </td><td>256</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE" id="VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE</a></td><td> = </td><td>512</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_AUTOSTART" id="VIR_CONNECT_LIST_DOMAINS_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_AUTOSTART</a></td><td> = </td><td>1024</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART" id="VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART</a></td><td> = </td><td>2048</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT" id="VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT">VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT</a></td><td> = </td><td>4096</td></tr><tr><td><a name="VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT" id="VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT">VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT</a></td><td> = </td><td>8192</td></tr></table><pre>}
</pre></div><h3><a name="virConnectListAllInterfacesFlags" id="virConnectListAllInterfacesFlags"><code>virConnectListAllInterfacesFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectListAllInterfacesFlags {
</pre><table><tr><td><a name="VIR_CONNECT_LIST_INTERFACES_INACTIVE" id="VIR_CONNECT_LIST_INTERFACES_INACTIVE">VIR_CONNECT_LIST_INTERFACES_INACTIVE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_CONNECT_LIST_INTERFACES_ACTIVE" id="VIR_CONNECT_LIST_INTERFACES_ACTIVE">VIR_CONNECT_LIST_INTERFACES_ACTIVE</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virConnectListAllNetworksFlags" id="virConnectListAllNetworksFlags"><code>virConnectListAllNetworksFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectListAllNetworksFlags {
</pre><table><tr><td><a name="VIR_CONNECT_LIST_NETWORKS_INACTIVE" id="VIR_CONNECT_LIST_NETWORKS_INACTIVE">VIR_CONNECT_LIST_NETWORKS_INACTIVE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_CONNECT_LIST_NETWORKS_ACTIVE" id="VIR_CONNECT_LIST_NETWORKS_ACTIVE">VIR_CONNECT_LIST_NETWORKS_ACTIVE</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_CONNECT_LIST_NETWORKS_PERSISTENT" id="VIR_CONNECT_LIST_NETWORKS_PERSISTENT">VIR_CONNECT_LIST_NETWORKS_PERSISTENT</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_CONNECT_LIST_NETWORKS_TRANSIENT" id="VIR_CONNECT_LIST_NETWORKS_TRANSIENT">VIR_CONNECT_LIST_NETWORKS_TRANSIENT</a></td><td> = </td><td>8</td></tr><tr><td><a name="VIR_CONNECT_LIST_NETWORKS_AUTOSTART" id="VIR_CONNECT_LIST_NETWORKS_AUTOSTART">VIR_CONNECT_LIST_NETWORKS_AUTOSTART</a></td><td> = </td><td>16</td></tr><tr><td><a name="VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART" id="VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART">VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART</a></td><td> = </td><td>32</td></tr></table><pre>}
</pre></div><h3><a name="virConnectListAllNodeDeviceFlags" id="virConnectListAllNodeDeviceFlags"><code>virConnectListAllNodeDeviceFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectListAllNodeDeviceFlags {
</pre><table><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM</a></td><td> = </td><td>1</td><td><div class="comment">System capability</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV</a></td><td> = </td><td>2</td><td><div class="comment">PCI device</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV</a></td><td> = </td><td>4</td><td><div class="comment">USB device</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE">VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE</a></td><td> = </td><td>8</td><td><div class="comment">USB interface</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET">VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET</a></td><td> = </td><td>16</td><td><div class="comment">Network device</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST</a></td><td> = </td><td>32</td><td><div class="comment">SCSI Host Bus Adapter</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET</a></td><td> = </td><td>64</td><td><div class="comment">SCSI Target</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI</a></td><td> = </td><td>128</td><td><div class="comment">SCSI device</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE">VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE</a></td><td> = </td><td>256</td><td><div class="comment">Storage device</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST">VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST</a></td><td> = </td><td>512</td><td><div class="comment">FC Host Bus Adapter</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS">VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS</a></td><td> = </td><td>1024</td><td><div class="comment">Capable of vport</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC" id="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC</a></td><td> = </td><td>2048</td><td><div class="comment">Capable of scsi_generic</div></td></tr></table><pre>}
</pre></div><h3><a name="virConnectListAllSecretsFlags" id="virConnectListAllSecretsFlags"><code>virConnectListAllSecretsFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectListAllSecretsFlags {
</pre><table><tr><td><a name="VIR_CONNECT_LIST_SECRETS_EPHEMERAL" id="VIR_CONNECT_LIST_SECRETS_EPHEMERAL">VIR_CONNECT_LIST_SECRETS_EPHEMERAL</a></td><td> = </td><td>1</td><td><div class="comment">kept in memory, never stored persistently</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL" id="VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL">VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_CONNECT_LIST_SECRETS_PRIVATE" id="VIR_CONNECT_LIST_SECRETS_PRIVATE">VIR_CONNECT_LIST_SECRETS_PRIVATE</a></td><td> = </td><td>4</td><td><div class="comment">not revealed to any caller of libvirt, nor to any other node</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_SECRETS_NO_PRIVATE" id="VIR_CONNECT_LIST_SECRETS_NO_PRIVATE">VIR_CONNECT_LIST_SECRETS_NO_PRIVATE</a></td><td> = </td><td>8</td></tr></table><pre>}
</pre></div><h3><a name="virConnectListAllStoragePoolsFlags" id="virConnectListAllStoragePoolsFlags"><code>virConnectListAllStoragePoolsFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virConnectListAllStoragePoolsFlags {
</pre><table><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE" id="VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE">VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE" id="VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE">VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT" id="VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT">VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT" id="VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT">VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT</a></td><td> = </td><td>8</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART" id="VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART">VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART</a></td><td> = </td><td>16</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART" id="VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART">VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART</a></td><td> = </td><td>32</td><td><div class="comment">List pools by type</div></td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_DIR" id="VIR_CONNECT_LIST_STORAGE_POOLS_DIR">VIR_CONNECT_LIST_STORAGE_POOLS_DIR</a></td><td> = </td><td>64</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_FS" id="VIR_CONNECT_LIST_STORAGE_POOLS_FS">VIR_CONNECT_LIST_STORAGE_POOLS_FS</a></td><td> = </td><td>128</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_NETFS" id="VIR_CONNECT_LIST_STORAGE_POOLS_NETFS">VIR_CONNECT_LIST_STORAGE_POOLS_NETFS</a></td><td> = </td><td>256</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL" id="VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL">VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL</a></td><td> = </td><td>512</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_DISK" id="VIR_CONNECT_LIST_STORAGE_POOLS_DISK">VIR_CONNECT_LIST_STORAGE_POOLS_DISK</a></td><td> = </td><td>1024</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI" id="VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI">VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI</a></td><td> = </td><td>2048</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_SCSI" id="VIR_CONNECT_LIST_STORAGE_POOLS_SCSI">VIR_CONNECT_LIST_STORAGE_POOLS_SCSI</a></td><td> = </td><td>4096</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_MPATH" id="VIR_CONNECT_LIST_STORAGE_POOLS_MPATH">VIR_CONNECT_LIST_STORAGE_POOLS_MPATH</a></td><td> = </td><td>8192</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_RBD" id="VIR_CONNECT_LIST_STORAGE_POOLS_RBD">VIR_CONNECT_LIST_STORAGE_POOLS_RBD</a></td><td> = </td><td>16384</td></tr><tr><td><a name="VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG" id="VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG">VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG</a></td><td> = </td><td>32768</td></tr></table><pre>}
</pre></div><h3><a name="virDomain" id="virDomain"><code>virDomain</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomain {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virDomainBlockCommitFlags" id="virDomainBlockCommitFlags"><code>virDomainBlockCommitFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainBlockCommitFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_BLOCK_COMMIT_SHALLOW" id="VIR_DOMAIN_BLOCK_COMMIT_SHALLOW">VIR_DOMAIN_BLOCK_COMMIT_SHALLOW</a></td><td> = </td><td>1</td><td><div class="comment">NULL base means next backing file, not whole chain</div></td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_COMMIT_DELETE" id="VIR_DOMAIN_BLOCK_COMMIT_DELETE">VIR_DOMAIN_BLOCK_COMMIT_DELETE</a></td><td> = </td><td>2</td><td><div class="comment">Delete any files that are now invalid after their contents have been committed</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainBlockInfo" id="virDomainBlockInfo"><code>virDomainBlockInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainBlockInfo {
</pre><table><tr><td><span class="type">unsigned long long</span></td><td>capacity</td><td><div class="comment">logical size in bytes of the block device backing image</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>allocation</td><td><div class="comment">highest allocated extent in bytes of the block device backing image</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>physical</td><td><div class="comment">physical size in bytes of the container of the backing image</div></td></tr></table><pre>
}
</pre></div><h3><a name="virDomainBlockJobAbortFlags" id="virDomainBlockJobAbortFlags"><code>virDomainBlockJobAbortFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainBlockJobAbortFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC" id="VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC">VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT" id="VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT">VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virDomainBlockJobInfo" id="virDomainBlockJobInfo"><code>virDomainBlockJobInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainBlockJobInfo {
</pre><table><tr><td><span class="type"><a href="libvirt-libvirt.html#virDomainBlockJobType">virDomainBlockJobType</a></span></td><td>type</td></tr><tr><td><span class="type">unsigned long</span></td><td>bandwidth</td><td><div class="comment">The following fields provide an indication of block job progress. @cur indicates the current position and will be between 0 and @end. @end is the final cursor position for this operation and represents completion. To approximate progress, divide @cur by @end.</div></td></tr><tr><td><span class="type"><a href="libvirt-libvirt.html#virDomainBlockJobCursor">virDomainBlockJobCursor</a></span></td><td>cur</td></tr><tr><td><span class="type"><a href="libvirt-libvirt.html#virDomainBlockJobCursor">virDomainBlockJobCursor</a></span></td><td>end</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainBlockJobType" id="virDomainBlockJobType"><code>virDomainBlockJobType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainBlockJobType {
</pre><table><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN" id="VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN">VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_TYPE_PULL" id="VIR_DOMAIN_BLOCK_JOB_TYPE_PULL">VIR_DOMAIN_BLOCK_JOB_TYPE_PULL</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_TYPE_COPY" id="VIR_DOMAIN_BLOCK_JOB_TYPE_COPY">VIR_DOMAIN_BLOCK_JOB_TYPE_COPY</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT" id="VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT">VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT</a></td><td> = </td><td>3</td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_JOB_TYPE_LAST" id="VIR_DOMAIN_BLOCK_JOB_TYPE_LAST">VIR_DOMAIN_BLOCK_JOB_TYPE_LAST</a></td><td> = </td><td>4</td></tr></table><pre>}
</pre></div><h3><a name="virDomainBlockRebaseFlags" id="virDomainBlockRebaseFlags"><code>virDomainBlockRebaseFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainBlockRebaseFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_BLOCK_REBASE_SHALLOW" id="VIR_DOMAIN_BLOCK_REBASE_SHALLOW">VIR_DOMAIN_BLOCK_REBASE_SHALLOW</a></td><td> = </td><td>1</td><td><div class="comment">Limit copy to top of source backing chain</div></td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT" id="VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT">VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT</a></td><td> = </td><td>2</td><td><div class="comment">Reuse existing external file for a copy</div></td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_REBASE_COPY_RAW" id="VIR_DOMAIN_BLOCK_REBASE_COPY_RAW">VIR_DOMAIN_BLOCK_REBASE_COPY_RAW</a></td><td> = </td><td>4</td><td><div class="comment">Make destination file raw</div></td></tr><tr><td><a name="VIR_DOMAIN_BLOCK_REBASE_COPY" id="VIR_DOMAIN_BLOCK_REBASE_COPY">VIR_DOMAIN_BLOCK_REBASE_COPY</a></td><td> = </td><td>8</td><td><div class="comment">Start a copy job</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainBlockResizeFlags" id="virDomainBlockResizeFlags"><code>virDomainBlockResizeFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainBlockResizeFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_BLOCK_RESIZE_BYTES" id="VIR_DOMAIN_BLOCK_RESIZE_BYTES">VIR_DOMAIN_BLOCK_RESIZE_BYTES</a></td><td> = </td><td>1</td><td><div class="comment">size in bytes instead of KiB</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainBlockStatsStruct" id="virDomainBlockStatsStruct"><code>virDomainBlockStatsStruct</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainBlockStatsStruct {
</pre><table><tr><td><span class="type">long long</span></td><td>rd_req</td><td><div class="comment">number of read requests</div></td></tr><tr><td><span class="type">long long</span></td><td>rd_bytes</td><td><div class="comment">number of read bytes</div></td></tr><tr><td><span class="type">long long</span></td><td>wr_req</td><td><div class="comment">number of write requests</div></td></tr><tr><td><span class="type">long long</span></td><td>wr_bytes</td><td><div class="comment">number of written bytes</div></td></tr><tr><td><span class="type">long long</span></td><td>errs</td><td><div class="comment">In Xen this returns the mysterious 'oo_req'.</div></td></tr></table><pre>
}
</pre></div><h3><a name="virDomainBlockedReason" id="virDomainBlockedReason"><code>virDomainBlockedReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainBlockedReason {
</pre><table><tr><td><a name="VIR_DOMAIN_BLOCKED_UNKNOWN" id="VIR_DOMAIN_BLOCKED_UNKNOWN">VIR_DOMAIN_BLOCKED_UNKNOWN</a></td><td> = </td><td>0</td><td><div class="comment">the reason is unknown</div></td></tr><tr><td><a name="VIR_DOMAIN_BLOCKED_LAST" id="VIR_DOMAIN_BLOCKED_LAST">VIR_DOMAIN_BLOCKED_LAST</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainChannelFlags" id="virDomainChannelFlags"><code>virDomainChannelFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainChannelFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_CHANNEL_FORCE" id="VIR_DOMAIN_CHANNEL_FORCE">VIR_DOMAIN_CHANNEL_FORCE</a></td><td> = </td><td>1</td><td><div class="comment">abort a (possibly) active channel connection to force a new connection</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainConsoleFlags" id="virDomainConsoleFlags"><code>virDomainConsoleFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainConsoleFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_CONSOLE_FORCE" id="VIR_DOMAIN_CONSOLE_FORCE">VIR_DOMAIN_CONSOLE_FORCE</a></td><td> = </td><td>1</td><td><div class="comment">abort a (possibly) active console connection to force a new connection</div></td></tr><tr><td><a name="VIR_DOMAIN_CONSOLE_SAFE" id="VIR_DOMAIN_CONSOLE_SAFE">VIR_DOMAIN_CONSOLE_SAFE</a></td><td> = </td><td>2</td><td><div class="comment">check if the console driver supports safe console operations</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainControlInfo" id="virDomainControlInfo"><code>virDomainControlInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainControlInfo {
</pre><table><tr><td><span class="type">unsigned int</span></td><td>state</td><td><div class="comment">control state, one of <a href="libvirt-libvirt.html#virDomainControlState">virDomainControlState</a></div></td></tr><tr><td><span class="type">unsigned int</span></td><td>details</td><td><div class="comment">state details, currently 0</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>stateTime</td><td><div class="comment">for how long (in msec) control interface has been in current state (except for OK and ERROR states)</div></td></tr></table><pre>
}
</pre></div><h3><a name="virDomainControlState" id="virDomainControlState"><code>virDomainControlState</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainControlState {
</pre><table><tr><td><a name="VIR_DOMAIN_CONTROL_OK" id="VIR_DOMAIN_CONTROL_OK">VIR_DOMAIN_CONTROL_OK</a></td><td> = </td><td>0</td><td><div class="comment">operational, ready to accept commands</div></td></tr><tr><td><a name="VIR_DOMAIN_CONTROL_JOB" id="VIR_DOMAIN_CONTROL_JOB">VIR_DOMAIN_CONTROL_JOB</a></td><td> = </td><td>1</td><td><div class="comment">background job is running (can be monitored by <a href="libvirt-libvirt.html#virDomainGetJobInfo">virDomainGetJobInfo</a>); only limited set of commands may be allowed</div></td></tr><tr><td><a name="VIR_DOMAIN_CONTROL_OCCUPIED" id="VIR_DOMAIN_CONTROL_OCCUPIED">VIR_DOMAIN_CONTROL_OCCUPIED</a></td><td> = </td><td>2</td><td><div class="comment">occupied by a running command</div></td></tr><tr><td><a name="VIR_DOMAIN_CONTROL_ERROR" id="VIR_DOMAIN_CONTROL_ERROR">VIR_DOMAIN_CONTROL_ERROR</a></td><td> = </td><td>3</td><td><div class="comment">unusable, domain cannot be fully operated</div></td></tr><tr><td><a name="VIR_DOMAIN_CONTROL_LAST" id="VIR_DOMAIN_CONTROL_LAST">VIR_DOMAIN_CONTROL_LAST</a></td><td> = </td><td>4</td></tr></table><pre>}
</pre></div><h3><a name="virDomainCoreDumpFlags" id="virDomainCoreDumpFlags"><code>virDomainCoreDumpFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainCoreDumpFlags {
</pre><table><tr><td><a name="VIR_DUMP_CRASH" id="VIR_DUMP_CRASH">VIR_DUMP_CRASH</a></td><td> = </td><td>1</td><td><div class="comment">crash after dump</div></td></tr><tr><td><a name="VIR_DUMP_LIVE" id="VIR_DUMP_LIVE">VIR_DUMP_LIVE</a></td><td> = </td><td>2</td><td><div class="comment">live dump</div></td></tr><tr><td><a name="VIR_DUMP_BYPASS_CACHE" id="VIR_DUMP_BYPASS_CACHE">VIR_DUMP_BYPASS_CACHE</a></td><td> = </td><td>4</td><td><div class="comment">avoid file system cache pollution</div></td></tr><tr><td><a name="VIR_DUMP_RESET" id="VIR_DUMP_RESET">VIR_DUMP_RESET</a></td><td> = </td><td>8</td><td><div class="comment">reset domain after dump finishes</div></td></tr><tr><td><a name="VIR_DUMP_MEMORY_ONLY" id="VIR_DUMP_MEMORY_ONLY">VIR_DUMP_MEMORY_ONLY</a></td><td> = </td><td>16</td><td><div class="comment">use dump-guest-memory</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainCrashedReason" id="virDomainCrashedReason"><code>virDomainCrashedReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainCrashedReason {
</pre><table><tr><td><a name="VIR_DOMAIN_CRASHED_UNKNOWN" id="VIR_DOMAIN_CRASHED_UNKNOWN">VIR_DOMAIN_CRASHED_UNKNOWN</a></td><td> = </td><td>0</td><td><div class="comment">crashed for unknown reason</div></td></tr><tr><td><a name="VIR_DOMAIN_CRASHED_PANICKED" id="VIR_DOMAIN_CRASHED_PANICKED">VIR_DOMAIN_CRASHED_PANICKED</a></td><td> = </td><td>1</td><td><div class="comment">domain panicked</div></td></tr><tr><td><a name="VIR_DOMAIN_CRASHED_LAST" id="VIR_DOMAIN_CRASHED_LAST">VIR_DOMAIN_CRASHED_LAST</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virDomainCreateFlags" id="virDomainCreateFlags"><code>virDomainCreateFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainCreateFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_NONE" id="VIR_DOMAIN_NONE">VIR_DOMAIN_NONE</a></td><td> = </td><td>0</td><td><div class="comment">Default behavior</div></td></tr><tr><td><a name="VIR_DOMAIN_START_PAUSED" id="VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a></td><td> = </td><td>1</td><td><div class="comment">Launch guest in paused state</div></td></tr><tr><td><a name="VIR_DOMAIN_START_AUTODESTROY" id="VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a></td><td> = </td><td>2</td><td><div class="comment">Automatically kill guest when <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> is closed</div></td></tr><tr><td><a name="VIR_DOMAIN_START_BYPASS_CACHE" id="VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a></td><td> = </td><td>4</td><td><div class="comment">Avoid file system cache pollution</div></td></tr><tr><td><a name="VIR_DOMAIN_START_FORCE_BOOT" id="VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a></td><td> = </td><td>8</td><td><div class="comment">Boot, discarding any managed save</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainDestroyFlagsValues" id="virDomainDestroyFlagsValues"><code>virDomainDestroyFlagsValues</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainDestroyFlagsValues {
</pre><table><tr><td><a name="VIR_DOMAIN_DESTROY_DEFAULT" id="VIR_DOMAIN_DESTROY_DEFAULT">VIR_DOMAIN_DESTROY_DEFAULT</a></td><td> = </td><td>0</td><td><div class="comment">Default behavior - could lead to data loss!!</div></td></tr><tr><td><a name="VIR_DOMAIN_DESTROY_GRACEFUL" id="VIR_DOMAIN_DESTROY_GRACEFUL">VIR_DOMAIN_DESTROY_GRACEFUL</a></td><td> = </td><td>1</td><td><div class="comment">only SIGTERM, no SIGKILL</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainDeviceModifyFlags" id="virDomainDeviceModifyFlags"><code>virDomainDeviceModifyFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainDeviceModifyFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_DEVICE_MODIFY_CONFIG" id="VIR_DOMAIN_DEVICE_MODIFY_CONFIG">VIR_DOMAIN_DEVICE_MODIFY_CONFIG</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_CONFIG</td><td><div class="comment">Additionally, these flags may be bitwise-OR'd in.</div></td></tr><tr><td><a name="VIR_DOMAIN_DEVICE_MODIFY_CURRENT" id="VIR_DOMAIN_DEVICE_MODIFY_CURRENT">VIR_DOMAIN_DEVICE_MODIFY_CURRENT</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_CURRENT</td></tr><tr><td><a name="VIR_DOMAIN_DEVICE_MODIFY_LIVE" id="VIR_DOMAIN_DEVICE_MODIFY_LIVE">VIR_DOMAIN_DEVICE_MODIFY_LIVE</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_LIVE</td></tr><tr><td><a name="VIR_DOMAIN_DEVICE_MODIFY_FORCE" id="VIR_DOMAIN_DEVICE_MODIFY_FORCE">VIR_DOMAIN_DEVICE_MODIFY_FORCE</a></td><td> = </td><td>4</td><td><div class="comment">Forcibly modify device (ex. force eject a cdrom)</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainDiskError" id="virDomainDiskError"><code>virDomainDiskError</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainDiskError {
</pre><table><tr><td><span class="type">char *</span></td><td>disk</td><td><div class="comment">disk target</div></td></tr><tr><td><span class="type">int</span></td><td>error</td><td><div class="comment"><a href="libvirt-libvirt.html#virDomainDiskErrorCode">virDomainDiskErrorCode</a></div></td></tr></table><pre>
}
</pre></div><h3><a name="virDomainDiskErrorCode" id="virDomainDiskErrorCode"><code>virDomainDiskErrorCode</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainDiskErrorCode {
</pre><table><tr><td><a name="VIR_DOMAIN_DISK_ERROR_NONE" id="VIR_DOMAIN_DISK_ERROR_NONE">VIR_DOMAIN_DISK_ERROR_NONE</a></td><td> = </td><td>0</td><td><div class="comment">no error</div></td></tr><tr><td><a name="VIR_DOMAIN_DISK_ERROR_UNSPEC" id="VIR_DOMAIN_DISK_ERROR_UNSPEC">VIR_DOMAIN_DISK_ERROR_UNSPEC</a></td><td> = </td><td>1</td><td><div class="comment">unspecified I/O error</div></td></tr><tr><td><a name="VIR_DOMAIN_DISK_ERROR_NO_SPACE" id="VIR_DOMAIN_DISK_ERROR_NO_SPACE">VIR_DOMAIN_DISK_ERROR_NO_SPACE</a></td><td> = </td><td>2</td><td><div class="comment">no space left on the device</div></td></tr><tr><td><a name="VIR_DOMAIN_DISK_ERROR_LAST" id="VIR_DOMAIN_DISK_ERROR_LAST">VIR_DOMAIN_DISK_ERROR_LAST</a></td><td> = </td><td>3</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventCrashedDetailType" id="virDomainEventCrashedDetailType"><code>virDomainEventCrashedDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventCrashedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_CRASHED_PANICKED" id="VIR_DOMAIN_EVENT_CRASHED_PANICKED">VIR_DOMAIN_EVENT_CRASHED_PANICKED</a></td><td> = </td><td>0</td><td><div class="comment">Guest was panicked</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_CRASHED_LAST" id="VIR_DOMAIN_EVENT_CRASHED_LAST">VIR_DOMAIN_EVENT_CRASHED_LAST</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventDefinedDetailType" id="virDomainEventDefinedDetailType"><code>virDomainEventDefinedDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventDefinedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_DEFINED_ADDED" id="VIR_DOMAIN_EVENT_DEFINED_ADDED">VIR_DOMAIN_EVENT_DEFINED_ADDED</a></td><td> = </td><td>0</td><td><div class="comment">Newly created config file</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_DEFINED_UPDATED" id="VIR_DOMAIN_EVENT_DEFINED_UPDATED">VIR_DOMAIN_EVENT_DEFINED_UPDATED</a></td><td> = </td><td>1</td><td><div class="comment">Changed config file</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_DEFINED_LAST" id="VIR_DOMAIN_EVENT_DEFINED_LAST">VIR_DOMAIN_EVENT_DEFINED_LAST</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventGraphicsAddress" id="virDomainEventGraphicsAddress"><code>virDomainEventGraphicsAddress</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainEventGraphicsAddress {
</pre><table><tr><td><span class="type">int</span></td><td>family</td><td><div class="comment">Address family, <a href="libvirt-libvirt.html#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a></div></td></tr><tr><td><span class="type">char *</span></td><td>node</td><td><div class="comment">Address of node (eg IP address, or UNIX path)</div></td></tr><tr><td><span class="type">char *</span></td><td>service</td><td><div class="comment">Service name/number (eg TCP port, or NULL)</div></td></tr></table><pre>
}
</pre></div><h3><a name="virDomainEventGraphicsAddressType" id="virDomainEventGraphicsAddressType"><code>virDomainEventGraphicsAddressType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventGraphicsAddressType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4" id="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4</a></td><td> = </td><td>1</td><td><div class="comment">IPv4 address</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6" id="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6</a></td><td> = </td><td>2</td><td><div class="comment">IPv6 address</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX" id="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX</a></td><td> = </td><td>3</td><td><div class="comment">UNIX socket path</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST" id="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST</a></td><td> = </td><td>4</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventGraphicsPhase" id="virDomainEventGraphicsPhase"><code>virDomainEventGraphicsPhase</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventGraphicsPhase {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_CONNECT" id="VIR_DOMAIN_EVENT_GRAPHICS_CONNECT">VIR_DOMAIN_EVENT_GRAPHICS_CONNECT</a></td><td> = </td><td>0</td><td><div class="comment">Initial socket connection established</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE" id="VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE">VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE</a></td><td> = </td><td>1</td><td><div class="comment">Authentication &amp; setup completed</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT" id="VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT">VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT</a></td><td> = </td><td>2</td><td><div class="comment">Final socket disconnection</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_LAST" id="VIR_DOMAIN_EVENT_GRAPHICS_LAST">VIR_DOMAIN_EVENT_GRAPHICS_LAST</a></td><td> = </td><td>3</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventGraphicsSubject" id="virDomainEventGraphicsSubject"><code>virDomainEventGraphicsSubject</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainEventGraphicsSubject {
</pre><table><tr><td><span class="type">int</span></td><td>nidentity</td><td><div class="comment">Number of identities in arra</div></td></tr><tr><td><span class="type"><a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectIdentityPtr">virDomainEventGraphicsSubjectIdentityPtr</a></span></td><td>identities</td><td><div class="comment">Array of identities for subject</div></td></tr></table><pre>
}
</pre></div><h3><a name="virDomainEventGraphicsSubjectIdentity" id="virDomainEventGraphicsSubjectIdentity"><code>virDomainEventGraphicsSubjectIdentity</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainEventGraphicsSubjectIdentity {
</pre><table><tr><td><span class="type">char *</span></td><td>type</td><td><div class="comment">Type of identity</div></td></tr><tr><td><span class="type">char *</span></td><td>name</td><td><div class="comment">Identity value</div></td></tr></table><pre>
}
</pre></div><h3><a name="virDomainEventID" id="virDomainEventID"><code>virDomainEventID</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventID {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_ID_LIFECYCLE" id="VIR_DOMAIN_EVENT_ID_LIFECYCLE">VIR_DOMAIN_EVENT_ID_LIFECYCLE</a></td><td> = </td><td>0</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_REBOOT" id="VIR_DOMAIN_EVENT_ID_REBOOT">VIR_DOMAIN_EVENT_ID_REBOOT</a></td><td> = </td><td>1</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_RTC_CHANGE" id="VIR_DOMAIN_EVENT_ID_RTC_CHANGE">VIR_DOMAIN_EVENT_ID_RTC_CHANGE</a></td><td> = </td><td>2</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventRTCChangeCallback">virConnectDomainEventRTCChangeCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_WATCHDOG" id="VIR_DOMAIN_EVENT_ID_WATCHDOG">VIR_DOMAIN_EVENT_ID_WATCHDOG</a></td><td> = </td><td>3</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventWatchdogCallback">virConnectDomainEventWatchdogCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_IO_ERROR" id="VIR_DOMAIN_EVENT_ID_IO_ERROR">VIR_DOMAIN_EVENT_ID_IO_ERROR</a></td><td> = </td><td>4</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventIOErrorCallback">virConnectDomainEventIOErrorCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_GRAPHICS" id="VIR_DOMAIN_EVENT_ID_GRAPHICS">VIR_DOMAIN_EVENT_ID_GRAPHICS</a></td><td> = </td><td>5</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventGraphicsCallback">virConnectDomainEventGraphicsCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON" id="VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON">VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON</a></td><td> = </td><td>6</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventIOErrorReasonCallback">virConnectDomainEventIOErrorReasonCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_CONTROL_ERROR" id="VIR_DOMAIN_EVENT_ID_CONTROL_ERROR">VIR_DOMAIN_EVENT_ID_CONTROL_ERROR</a></td><td> = </td><td>7</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_BLOCK_JOB" id="VIR_DOMAIN_EVENT_ID_BLOCK_JOB">VIR_DOMAIN_EVENT_ID_BLOCK_JOB</a></td><td> = </td><td>8</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventBlockJobCallback">virConnectDomainEventBlockJobCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_DISK_CHANGE" id="VIR_DOMAIN_EVENT_ID_DISK_CHANGE">VIR_DOMAIN_EVENT_ID_DISK_CHANGE</a></td><td> = </td><td>9</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventDiskChangeCallback">virConnectDomainEventDiskChangeCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_TRAY_CHANGE" id="VIR_DOMAIN_EVENT_ID_TRAY_CHANGE">VIR_DOMAIN_EVENT_ID_TRAY_CHANGE</a></td><td> = </td><td>10</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventTrayChangeCallback">virConnectDomainEventTrayChangeCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_PMWAKEUP" id="VIR_DOMAIN_EVENT_ID_PMWAKEUP">VIR_DOMAIN_EVENT_ID_PMWAKEUP</a></td><td> = </td><td>11</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventPMWakeupCallback">virConnectDomainEventPMWakeupCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_PMSUSPEND" id="VIR_DOMAIN_EVENT_ID_PMSUSPEND">VIR_DOMAIN_EVENT_ID_PMSUSPEND</a></td><td> = </td><td>12</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventPMSuspendCallback">virConnectDomainEventPMSuspendCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE" id="VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE">VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE</a></td><td> = </td><td>13</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventBalloonChangeCallback">virConnectDomainEventBalloonChangeCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK" id="VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK">VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK</a></td><td> = </td><td>14</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventPMSuspendDiskCallback">virConnectDomainEventPMSuspendDiskCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED" id="VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED">VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED</a></td><td> = </td><td>15</td><td><div class="comment"><a href="libvirt-libvirt.html#virConnectDomainEventDeviceRemovedCallback">virConnectDomainEventDeviceRemovedCallback</a></div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_LAST" id="VIR_DOMAIN_EVENT_ID_LAST">VIR_DOMAIN_EVENT_ID_LAST</a></td><td> = </td><td>16</td><td><div class="comment">NB: this enum value will increase over time as new events are added to the libvirt API. It reflects the last event ID supported by this version of the libvirt API.</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventIOErrorAction" id="virDomainEventIOErrorAction"><code>virDomainEventIOErrorAction</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventIOErrorAction {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_IO_ERROR_NONE" id="VIR_DOMAIN_EVENT_IO_ERROR_NONE">VIR_DOMAIN_EVENT_IO_ERROR_NONE</a></td><td> = </td><td>0</td><td><div class="comment">No action, IO error ignored</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_IO_ERROR_PAUSE" id="VIR_DOMAIN_EVENT_IO_ERROR_PAUSE">VIR_DOMAIN_EVENT_IO_ERROR_PAUSE</a></td><td> = </td><td>1</td><td><div class="comment">Guest CPUs are pausde</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_IO_ERROR_REPORT" id="VIR_DOMAIN_EVENT_IO_ERROR_REPORT">VIR_DOMAIN_EVENT_IO_ERROR_REPORT</a></td><td> = </td><td>2</td><td><div class="comment">IO error reported to guest OS</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_IO_ERROR_LAST" id="VIR_DOMAIN_EVENT_IO_ERROR_LAST">VIR_DOMAIN_EVENT_IO_ERROR_LAST</a></td><td> = </td><td>3</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventPMSuspendedDetailType" id="virDomainEventPMSuspendedDetailType"><code>virDomainEventPMSuspendedDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventPMSuspendedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY" id="VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY">VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY</a></td><td> = </td><td>0</td><td><div class="comment">Guest was PM suspended to memory</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_PMSUSPENDED_DISK" id="VIR_DOMAIN_EVENT_PMSUSPENDED_DISK">VIR_DOMAIN_EVENT_PMSUSPENDED_DISK</a></td><td> = </td><td>1</td><td><div class="comment">Guest was PM suspended to disk</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_PMSUSPENDED_LAST" id="VIR_DOMAIN_EVENT_PMSUSPENDED_LAST">VIR_DOMAIN_EVENT_PMSUSPENDED_LAST</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventResumedDetailType" id="virDomainEventResumedDetailType"><code>virDomainEventResumedDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventResumedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_RESUMED_UNPAUSED" id="VIR_DOMAIN_EVENT_RESUMED_UNPAUSED">VIR_DOMAIN_EVENT_RESUMED_UNPAUSED</a></td><td> = </td><td>0</td><td><div class="comment">Normal resume due to admin unpause</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_RESUMED_MIGRATED" id="VIR_DOMAIN_EVENT_RESUMED_MIGRATED">VIR_DOMAIN_EVENT_RESUMED_MIGRATED</a></td><td> = </td><td>1</td><td><div class="comment">Resumed for completion of migration</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT" id="VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT</a></td><td> = </td><td>2</td><td><div class="comment">Resumed from snapshot</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_RESUMED_LAST" id="VIR_DOMAIN_EVENT_RESUMED_LAST">VIR_DOMAIN_EVENT_RESUMED_LAST</a></td><td> = </td><td>3</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventShutdownDetailType" id="virDomainEventShutdownDetailType"><code>virDomainEventShutdownDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventShutdownDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED" id="VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED">VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED</a></td><td> = </td><td>0</td><td><div class="comment">Guest finished shutdown sequence</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SHUTDOWN_LAST" id="VIR_DOMAIN_EVENT_SHUTDOWN_LAST">VIR_DOMAIN_EVENT_SHUTDOWN_LAST</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventStartedDetailType" id="virDomainEventStartedDetailType"><code>virDomainEventStartedDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventStartedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_BOOTED" id="VIR_DOMAIN_EVENT_STARTED_BOOTED">VIR_DOMAIN_EVENT_STARTED_BOOTED</a></td><td> = </td><td>0</td><td><div class="comment">Normal startup from boot</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_MIGRATED" id="VIR_DOMAIN_EVENT_STARTED_MIGRATED">VIR_DOMAIN_EVENT_STARTED_MIGRATED</a></td><td> = </td><td>1</td><td><div class="comment">Incoming migration from another host</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_RESTORED" id="VIR_DOMAIN_EVENT_STARTED_RESTORED">VIR_DOMAIN_EVENT_STARTED_RESTORED</a></td><td> = </td><td>2</td><td><div class="comment">Restored from a state file</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT" id="VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT</a></td><td> = </td><td>3</td><td><div class="comment">Restored from snapshot</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_WAKEUP" id="VIR_DOMAIN_EVENT_STARTED_WAKEUP">VIR_DOMAIN_EVENT_STARTED_WAKEUP</a></td><td> = </td><td>4</td><td><div class="comment">Started due to wakeup event</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_LAST" id="VIR_DOMAIN_EVENT_STARTED_LAST">VIR_DOMAIN_EVENT_STARTED_LAST</a></td><td> = </td><td>5</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventStoppedDetailType" id="virDomainEventStoppedDetailType"><code>virDomainEventStoppedDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventStoppedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN" id="VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN">VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN</a></td><td> = </td><td>0</td><td><div class="comment">Normal shutdown</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_DESTROYED" id="VIR_DOMAIN_EVENT_STOPPED_DESTROYED">VIR_DOMAIN_EVENT_STOPPED_DESTROYED</a></td><td> = </td><td>1</td><td><div class="comment">Forced poweroff from host</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_CRASHED" id="VIR_DOMAIN_EVENT_STOPPED_CRASHED">VIR_DOMAIN_EVENT_STOPPED_CRASHED</a></td><td> = </td><td>2</td><td><div class="comment">Guest crashed</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_MIGRATED" id="VIR_DOMAIN_EVENT_STOPPED_MIGRATED">VIR_DOMAIN_EVENT_STOPPED_MIGRATED</a></td><td> = </td><td>3</td><td><div class="comment">Migrated off to another host</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_SAVED" id="VIR_DOMAIN_EVENT_STOPPED_SAVED">VIR_DOMAIN_EVENT_STOPPED_SAVED</a></td><td> = </td><td>4</td><td><div class="comment">Saved to a state file</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_FAILED" id="VIR_DOMAIN_EVENT_STOPPED_FAILED">VIR_DOMAIN_EVENT_STOPPED_FAILED</a></td><td> = </td><td>5</td><td><div class="comment">Host emulator/mgmt failed</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT" id="VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT</a></td><td> = </td><td>6</td><td><div class="comment">offline snapshot loaded</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_LAST" id="VIR_DOMAIN_EVENT_STOPPED_LAST">VIR_DOMAIN_EVENT_STOPPED_LAST</a></td><td> = </td><td>7</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventSuspendedDetailType" id="virDomainEventSuspendedDetailType"><code>virDomainEventSuspendedDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventSuspendedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_PAUSED" id="VIR_DOMAIN_EVENT_SUSPENDED_PAUSED">VIR_DOMAIN_EVENT_SUSPENDED_PAUSED</a></td><td> = </td><td>0</td><td><div class="comment">Normal suspend due to admin pause</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED" id="VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED">VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED</a></td><td> = </td><td>1</td><td><div class="comment">Suspended for offline migration</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_IOERROR" id="VIR_DOMAIN_EVENT_SUSPENDED_IOERROR">VIR_DOMAIN_EVENT_SUSPENDED_IOERROR</a></td><td> = </td><td>2</td><td><div class="comment">Suspended due to a disk I/O error</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG" id="VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG">VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG</a></td><td> = </td><td>3</td><td><div class="comment">Suspended due to a watchdog firing</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_RESTORED" id="VIR_DOMAIN_EVENT_SUSPENDED_RESTORED">VIR_DOMAIN_EVENT_SUSPENDED_RESTORED</a></td><td> = </td><td>4</td><td><div class="comment">Restored from paused state file</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT" id="VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT</a></td><td> = </td><td>5</td><td><div class="comment">Restored from paused snapshot</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR" id="VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR">VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR</a></td><td> = </td><td>6</td><td><div class="comment">suspended after failure during libvirt API call</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_LAST" id="VIR_DOMAIN_EVENT_SUSPENDED_LAST">VIR_DOMAIN_EVENT_SUSPENDED_LAST</a></td><td> = </td><td>7</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventTrayChangeReason" id="virDomainEventTrayChangeReason"><code>virDomainEventTrayChangeReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventTrayChangeReason {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN" id="VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN">VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE" id="VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE">VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST" id="VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST">VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventType" id="virDomainEventType"><code>virDomainEventType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_DEFINED" id="VIR_DOMAIN_EVENT_DEFINED">VIR_DOMAIN_EVENT_DEFINED</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_UNDEFINED" id="VIR_DOMAIN_EVENT_UNDEFINED">VIR_DOMAIN_EVENT_UNDEFINED</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED" id="VIR_DOMAIN_EVENT_STARTED">VIR_DOMAIN_EVENT_STARTED</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED" id="VIR_DOMAIN_EVENT_SUSPENDED">VIR_DOMAIN_EVENT_SUSPENDED</a></td><td> = </td><td>3</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_RESUMED" id="VIR_DOMAIN_EVENT_RESUMED">VIR_DOMAIN_EVENT_RESUMED</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED" id="VIR_DOMAIN_EVENT_STOPPED">VIR_DOMAIN_EVENT_STOPPED</a></td><td> = </td><td>5</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SHUTDOWN" id="VIR_DOMAIN_EVENT_SHUTDOWN">VIR_DOMAIN_EVENT_SHUTDOWN</a></td><td> = </td><td>6</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_PMSUSPENDED" id="VIR_DOMAIN_EVENT_PMSUSPENDED">VIR_DOMAIN_EVENT_PMSUSPENDED</a></td><td> = </td><td>7</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_CRASHED" id="VIR_DOMAIN_EVENT_CRASHED">VIR_DOMAIN_EVENT_CRASHED</a></td><td> = </td><td>8</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_LAST" id="VIR_DOMAIN_EVENT_LAST">VIR_DOMAIN_EVENT_LAST</a></td><td> = </td><td>9</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventUndefinedDetailType" id="virDomainEventUndefinedDetailType"><code>virDomainEventUndefinedDetailType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventUndefinedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_UNDEFINED_REMOVED" id="VIR_DOMAIN_EVENT_UNDEFINED_REMOVED">VIR_DOMAIN_EVENT_UNDEFINED_REMOVED</a></td><td> = </td><td>0</td><td><div class="comment">Deleted the config file</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_UNDEFINED_LAST" id="VIR_DOMAIN_EVENT_UNDEFINED_LAST">VIR_DOMAIN_EVENT_UNDEFINED_LAST</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventWatchdogAction" id="virDomainEventWatchdogAction"><code>virDomainEventWatchdogAction</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainEventWatchdogAction {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_NONE" id="VIR_DOMAIN_EVENT_WATCHDOG_NONE">VIR_DOMAIN_EVENT_WATCHDOG_NONE</a></td><td> = </td><td>0</td><td><div class="comment">No action, watchdog ignored</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_PAUSE" id="VIR_DOMAIN_EVENT_WATCHDOG_PAUSE">VIR_DOMAIN_EVENT_WATCHDOG_PAUSE</a></td><td> = </td><td>1</td><td><div class="comment">Guest CPUs are paused</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_RESET" id="VIR_DOMAIN_EVENT_WATCHDOG_RESET">VIR_DOMAIN_EVENT_WATCHDOG_RESET</a></td><td> = </td><td>2</td><td><div class="comment">Guest CPUs are reset</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF" id="VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF">VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF</a></td><td> = </td><td>3</td><td><div class="comment">Guest is forcably powered off</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN" id="VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN">VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN</a></td><td> = </td><td>4</td><td><div class="comment">Guest is requested to gracefully shutdown</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_DEBUG" id="VIR_DOMAIN_EVENT_WATCHDOG_DEBUG">VIR_DOMAIN_EVENT_WATCHDOG_DEBUG</a></td><td> = </td><td>5</td><td><div class="comment">No action, a debug message logged</div></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_LAST" id="VIR_DOMAIN_EVENT_WATCHDOG_LAST">VIR_DOMAIN_EVENT_WATCHDOG_LAST</a></td><td> = </td><td>6</td></tr></table><pre>}
</pre></div><h3><a name="virDomainInfo" id="virDomainInfo"><code>virDomainInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainInfo {
</pre><table><tr><td><span class="type">unsigned char</span></td><td>state</td><td><div class="comment">the running state, one of <a href="libvirt-libvirt.html#virDomainState">virDomainState</a></div></td></tr><tr><td><span class="type">unsigned long</span></td><td>maxMem</td><td><div class="comment">the maximum memory in KBytes allowed</div></td></tr><tr><td><span class="type">unsigned long</span></td><td>memory</td><td><div class="comment">the memory in KBytes used by the domain</div></td></tr><tr><td><span class="type">unsigned short</span></td><td>nrVirtCpu</td><td><div class="comment">the number of virtual CPUs for the domain</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>cpuTime</td><td><div class="comment">the CPU time used in nanoseconds</div></td></tr></table><pre>
}
</pre></div><h3><a name="virDomainInterfaceStatsStruct" id="virDomainInterfaceStatsStruct"><code>virDomainInterfaceStatsStruct</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainInterfaceStatsStruct {
</pre><table><tr><td><span class="type">long long</span></td><td>rx_bytes</td></tr><tr><td><span class="type">long long</span></td><td>rx_packets</td></tr><tr><td><span class="type">long long</span></td><td>rx_errs</td></tr><tr><td><span class="type">long long</span></td><td>rx_drop</td></tr><tr><td><span class="type">long long</span></td><td>tx_bytes</td></tr><tr><td><span class="type">long long</span></td><td>tx_packets</td></tr><tr><td><span class="type">long long</span></td><td>tx_errs</td></tr><tr><td><span class="type">long long</span></td><td>tx_drop</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainJobInfo" id="virDomainJobInfo"><code>virDomainJobInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainJobInfo {
</pre><table><tr><td><span class="type">int</span></td><td>type</td><td><div class="comment">Time is measured in milliseconds</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>timeElapsed</td><td><div class="comment">Always set</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>timeRemaining</td><td><div class="comment">Only for <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> Data is measured in bytes unless otherwise specified and is measuring the job as a whole. For <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_UNBOUNDED">VIR_DOMAIN_JOB_UNBOUNDED</a>, dataTotal may be less than the final sum of dataProcessed + dataRemaining in the event that the hypervisor has to repeat some data, such as due to dirtied pages during migration. For <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a>, dataTotal shall always equal the sum of dataProcessed + dataRemaining.</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>dataTotal</td></tr><tr><td><span class="type">unsigned long long</span></td><td>dataProcessed</td></tr><tr><td><span class="type">unsigned long long</span></td><td>dataRemaining</td><td><div class="comment">As above, but only tracking guest memory progress</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>memTotal</td></tr><tr><td><span class="type">unsigned long long</span></td><td>memProcessed</td></tr><tr><td><span class="type">unsigned long long</span></td><td>memRemaining</td><td><div class="comment">As above, but only tracking guest disk file progress</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>fileTotal</td></tr><tr><td><span class="type">unsigned long long</span></td><td>fileProcessed</td></tr><tr><td><span class="type">unsigned long long</span></td><td>fileRemaining</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainJobType" id="virDomainJobType"><code>virDomainJobType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainJobType {
</pre><table><tr><td><a name="VIR_DOMAIN_JOB_NONE" id="VIR_DOMAIN_JOB_NONE">VIR_DOMAIN_JOB_NONE</a></td><td> = </td><td>0</td><td><div class="comment">No job is active</div></td></tr><tr><td><a name="VIR_DOMAIN_JOB_BOUNDED" id="VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a></td><td> = </td><td>1</td><td><div class="comment">Job with a finite completion time</div></td></tr><tr><td><a name="VIR_DOMAIN_JOB_UNBOUNDED" id="VIR_DOMAIN_JOB_UNBOUNDED">VIR_DOMAIN_JOB_UNBOUNDED</a></td><td> = </td><td>2</td><td><div class="comment">Job without a finite completion time</div></td></tr><tr><td><a name="VIR_DOMAIN_JOB_COMPLETED" id="VIR_DOMAIN_JOB_COMPLETED">VIR_DOMAIN_JOB_COMPLETED</a></td><td> = </td><td>3</td><td><div class="comment">Job has finished, but isn't cleaned up</div></td></tr><tr><td><a name="VIR_DOMAIN_JOB_FAILED" id="VIR_DOMAIN_JOB_FAILED">VIR_DOMAIN_JOB_FAILED</a></td><td> = </td><td>4</td><td><div class="comment">Job hit error, but isn't cleaned up</div></td></tr><tr><td><a name="VIR_DOMAIN_JOB_CANCELLED" id="VIR_DOMAIN_JOB_CANCELLED">VIR_DOMAIN_JOB_CANCELLED</a></td><td> = </td><td>5</td><td><div class="comment">Job was aborted, but isn't cleaned up</div></td></tr><tr><td><a name="VIR_DOMAIN_JOB_LAST" id="VIR_DOMAIN_JOB_LAST">VIR_DOMAIN_JOB_LAST</a></td><td> = </td><td>6</td></tr></table><pre>}
</pre></div><h3><a name="virDomainMemoryFlags" id="virDomainMemoryFlags"><code>virDomainMemoryFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainMemoryFlags {
</pre><table><tr><td><a name="VIR_MEMORY_VIRTUAL" id="VIR_MEMORY_VIRTUAL">VIR_MEMORY_VIRTUAL</a></td><td> = </td><td>1</td><td><div class="comment">addresses are virtual addresses</div></td></tr><tr><td><a name="VIR_MEMORY_PHYSICAL" id="VIR_MEMORY_PHYSICAL">VIR_MEMORY_PHYSICAL</a></td><td> = </td><td>2</td><td><div class="comment">addresses are physical addresses</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainMemoryModFlags" id="virDomainMemoryModFlags"><code>virDomainMemoryModFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainMemoryModFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_MEM_CONFIG" id="VIR_DOMAIN_MEM_CONFIG">VIR_DOMAIN_MEM_CONFIG</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_CONFIG</td><td><div class="comment">Additionally, these flags may be bitwise-OR'd in.</div></td></tr><tr><td><a name="VIR_DOMAIN_MEM_CURRENT" id="VIR_DOMAIN_MEM_CURRENT">VIR_DOMAIN_MEM_CURRENT</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_CURRENT</td></tr><tr><td><a name="VIR_DOMAIN_MEM_LIVE" id="VIR_DOMAIN_MEM_LIVE">VIR_DOMAIN_MEM_LIVE</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_LIVE</td></tr><tr><td><a name="VIR_DOMAIN_MEM_MAXIMUM" id="VIR_DOMAIN_MEM_MAXIMUM">VIR_DOMAIN_MEM_MAXIMUM</a></td><td> = </td><td>4</td><td><div class="comment">affect Max rather than current</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainMemoryStatStruct" id="virDomainMemoryStatStruct"><code>virDomainMemoryStatStruct</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainMemoryStatStruct {
</pre><table><tr><td><span class="type">int</span></td><td>tag</td></tr><tr><td><span class="type">unsigned long long</span></td><td>val</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainMemoryStatTags" id="virDomainMemoryStatTags"><code>virDomainMemoryStatTags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainMemoryStatTags {
</pre><table><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_LAST" id="VIR_DOMAIN_MEMORY_STAT_LAST">VIR_DOMAIN_MEMORY_STAT_LAST</a></td><td> = </td><td>VIR_DOMAIN_MEMORY_STAT_NR</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_SWAP_IN" id="VIR_DOMAIN_MEMORY_STAT_SWAP_IN">VIR_DOMAIN_MEMORY_STAT_SWAP_IN</a></td><td> = </td><td>0</td><td><div class="comment">The total amount of memory written out to swap space (in kB).</div></td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_SWAP_OUT" id="VIR_DOMAIN_MEMORY_STAT_SWAP_OUT">VIR_DOMAIN_MEMORY_STAT_SWAP_OUT</a></td><td> = </td><td>1</td><td><div class="comment">Page faults occur when a process makes a valid access to virtual memory that is not available. When servicing the page fault, if disk IO is required, it is considered a major fault. If not, it is a minor fault. These are expressed as the number of faults that have occurred.</div></td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT" id="VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT" id="VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT</a></td><td> = </td><td>3</td><td><div class="comment">The amount of memory left completely unused by the system. Memory that is available but used for reclaimable caches should NOT be reported as free. This value is expressed in kB.</div></td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_UNUSED" id="VIR_DOMAIN_MEMORY_STAT_UNUSED">VIR_DOMAIN_MEMORY_STAT_UNUSED</a></td><td> = </td><td>4</td><td><div class="comment">The total amount of usable memory as seen by the domain. This value may be less than the amount of memory assigned to the domain if a balloon driver is in use or if the guest OS does not initialize all assigned pages. This value is expressed in kB.</div></td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_AVAILABLE" id="VIR_DOMAIN_MEMORY_STAT_AVAILABLE">VIR_DOMAIN_MEMORY_STAT_AVAILABLE</a></td><td> = </td><td>5</td><td><div class="comment">Current balloon value (in KB).</div></td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON" id="VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON">VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON</a></td><td> = </td><td>6</td><td><div class="comment">Resident Set Size of the process running the domain. This value is in kB</div></td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_RSS" id="VIR_DOMAIN_MEMORY_STAT_RSS">VIR_DOMAIN_MEMORY_STAT_RSS</a></td><td> = </td><td>7</td><td><div class="comment">The number of statistics supported by this version of the interface. To add new statistics, add them to the enum and increase this value.</div></td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_NR" id="VIR_DOMAIN_MEMORY_STAT_NR">VIR_DOMAIN_MEMORY_STAT_NR</a></td><td> = </td><td>8</td></tr></table><pre>}
</pre></div><h3><a name="virDomainMetadataType" id="virDomainMetadataType"><code>virDomainMetadataType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainMetadataType {
</pre><table><tr><td><a name="VIR_DOMAIN_METADATA_DESCRIPTION" id="VIR_DOMAIN_METADATA_DESCRIPTION">VIR_DOMAIN_METADATA_DESCRIPTION</a></td><td> = </td><td>0</td><td><div class="comment">Operate on &lt;description&gt;</div></td></tr><tr><td><a name="VIR_DOMAIN_METADATA_TITLE" id="VIR_DOMAIN_METADATA_TITLE">VIR_DOMAIN_METADATA_TITLE</a></td><td> = </td><td>1</td><td><div class="comment">Operate on &lt;title&gt;</div></td></tr><tr><td><a name="VIR_DOMAIN_METADATA_ELEMENT" id="VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a></td><td> = </td><td>2</td><td><div class="comment">Operate on &lt;metadata&gt;</div></td></tr><tr><td><a name="VIR_DOMAIN_METADATA_LAST" id="VIR_DOMAIN_METADATA_LAST">VIR_DOMAIN_METADATA_LAST</a></td><td> = </td><td>3</td></tr></table><pre>}
</pre></div><h3><a name="virDomainMigrateFlags" id="virDomainMigrateFlags"><code>virDomainMigrateFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainMigrateFlags {
</pre><table><tr><td><a name="VIR_MIGRATE_LIVE" id="VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a></td><td> = </td><td>1</td><td><div class="comment">live migration</div></td></tr><tr><td><a name="VIR_MIGRATE_PEER2PEER" id="VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a></td><td> = </td><td>2</td><td><div class="comment">direct source -&gt; dest host control channel Note the less-common spelling that we're stuck with: <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> should be VIR_MIGRATE_TUNNELED</div></td></tr><tr><td><a name="VIR_MIGRATE_TUNNELLED" id="VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a></td><td> = </td><td>4</td><td><div class="comment">tunnel migration data over libvirtd connection</div></td></tr><tr><td><a name="VIR_MIGRATE_PERSIST_DEST" id="VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a></td><td> = </td><td>8</td><td><div class="comment">persist the VM on the destination</div></td></tr><tr><td><a name="VIR_MIGRATE_UNDEFINE_SOURCE" id="VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a></td><td> = </td><td>16</td><td><div class="comment">undefine the VM on the source</div></td></tr><tr><td><a name="VIR_MIGRATE_PAUSED" id="VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a></td><td> = </td><td>32</td><td><div class="comment">pause on remote side</div></td></tr><tr><td><a name="VIR_MIGRATE_NON_SHARED_DISK" id="VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a></td><td> = </td><td>64</td><td><div class="comment">migration with non-shared storage with full disk copy</div></td></tr><tr><td><a name="VIR_MIGRATE_NON_SHARED_INC" id="VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a></td><td> = </td><td>128</td><td><div class="comment">migration with non-shared storage with incremental copy (same base image shared between source and destination)</div></td></tr><tr><td><a name="VIR_MIGRATE_CHANGE_PROTECTION" id="VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a></td><td> = </td><td>256</td><td><div class="comment">protect for changing domain configuration through the whole migration process; this will be used automatically when supported</div></td></tr><tr><td><a name="VIR_MIGRATE_UNSAFE" id="VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a></td><td> = </td><td>512</td><td><div class="comment">force migration even if it is considered unsafe</div></td></tr><tr><td><a name="VIR_MIGRATE_OFFLINE" id="VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a></td><td> = </td><td>1024</td><td><div class="comment">offline migrate</div></td></tr><tr><td><a name="VIR_MIGRATE_COMPRESSED" id="VIR_MIGRATE_COMPRESSED">VIR_MIGRATE_COMPRESSED</a></td><td> = </td><td>2048</td><td><div class="comment">compress data during migration</div></td></tr><tr><td><a name="VIR_MIGRATE_ABORT_ON_ERROR" id="VIR_MIGRATE_ABORT_ON_ERROR">VIR_MIGRATE_ABORT_ON_ERROR</a></td><td> = </td><td>4096</td><td><div class="comment">abort migration on I/O errors happened during migration</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainModificationImpact" id="virDomainModificationImpact"><code>virDomainModificationImpact</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainModificationImpact {
</pre><table><tr><td><a name="VIR_DOMAIN_AFFECT_CURRENT" id="VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a></td><td> = </td><td>0</td><td><div class="comment">Affect current domain state.</div></td></tr><tr><td><a name="VIR_DOMAIN_AFFECT_LIVE" id="VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a></td><td> = </td><td>1</td><td><div class="comment">Affect running domain state.</div></td></tr><tr><td><a name="VIR_DOMAIN_AFFECT_CONFIG" id="VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a></td><td> = </td><td>2</td><td><div class="comment">Affect persistent domain state. 1 &lt;&lt; 2 is reserved for <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainNostateReason" id="virDomainNostateReason"><code>virDomainNostateReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainNostateReason {
</pre><table><tr><td><a name="VIR_DOMAIN_NOSTATE_UNKNOWN" id="VIR_DOMAIN_NOSTATE_UNKNOWN">VIR_DOMAIN_NOSTATE_UNKNOWN</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_NOSTATE_LAST" id="VIR_DOMAIN_NOSTATE_LAST">VIR_DOMAIN_NOSTATE_LAST</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainNumatuneMemMode" id="virDomainNumatuneMemMode"><code>virDomainNumatuneMemMode</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainNumatuneMemMode {
</pre><table><tr><td><a name="VIR_DOMAIN_NUMATUNE_MEM_STRICT" id="VIR_DOMAIN_NUMATUNE_MEM_STRICT">VIR_DOMAIN_NUMATUNE_MEM_STRICT</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_NUMATUNE_MEM_PREFERRED" id="VIR_DOMAIN_NUMATUNE_MEM_PREFERRED">VIR_DOMAIN_NUMATUNE_MEM_PREFERRED</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE" id="VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE">VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_DOMAIN_NUMATUNE_MEM_LAST" id="VIR_DOMAIN_NUMATUNE_MEM_LAST">VIR_DOMAIN_NUMATUNE_MEM_LAST</a></td><td> = </td><td>3</td><td><div class="comment">This constant is subject to change</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainOpenGraphicsFlags" id="virDomainOpenGraphicsFlags"><code>virDomainOpenGraphicsFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainOpenGraphicsFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH" id="VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH">VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainPMSuspendedDiskReason" id="virDomainPMSuspendedDiskReason"><code>virDomainPMSuspendedDiskReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainPMSuspendedDiskReason {
</pre><table><tr><td><a name="VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN" id="VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN">VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_PMSUSPENDED_DISK_LAST" id="VIR_DOMAIN_PMSUSPENDED_DISK_LAST">VIR_DOMAIN_PMSUSPENDED_DISK_LAST</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainPMSuspendedReason" id="virDomainPMSuspendedReason"><code>virDomainPMSuspendedReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainPMSuspendedReason {
</pre><table><tr><td><a name="VIR_DOMAIN_PMSUSPENDED_UNKNOWN" id="VIR_DOMAIN_PMSUSPENDED_UNKNOWN">VIR_DOMAIN_PMSUSPENDED_UNKNOWN</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_PMSUSPENDED_LAST" id="VIR_DOMAIN_PMSUSPENDED_LAST">VIR_DOMAIN_PMSUSPENDED_LAST</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainPausedReason" id="virDomainPausedReason"><code>virDomainPausedReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainPausedReason {
</pre><table><tr><td><a name="VIR_DOMAIN_PAUSED_UNKNOWN" id="VIR_DOMAIN_PAUSED_UNKNOWN">VIR_DOMAIN_PAUSED_UNKNOWN</a></td><td> = </td><td>0</td><td><div class="comment">the reason is unknown</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_USER" id="VIR_DOMAIN_PAUSED_USER">VIR_DOMAIN_PAUSED_USER</a></td><td> = </td><td>1</td><td><div class="comment">paused on user request</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_MIGRATION" id="VIR_DOMAIN_PAUSED_MIGRATION">VIR_DOMAIN_PAUSED_MIGRATION</a></td><td> = </td><td>2</td><td><div class="comment">paused for offline migration</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_SAVE" id="VIR_DOMAIN_PAUSED_SAVE">VIR_DOMAIN_PAUSED_SAVE</a></td><td> = </td><td>3</td><td><div class="comment">paused for save</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_DUMP" id="VIR_DOMAIN_PAUSED_DUMP">VIR_DOMAIN_PAUSED_DUMP</a></td><td> = </td><td>4</td><td><div class="comment">paused for offline core dump</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_IOERROR" id="VIR_DOMAIN_PAUSED_IOERROR">VIR_DOMAIN_PAUSED_IOERROR</a></td><td> = </td><td>5</td><td><div class="comment">paused due to a disk I/O error</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_WATCHDOG" id="VIR_DOMAIN_PAUSED_WATCHDOG">VIR_DOMAIN_PAUSED_WATCHDOG</a></td><td> = </td><td>6</td><td><div class="comment">paused due to a watchdog event</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_FROM_SNAPSHOT" id="VIR_DOMAIN_PAUSED_FROM_SNAPSHOT">VIR_DOMAIN_PAUSED_FROM_SNAPSHOT</a></td><td> = </td><td>7</td><td><div class="comment">paused after restoring from snapshot</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_SHUTTING_DOWN" id="VIR_DOMAIN_PAUSED_SHUTTING_DOWN">VIR_DOMAIN_PAUSED_SHUTTING_DOWN</a></td><td> = </td><td>8</td><td><div class="comment">paused during shutdown process</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_SNAPSHOT" id="VIR_DOMAIN_PAUSED_SNAPSHOT">VIR_DOMAIN_PAUSED_SNAPSHOT</a></td><td> = </td><td>9</td><td><div class="comment">paused while creating a snapshot</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_CRASHED" id="VIR_DOMAIN_PAUSED_CRASHED">VIR_DOMAIN_PAUSED_CRASHED</a></td><td> = </td><td>10</td><td><div class="comment">paused due to a guest crash</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED_LAST" id="VIR_DOMAIN_PAUSED_LAST">VIR_DOMAIN_PAUSED_LAST</a></td><td> = </td><td>11</td></tr></table><pre>}
</pre></div><h3><a name="virDomainProcessSignal" id="virDomainProcessSignal"><code>virDomainProcessSignal</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainProcessSignal {
</pre><table><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_NOP" id="VIR_DOMAIN_PROCESS_SIGNAL_NOP">VIR_DOMAIN_PROCESS_SIGNAL_NOP</a></td><td> = </td><td>0</td><td><div class="comment">No constant in POSIX/Linux</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_HUP" id="VIR_DOMAIN_PROCESS_SIGNAL_HUP">VIR_DOMAIN_PROCESS_SIGNAL_HUP</a></td><td> = </td><td>1</td><td><div class="comment">SIGHUP</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_INT" id="VIR_DOMAIN_PROCESS_SIGNAL_INT">VIR_DOMAIN_PROCESS_SIGNAL_INT</a></td><td> = </td><td>2</td><td><div class="comment">SIGINT</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_QUIT" id="VIR_DOMAIN_PROCESS_SIGNAL_QUIT">VIR_DOMAIN_PROCESS_SIGNAL_QUIT</a></td><td> = </td><td>3</td><td><div class="comment">SIGQUIT</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_ILL" id="VIR_DOMAIN_PROCESS_SIGNAL_ILL">VIR_DOMAIN_PROCESS_SIGNAL_ILL</a></td><td> = </td><td>4</td><td><div class="comment">SIGILL</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_TRAP" id="VIR_DOMAIN_PROCESS_SIGNAL_TRAP">VIR_DOMAIN_PROCESS_SIGNAL_TRAP</a></td><td> = </td><td>5</td><td><div class="comment">SIGTRAP</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_ABRT" id="VIR_DOMAIN_PROCESS_SIGNAL_ABRT">VIR_DOMAIN_PROCESS_SIGNAL_ABRT</a></td><td> = </td><td>6</td><td><div class="comment">SIGABRT</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_BUS" id="VIR_DOMAIN_PROCESS_SIGNAL_BUS">VIR_DOMAIN_PROCESS_SIGNAL_BUS</a></td><td> = </td><td>7</td><td><div class="comment">SIGBUS</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_FPE" id="VIR_DOMAIN_PROCESS_SIGNAL_FPE">VIR_DOMAIN_PROCESS_SIGNAL_FPE</a></td><td> = </td><td>8</td><td><div class="comment">SIGFPE</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_KILL" id="VIR_DOMAIN_PROCESS_SIGNAL_KILL">VIR_DOMAIN_PROCESS_SIGNAL_KILL</a></td><td> = </td><td>9</td><td><div class="comment">SIGKILL</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_USR1" id="VIR_DOMAIN_PROCESS_SIGNAL_USR1">VIR_DOMAIN_PROCESS_SIGNAL_USR1</a></td><td> = </td><td>10</td><td><div class="comment">SIGUSR1</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_SEGV" id="VIR_DOMAIN_PROCESS_SIGNAL_SEGV">VIR_DOMAIN_PROCESS_SIGNAL_SEGV</a></td><td> = </td><td>11</td><td><div class="comment">SIGSEGV</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_USR2" id="VIR_DOMAIN_PROCESS_SIGNAL_USR2">VIR_DOMAIN_PROCESS_SIGNAL_USR2</a></td><td> = </td><td>12</td><td><div class="comment">SIGUSR2</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_PIPE" id="VIR_DOMAIN_PROCESS_SIGNAL_PIPE">VIR_DOMAIN_PROCESS_SIGNAL_PIPE</a></td><td> = </td><td>13</td><td><div class="comment">SIGPIPE</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_ALRM" id="VIR_DOMAIN_PROCESS_SIGNAL_ALRM">VIR_DOMAIN_PROCESS_SIGNAL_ALRM</a></td><td> = </td><td>14</td><td><div class="comment">SIGALRM</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_TERM" id="VIR_DOMAIN_PROCESS_SIGNAL_TERM">VIR_DOMAIN_PROCESS_SIGNAL_TERM</a></td><td> = </td><td>15</td><td><div class="comment">SIGTERM</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_STKFLT" id="VIR_DOMAIN_PROCESS_SIGNAL_STKFLT">VIR_DOMAIN_PROCESS_SIGNAL_STKFLT</a></td><td> = </td><td>16</td><td><div class="comment">Not in POSIX (SIGSTKFLT on Linux</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_CHLD" id="VIR_DOMAIN_PROCESS_SIGNAL_CHLD">VIR_DOMAIN_PROCESS_SIGNAL_CHLD</a></td><td> = </td><td>17</td><td><div class="comment">SIGCHLD</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_CONT" id="VIR_DOMAIN_PROCESS_SIGNAL_CONT">VIR_DOMAIN_PROCESS_SIGNAL_CONT</a></td><td> = </td><td>18</td><td><div class="comment">SIGCONT</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_STOP" id="VIR_DOMAIN_PROCESS_SIGNAL_STOP">VIR_DOMAIN_PROCESS_SIGNAL_STOP</a></td><td> = </td><td>19</td><td><div class="comment">SIGSTOP</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_TSTP" id="VIR_DOMAIN_PROCESS_SIGNAL_TSTP">VIR_DOMAIN_PROCESS_SIGNAL_TSTP</a></td><td> = </td><td>20</td><td><div class="comment">SIGTSTP</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_TTIN" id="VIR_DOMAIN_PROCESS_SIGNAL_TTIN">VIR_DOMAIN_PROCESS_SIGNAL_TTIN</a></td><td> = </td><td>21</td><td><div class="comment">SIGTTIN</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_TTOU" id="VIR_DOMAIN_PROCESS_SIGNAL_TTOU">VIR_DOMAIN_PROCESS_SIGNAL_TTOU</a></td><td> = </td><td>22</td><td><div class="comment">SIGTTOU</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_URG" id="VIR_DOMAIN_PROCESS_SIGNAL_URG">VIR_DOMAIN_PROCESS_SIGNAL_URG</a></td><td> = </td><td>23</td><td><div class="comment">SIGURG</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_XCPU" id="VIR_DOMAIN_PROCESS_SIGNAL_XCPU">VIR_DOMAIN_PROCESS_SIGNAL_XCPU</a></td><td> = </td><td>24</td><td><div class="comment">SIGXCPU</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_XFSZ" id="VIR_DOMAIN_PROCESS_SIGNAL_XFSZ">VIR_DOMAIN_PROCESS_SIGNAL_XFSZ</a></td><td> = </td><td>25</td><td><div class="comment">SIGXFSZ</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_VTALRM" id="VIR_DOMAIN_PROCESS_SIGNAL_VTALRM">VIR_DOMAIN_PROCESS_SIGNAL_VTALRM</a></td><td> = </td><td>26</td><td><div class="comment">SIGVTALRM</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_PROF" id="VIR_DOMAIN_PROCESS_SIGNAL_PROF">VIR_DOMAIN_PROCESS_SIGNAL_PROF</a></td><td> = </td><td>27</td><td><div class="comment">SIGPROF</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_WINCH" id="VIR_DOMAIN_PROCESS_SIGNAL_WINCH">VIR_DOMAIN_PROCESS_SIGNAL_WINCH</a></td><td> = </td><td>28</td><td><div class="comment">Not in POSIX (SIGWINCH on Linux)</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_POLL" id="VIR_DOMAIN_PROCESS_SIGNAL_POLL">VIR_DOMAIN_PROCESS_SIGNAL_POLL</a></td><td> = </td><td>29</td><td><div class="comment">SIGPOLL (also known as SIGIO on Linux)</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_PWR" id="VIR_DOMAIN_PROCESS_SIGNAL_PWR">VIR_DOMAIN_PROCESS_SIGNAL_PWR</a></td><td> = </td><td>30</td><td><div class="comment">Not in POSIX (SIGPWR on Linux)</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_SYS" id="VIR_DOMAIN_PROCESS_SIGNAL_SYS">VIR_DOMAIN_PROCESS_SIGNAL_SYS</a></td><td> = </td><td>31</td><td><div class="comment">SIGSYS (also known as SIGUNUSED on Linux)</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT0" id="VIR_DOMAIN_PROCESS_SIGNAL_RT0">VIR_DOMAIN_PROCESS_SIGNAL_RT0</a></td><td> = </td><td>32</td><td><div class="comment">SIGRTMIN</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT1" id="VIR_DOMAIN_PROCESS_SIGNAL_RT1">VIR_DOMAIN_PROCESS_SIGNAL_RT1</a></td><td> = </td><td>33</td><td><div class="comment">SIGRTMIN + 1</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT2" id="VIR_DOMAIN_PROCESS_SIGNAL_RT2">VIR_DOMAIN_PROCESS_SIGNAL_RT2</a></td><td> = </td><td>34</td><td><div class="comment">SIGRTMIN + 2</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT3" id="VIR_DOMAIN_PROCESS_SIGNAL_RT3">VIR_DOMAIN_PROCESS_SIGNAL_RT3</a></td><td> = </td><td>35</td><td><div class="comment">SIGRTMIN + 3</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT4" id="VIR_DOMAIN_PROCESS_SIGNAL_RT4">VIR_DOMAIN_PROCESS_SIGNAL_RT4</a></td><td> = </td><td>36</td><td><div class="comment">SIGRTMIN + 4</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT5" id="VIR_DOMAIN_PROCESS_SIGNAL_RT5">VIR_DOMAIN_PROCESS_SIGNAL_RT5</a></td><td> = </td><td>37</td><td><div class="comment">SIGRTMIN + 5</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT6" id="VIR_DOMAIN_PROCESS_SIGNAL_RT6">VIR_DOMAIN_PROCESS_SIGNAL_RT6</a></td><td> = </td><td>38</td><td><div class="comment">SIGRTMIN + 6</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT7" id="VIR_DOMAIN_PROCESS_SIGNAL_RT7">VIR_DOMAIN_PROCESS_SIGNAL_RT7</a></td><td> = </td><td>39</td><td><div class="comment">SIGRTMIN + 7</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT8" id="VIR_DOMAIN_PROCESS_SIGNAL_RT8">VIR_DOMAIN_PROCESS_SIGNAL_RT8</a></td><td> = </td><td>40</td><td><div class="comment">SIGRTMIN + 8</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT9" id="VIR_DOMAIN_PROCESS_SIGNAL_RT9">VIR_DOMAIN_PROCESS_SIGNAL_RT9</a></td><td> = </td><td>41</td><td><div class="comment">SIGRTMIN + 9</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT10" id="VIR_DOMAIN_PROCESS_SIGNAL_RT10">VIR_DOMAIN_PROCESS_SIGNAL_RT10</a></td><td> = </td><td>42</td><td><div class="comment">SIGRTMIN + 10</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT11" id="VIR_DOMAIN_PROCESS_SIGNAL_RT11">VIR_DOMAIN_PROCESS_SIGNAL_RT11</a></td><td> = </td><td>43</td><td><div class="comment">SIGRTMIN + 11</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT12" id="VIR_DOMAIN_PROCESS_SIGNAL_RT12">VIR_DOMAIN_PROCESS_SIGNAL_RT12</a></td><td> = </td><td>44</td><td><div class="comment">SIGRTMIN + 12</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT13" id="VIR_DOMAIN_PROCESS_SIGNAL_RT13">VIR_DOMAIN_PROCESS_SIGNAL_RT13</a></td><td> = </td><td>45</td><td><div class="comment">SIGRTMIN + 13</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT14" id="VIR_DOMAIN_PROCESS_SIGNAL_RT14">VIR_DOMAIN_PROCESS_SIGNAL_RT14</a></td><td> = </td><td>46</td><td><div class="comment">SIGRTMIN + 14</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT15" id="VIR_DOMAIN_PROCESS_SIGNAL_RT15">VIR_DOMAIN_PROCESS_SIGNAL_RT15</a></td><td> = </td><td>47</td><td><div class="comment">SIGRTMIN + 15</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT16" id="VIR_DOMAIN_PROCESS_SIGNAL_RT16">VIR_DOMAIN_PROCESS_SIGNAL_RT16</a></td><td> = </td><td>48</td><td><div class="comment">SIGRTMIN + 16</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT17" id="VIR_DOMAIN_PROCESS_SIGNAL_RT17">VIR_DOMAIN_PROCESS_SIGNAL_RT17</a></td><td> = </td><td>49</td><td><div class="comment">SIGRTMIN + 17</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT18" id="VIR_DOMAIN_PROCESS_SIGNAL_RT18">VIR_DOMAIN_PROCESS_SIGNAL_RT18</a></td><td> = </td><td>50</td><td><div class="comment">SIGRTMIN + 18</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT19" id="VIR_DOMAIN_PROCESS_SIGNAL_RT19">VIR_DOMAIN_PROCESS_SIGNAL_RT19</a></td><td> = </td><td>51</td><td><div class="comment">SIGRTMIN + 19</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT20" id="VIR_DOMAIN_PROCESS_SIGNAL_RT20">VIR_DOMAIN_PROCESS_SIGNAL_RT20</a></td><td> = </td><td>52</td><td><div class="comment">SIGRTMIN + 20</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT21" id="VIR_DOMAIN_PROCESS_SIGNAL_RT21">VIR_DOMAIN_PROCESS_SIGNAL_RT21</a></td><td> = </td><td>53</td><td><div class="comment">SIGRTMIN + 21</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT22" id="VIR_DOMAIN_PROCESS_SIGNAL_RT22">VIR_DOMAIN_PROCESS_SIGNAL_RT22</a></td><td> = </td><td>54</td><td><div class="comment">SIGRTMIN + 22</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT23" id="VIR_DOMAIN_PROCESS_SIGNAL_RT23">VIR_DOMAIN_PROCESS_SIGNAL_RT23</a></td><td> = </td><td>55</td><td><div class="comment">SIGRTMIN + 23</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT24" id="VIR_DOMAIN_PROCESS_SIGNAL_RT24">VIR_DOMAIN_PROCESS_SIGNAL_RT24</a></td><td> = </td><td>56</td><td><div class="comment">SIGRTMIN + 24</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT25" id="VIR_DOMAIN_PROCESS_SIGNAL_RT25">VIR_DOMAIN_PROCESS_SIGNAL_RT25</a></td><td> = </td><td>57</td><td><div class="comment">SIGRTMIN + 25</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT26" id="VIR_DOMAIN_PROCESS_SIGNAL_RT26">VIR_DOMAIN_PROCESS_SIGNAL_RT26</a></td><td> = </td><td>58</td><td><div class="comment">SIGRTMIN + 26</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT27" id="VIR_DOMAIN_PROCESS_SIGNAL_RT27">VIR_DOMAIN_PROCESS_SIGNAL_RT27</a></td><td> = </td><td>59</td><td><div class="comment">SIGRTMIN + 27</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT28" id="VIR_DOMAIN_PROCESS_SIGNAL_RT28">VIR_DOMAIN_PROCESS_SIGNAL_RT28</a></td><td> = </td><td>60</td><td><div class="comment">SIGRTMIN + 28</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT29" id="VIR_DOMAIN_PROCESS_SIGNAL_RT29">VIR_DOMAIN_PROCESS_SIGNAL_RT29</a></td><td> = </td><td>61</td><td><div class="comment">SIGRTMIN + 29</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT30" id="VIR_DOMAIN_PROCESS_SIGNAL_RT30">VIR_DOMAIN_PROCESS_SIGNAL_RT30</a></td><td> = </td><td>62</td><td><div class="comment">SIGRTMIN + 30</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT31" id="VIR_DOMAIN_PROCESS_SIGNAL_RT31">VIR_DOMAIN_PROCESS_SIGNAL_RT31</a></td><td> = </td><td>63</td><td><div class="comment">SIGRTMIN + 31</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_RT32" id="VIR_DOMAIN_PROCESS_SIGNAL_RT32">VIR_DOMAIN_PROCESS_SIGNAL_RT32</a></td><td> = </td><td>64</td><td><div class="comment">SIGRTMIN + 32 / SIGRTMAX</div></td></tr><tr><td><a name="VIR_DOMAIN_PROCESS_SIGNAL_LAST" id="VIR_DOMAIN_PROCESS_SIGNAL_LAST">VIR_DOMAIN_PROCESS_SIGNAL_LAST</a></td><td> = </td><td>65</td></tr></table><pre>}
</pre></div><h3><a name="virDomainRebootFlagValues" id="virDomainRebootFlagValues"><code>virDomainRebootFlagValues</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainRebootFlagValues {
</pre><table><tr><td><a name="VIR_DOMAIN_REBOOT_DEFAULT" id="VIR_DOMAIN_REBOOT_DEFAULT">VIR_DOMAIN_REBOOT_DEFAULT</a></td><td> = </td><td>0</td><td><div class="comment">hypervisor choice</div></td></tr><tr><td><a name="VIR_DOMAIN_REBOOT_ACPI_POWER_BTN" id="VIR_DOMAIN_REBOOT_ACPI_POWER_BTN">VIR_DOMAIN_REBOOT_ACPI_POWER_BTN</a></td><td> = </td><td>1</td><td><div class="comment">Send ACPI event</div></td></tr><tr><td><a name="VIR_DOMAIN_REBOOT_GUEST_AGENT" id="VIR_DOMAIN_REBOOT_GUEST_AGENT">VIR_DOMAIN_REBOOT_GUEST_AGENT</a></td><td> = </td><td>2</td><td><div class="comment">Use guest agent</div></td></tr><tr><td><a name="VIR_DOMAIN_REBOOT_INITCTL" id="VIR_DOMAIN_REBOOT_INITCTL">VIR_DOMAIN_REBOOT_INITCTL</a></td><td> = </td><td>4</td><td><div class="comment">Use initctl</div></td></tr><tr><td><a name="VIR_DOMAIN_REBOOT_SIGNAL" id="VIR_DOMAIN_REBOOT_SIGNAL">VIR_DOMAIN_REBOOT_SIGNAL</a></td><td> = </td><td>8</td><td><div class="comment">Send a signal</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainRunningReason" id="virDomainRunningReason"><code>virDomainRunningReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainRunningReason {
</pre><table><tr><td><a name="VIR_DOMAIN_RUNNING_UNKNOWN" id="VIR_DOMAIN_RUNNING_UNKNOWN">VIR_DOMAIN_RUNNING_UNKNOWN</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_BOOTED" id="VIR_DOMAIN_RUNNING_BOOTED">VIR_DOMAIN_RUNNING_BOOTED</a></td><td> = </td><td>1</td><td><div class="comment">normal startup from boot</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_MIGRATED" id="VIR_DOMAIN_RUNNING_MIGRATED">VIR_DOMAIN_RUNNING_MIGRATED</a></td><td> = </td><td>2</td><td><div class="comment">migrated from another host</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_RESTORED" id="VIR_DOMAIN_RUNNING_RESTORED">VIR_DOMAIN_RUNNING_RESTORED</a></td><td> = </td><td>3</td><td><div class="comment">restored from a state file</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_FROM_SNAPSHOT" id="VIR_DOMAIN_RUNNING_FROM_SNAPSHOT">VIR_DOMAIN_RUNNING_FROM_SNAPSHOT</a></td><td> = </td><td>4</td><td><div class="comment">restored from snapshot</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_UNPAUSED" id="VIR_DOMAIN_RUNNING_UNPAUSED">VIR_DOMAIN_RUNNING_UNPAUSED</a></td><td> = </td><td>5</td><td><div class="comment">returned from paused state</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_MIGRATION_CANCELED" id="VIR_DOMAIN_RUNNING_MIGRATION_CANCELED">VIR_DOMAIN_RUNNING_MIGRATION_CANCELED</a></td><td> = </td><td>6</td><td><div class="comment">returned from migration</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_SAVE_CANCELED" id="VIR_DOMAIN_RUNNING_SAVE_CANCELED">VIR_DOMAIN_RUNNING_SAVE_CANCELED</a></td><td> = </td><td>7</td><td><div class="comment">returned from failed save process</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_WAKEUP" id="VIR_DOMAIN_RUNNING_WAKEUP">VIR_DOMAIN_RUNNING_WAKEUP</a></td><td> = </td><td>8</td><td><div class="comment">returned from pmsuspended due to wakeup event</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_CRASHED" id="VIR_DOMAIN_RUNNING_CRASHED">VIR_DOMAIN_RUNNING_CRASHED</a></td><td> = </td><td>9</td><td><div class="comment">resumed from crashed</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING_LAST" id="VIR_DOMAIN_RUNNING_LAST">VIR_DOMAIN_RUNNING_LAST</a></td><td> = </td><td>10</td></tr></table><pre>}
</pre></div><h3><a name="virDomainSaveRestoreFlags" id="virDomainSaveRestoreFlags"><code>virDomainSaveRestoreFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainSaveRestoreFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_SAVE_BYPASS_CACHE" id="VIR_DOMAIN_SAVE_BYPASS_CACHE">VIR_DOMAIN_SAVE_BYPASS_CACHE</a></td><td> = </td><td>1</td><td><div class="comment">Avoid file system cache pollution</div></td></tr><tr><td><a name="VIR_DOMAIN_SAVE_RUNNING" id="VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a></td><td> = </td><td>2</td><td><div class="comment">Favor running over paused</div></td></tr><tr><td><a name="VIR_DOMAIN_SAVE_PAUSED" id="VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a></td><td> = </td><td>4</td><td><div class="comment">Favor paused over running</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainShutdownFlagValues" id="virDomainShutdownFlagValues"><code>virDomainShutdownFlagValues</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainShutdownFlagValues {
</pre><table><tr><td><a name="VIR_DOMAIN_SHUTDOWN_DEFAULT" id="VIR_DOMAIN_SHUTDOWN_DEFAULT">VIR_DOMAIN_SHUTDOWN_DEFAULT</a></td><td> = </td><td>0</td><td><div class="comment">hypervisor choice</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN" id="VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN">VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN</a></td><td> = </td><td>1</td><td><div class="comment">Send ACPI event</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTDOWN_GUEST_AGENT" id="VIR_DOMAIN_SHUTDOWN_GUEST_AGENT">VIR_DOMAIN_SHUTDOWN_GUEST_AGENT</a></td><td> = </td><td>2</td><td><div class="comment">Use guest agent</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTDOWN_INITCTL" id="VIR_DOMAIN_SHUTDOWN_INITCTL">VIR_DOMAIN_SHUTDOWN_INITCTL</a></td><td> = </td><td>4</td><td><div class="comment">Use initctl</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTDOWN_SIGNAL" id="VIR_DOMAIN_SHUTDOWN_SIGNAL">VIR_DOMAIN_SHUTDOWN_SIGNAL</a></td><td> = </td><td>8</td><td><div class="comment">Send a signal</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainShutdownReason" id="virDomainShutdownReason"><code>virDomainShutdownReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainShutdownReason {
</pre><table><tr><td><a name="VIR_DOMAIN_SHUTDOWN_UNKNOWN" id="VIR_DOMAIN_SHUTDOWN_UNKNOWN">VIR_DOMAIN_SHUTDOWN_UNKNOWN</a></td><td> = </td><td>0</td><td><div class="comment">the reason is unknown</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTDOWN_USER" id="VIR_DOMAIN_SHUTDOWN_USER">VIR_DOMAIN_SHUTDOWN_USER</a></td><td> = </td><td>1</td><td><div class="comment">shutting down on user request</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTDOWN_LAST" id="VIR_DOMAIN_SHUTDOWN_LAST">VIR_DOMAIN_SHUTDOWN_LAST</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virDomainShutoffReason" id="virDomainShutoffReason"><code>virDomainShutoffReason</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainShutoffReason {
</pre><table><tr><td><a name="VIR_DOMAIN_SHUTOFF_UNKNOWN" id="VIR_DOMAIN_SHUTOFF_UNKNOWN">VIR_DOMAIN_SHUTOFF_UNKNOWN</a></td><td> = </td><td>0</td><td><div class="comment">the reason is unknown</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF_SHUTDOWN" id="VIR_DOMAIN_SHUTOFF_SHUTDOWN">VIR_DOMAIN_SHUTOFF_SHUTDOWN</a></td><td> = </td><td>1</td><td><div class="comment">normal shutdown</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF_DESTROYED" id="VIR_DOMAIN_SHUTOFF_DESTROYED">VIR_DOMAIN_SHUTOFF_DESTROYED</a></td><td> = </td><td>2</td><td><div class="comment">forced poweroff</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF_CRASHED" id="VIR_DOMAIN_SHUTOFF_CRASHED">VIR_DOMAIN_SHUTOFF_CRASHED</a></td><td> = </td><td>3</td><td><div class="comment">domain crashed</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF_MIGRATED" id="VIR_DOMAIN_SHUTOFF_MIGRATED">VIR_DOMAIN_SHUTOFF_MIGRATED</a></td><td> = </td><td>4</td><td><div class="comment">migrated to another host</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF_SAVED" id="VIR_DOMAIN_SHUTOFF_SAVED">VIR_DOMAIN_SHUTOFF_SAVED</a></td><td> = </td><td>5</td><td><div class="comment">saved to a file</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF_FAILED" id="VIR_DOMAIN_SHUTOFF_FAILED">VIR_DOMAIN_SHUTOFF_FAILED</a></td><td> = </td><td>6</td><td><div class="comment">domain failed to start</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT" id="VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT">VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT</a></td><td> = </td><td>7</td><td><div class="comment">restored from a snapshot which was taken while domain was shutoff</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF_LAST" id="VIR_DOMAIN_SHUTOFF_LAST">VIR_DOMAIN_SHUTOFF_LAST</a></td><td> = </td><td>8</td></tr></table><pre>}
</pre></div><h3><a name="virDomainSnapshot" id="virDomainSnapshot"><code>virDomainSnapshot</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virDomainSnapshot {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virDomainSnapshotCreateFlags" id="virDomainSnapshotCreateFlags"><code>virDomainSnapshotCreateFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainSnapshotCreateFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE" id="VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE">VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE</a></td><td> = </td><td>1</td><td><div class="comment">Restore or alter metadata</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT" id="VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT">VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT</a></td><td> = </td><td>2</td><td><div class="comment">With redefine, make snapshot current</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA" id="VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA">VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA</a></td><td> = </td><td>4</td><td><div class="comment">Make snapshot without remembering it</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_HALT" id="VIR_DOMAIN_SNAPSHOT_CREATE_HALT">VIR_DOMAIN_SNAPSHOT_CREATE_HALT</a></td><td> = </td><td>8</td><td><div class="comment">Stop running guest after snapshot</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY" id="VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY</a></td><td> = </td><td>16</td><td><div class="comment">disk snapshot, not system checkpoint</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT" id="VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT">VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT</a></td><td> = </td><td>32</td><td><div class="comment">reuse any existing external files</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE" id="VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE">VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE</a></td><td> = </td><td>64</td><td><div class="comment">use guest agent to quiesce all mounted file systems within the domain</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC" id="VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC">VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC</a></td><td> = </td><td>128</td><td><div class="comment">atomically avoid partial changes</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_CREATE_LIVE" id="VIR_DOMAIN_SNAPSHOT_CREATE_LIVE">VIR_DOMAIN_SNAPSHOT_CREATE_LIVE</a></td><td> = </td><td>256</td><td><div class="comment">create the snapshot while the guest is running</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainSnapshotDeleteFlags" id="virDomainSnapshotDeleteFlags"><code>virDomainSnapshotDeleteFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainSnapshotDeleteFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN" id="VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN">VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN</a></td><td> = </td><td>1</td><td><div class="comment">Also delete children</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY" id="VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY">VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY</a></td><td> = </td><td>2</td><td><div class="comment">Delete just metadata</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY" id="VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY">VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY</a></td><td> = </td><td>4</td><td><div class="comment">Delete just children</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainSnapshotListFlags" id="virDomainSnapshotListFlags"><code>virDomainSnapshotListFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainSnapshotListFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS" id="VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS">VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS</a></td><td> = </td><td>1</td><td><div class="comment">List all descendants, not just children, when listing a snapshot For historical reasons, groups do not use contiguous bits.</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_ROOTS" id="VIR_DOMAIN_SNAPSHOT_LIST_ROOTS">VIR_DOMAIN_SNAPSHOT_LIST_ROOTS</a></td><td> = </td><td>1</td><td><div class="comment">Filter by snapshots with no parents, when listing a domain</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_METADATA" id="VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a></td><td> = </td><td>2</td><td><div class="comment">Filter by snapshots which have metadata</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_LEAVES" id="VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a></td><td> = </td><td>4</td><td><div class="comment">Filter by snapshots with no children</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES" id="VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES</a></td><td> = </td><td>8</td><td><div class="comment">Filter by snapshots that have children</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA" id="VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA</a></td><td> = </td><td>16</td><td><div class="comment">Filter by snapshots with no metadata</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE" id="VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE</a></td><td> = </td><td>32</td><td><div class="comment">Filter by snapshots taken while guest was shut off</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE" id="VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE</a></td><td> = </td><td>64</td><td><div class="comment">Filter by snapshots taken while guest was active, and with memory state</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY" id="VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY</a></td><td> = </td><td>128</td><td><div class="comment">Filter by snapshots taken while guest was active, but without memory state</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL" id="VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a></td><td> = </td><td>256</td><td><div class="comment">Filter by snapshots stored internal to disk images</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL" id="VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL</a></td><td> = </td><td>512</td><td><div class="comment">Filter by snapshots that use files external to disk images</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainSnapshotRevertFlags" id="virDomainSnapshotRevertFlags"><code>virDomainSnapshotRevertFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainSnapshotRevertFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING" id="VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING">VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING</a></td><td> = </td><td>1</td><td><div class="comment">Run after revert</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED" id="VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED">VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED</a></td><td> = </td><td>2</td><td><div class="comment">Pause after revert</div></td></tr><tr><td><a name="VIR_DOMAIN_SNAPSHOT_REVERT_FORCE" id="VIR_DOMAIN_SNAPSHOT_REVERT_FORCE">VIR_DOMAIN_SNAPSHOT_REVERT_FORCE</a></td><td> = </td><td>4</td><td><div class="comment">Allow risky reverts</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainState" id="virDomainState"><code>virDomainState</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainState {
</pre><table><tr><td><a name="VIR_DOMAIN_NOSTATE" id="VIR_DOMAIN_NOSTATE">VIR_DOMAIN_NOSTATE</a></td><td> = </td><td>0</td><td><div class="comment">no state</div></td></tr><tr><td><a name="VIR_DOMAIN_RUNNING" id="VIR_DOMAIN_RUNNING">VIR_DOMAIN_RUNNING</a></td><td> = </td><td>1</td><td><div class="comment">the domain is running</div></td></tr><tr><td><a name="VIR_DOMAIN_BLOCKED" id="VIR_DOMAIN_BLOCKED">VIR_DOMAIN_BLOCKED</a></td><td> = </td><td>2</td><td><div class="comment">the domain is blocked on resource</div></td></tr><tr><td><a name="VIR_DOMAIN_PAUSED" id="VIR_DOMAIN_PAUSED">VIR_DOMAIN_PAUSED</a></td><td> = </td><td>3</td><td><div class="comment">the domain is paused by user</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTDOWN" id="VIR_DOMAIN_SHUTDOWN">VIR_DOMAIN_SHUTDOWN</a></td><td> = </td><td>4</td><td><div class="comment">the domain is being shut down</div></td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF" id="VIR_DOMAIN_SHUTOFF">VIR_DOMAIN_SHUTOFF</a></td><td> = </td><td>5</td><td><div class="comment">the domain is shut off</div></td></tr><tr><td><a name="VIR_DOMAIN_CRASHED" id="VIR_DOMAIN_CRASHED">VIR_DOMAIN_CRASHED</a></td><td> = </td><td>6</td><td><div class="comment">the domain is crashed</div></td></tr><tr><td><a name="VIR_DOMAIN_PMSUSPENDED" id="VIR_DOMAIN_PMSUSPENDED">VIR_DOMAIN_PMSUSPENDED</a></td><td> = </td><td>7</td><td><div class="comment">the domain is suspended by guest power management</div></td></tr><tr><td><a name="VIR_DOMAIN_LAST" id="VIR_DOMAIN_LAST">VIR_DOMAIN_LAST</a></td><td> = </td><td>8</td><td><div class="comment">NB: this enum value will increase over time as new events are added to the libvirt API. It reflects the last state supported by this version of the libvirt API.</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainUndefineFlagsValues" id="virDomainUndefineFlagsValues"><code>virDomainUndefineFlagsValues</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainUndefineFlagsValues {
</pre><table><tr><td><a name="VIR_DOMAIN_UNDEFINE_MANAGED_SAVE" id="VIR_DOMAIN_UNDEFINE_MANAGED_SAVE">VIR_DOMAIN_UNDEFINE_MANAGED_SAVE</a></td><td> = </td><td>1</td><td><div class="comment">Also remove any managed save</div></td></tr><tr><td><a name="VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA" id="VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA">VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA</a></td><td> = </td><td>2</td><td><div class="comment">If last use of domain, then also remove any snapshot metadata Future undefine control flags should come here.</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainVcpuFlags" id="virDomainVcpuFlags"><code>virDomainVcpuFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainVcpuFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_VCPU_CONFIG" id="VIR_DOMAIN_VCPU_CONFIG">VIR_DOMAIN_VCPU_CONFIG</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_CONFIG</td><td><div class="comment">Additionally, these flags may be bitwise-OR'd in.</div></td></tr><tr><td><a name="VIR_DOMAIN_VCPU_CURRENT" id="VIR_DOMAIN_VCPU_CURRENT">VIR_DOMAIN_VCPU_CURRENT</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_CURRENT</td></tr><tr><td><a name="VIR_DOMAIN_VCPU_LIVE" id="VIR_DOMAIN_VCPU_LIVE">VIR_DOMAIN_VCPU_LIVE</a></td><td> = </td><td>VIR_DOMAIN_AFFECT_LIVE</td></tr><tr><td><a name="VIR_DOMAIN_VCPU_MAXIMUM" id="VIR_DOMAIN_VCPU_MAXIMUM">VIR_DOMAIN_VCPU_MAXIMUM</a></td><td> = </td><td>4</td><td><div class="comment">Max rather than current count</div></td></tr><tr><td><a name="VIR_DOMAIN_VCPU_GUEST" id="VIR_DOMAIN_VCPU_GUEST">VIR_DOMAIN_VCPU_GUEST</a></td><td> = </td><td>8</td><td><div class="comment">Modify state of the cpu in the guest</div></td></tr></table><pre>}
</pre></div><h3><a name="virDomainXMLFlags" id="virDomainXMLFlags"><code>virDomainXMLFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virDomainXMLFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_XML_SECURE" id="VIR_DOMAIN_XML_SECURE">VIR_DOMAIN_XML_SECURE</a></td><td> = </td><td>1</td><td><div class="comment">dump security sensitive information too</div></td></tr><tr><td><a name="VIR_DOMAIN_XML_INACTIVE" id="VIR_DOMAIN_XML_INACTIVE">VIR_DOMAIN_XML_INACTIVE</a></td><td> = </td><td>2</td><td><div class="comment">dump inactive domain information</div></td></tr><tr><td><a name="VIR_DOMAIN_XML_UPDATE_CPU" id="VIR_DOMAIN_XML_UPDATE_CPU">VIR_DOMAIN_XML_UPDATE_CPU</a></td><td> = </td><td>4</td><td><div class="comment">update guest CPU requirements according to host CPU</div></td></tr><tr><td><a name="VIR_DOMAIN_XML_MIGRATABLE" id="VIR_DOMAIN_XML_MIGRATABLE">VIR_DOMAIN_XML_MIGRATABLE</a></td><td> = </td><td>8</td><td><div class="comment">dump XML suitable for migration</div></td></tr></table><pre>}
</pre></div><h3><a name="virEventHandleType" id="virEventHandleType"><code>virEventHandleType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virEventHandleType {
</pre><table><tr><td><a name="VIR_EVENT_HANDLE_READABLE" id="VIR_EVENT_HANDLE_READABLE">VIR_EVENT_HANDLE_READABLE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_EVENT_HANDLE_WRITABLE" id="VIR_EVENT_HANDLE_WRITABLE">VIR_EVENT_HANDLE_WRITABLE</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_EVENT_HANDLE_ERROR" id="VIR_EVENT_HANDLE_ERROR">VIR_EVENT_HANDLE_ERROR</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_EVENT_HANDLE_HANGUP" id="VIR_EVENT_HANDLE_HANGUP">VIR_EVENT_HANDLE_HANGUP</a></td><td> = </td><td>8</td></tr></table><pre>}
</pre></div><h3><a name="virInterface" id="virInterface"><code>virInterface</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virInterface {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virInterfaceXMLFlags" id="virInterfaceXMLFlags"><code>virInterfaceXMLFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virInterfaceXMLFlags {
</pre><table><tr><td><a name="VIR_INTERFACE_XML_INACTIVE" id="VIR_INTERFACE_XML_INACTIVE">VIR_INTERFACE_XML_INACTIVE</a></td><td> = </td><td>1</td><td><div class="comment">dump inactive interface information</div></td></tr></table><pre>}
</pre></div><h3><a name="virKeycodeSet" id="virKeycodeSet"><code>virKeycodeSet</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virKeycodeSet {
</pre><table><tr><td><a name="VIR_KEYCODE_SET_LINUX" id="VIR_KEYCODE_SET_LINUX">VIR_KEYCODE_SET_LINUX</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_KEYCODE_SET_XT" id="VIR_KEYCODE_SET_XT">VIR_KEYCODE_SET_XT</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_KEYCODE_SET_ATSET1" id="VIR_KEYCODE_SET_ATSET1">VIR_KEYCODE_SET_ATSET1</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_KEYCODE_SET_ATSET2" id="VIR_KEYCODE_SET_ATSET2">VIR_KEYCODE_SET_ATSET2</a></td><td> = </td><td>3</td></tr><tr><td><a name="VIR_KEYCODE_SET_ATSET3" id="VIR_KEYCODE_SET_ATSET3">VIR_KEYCODE_SET_ATSET3</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_KEYCODE_SET_OSX" id="VIR_KEYCODE_SET_OSX">VIR_KEYCODE_SET_OSX</a></td><td> = </td><td>5</td></tr><tr><td><a name="VIR_KEYCODE_SET_XT_KBD" id="VIR_KEYCODE_SET_XT_KBD">VIR_KEYCODE_SET_XT_KBD</a></td><td> = </td><td>6</td></tr><tr><td><a name="VIR_KEYCODE_SET_USB" id="VIR_KEYCODE_SET_USB">VIR_KEYCODE_SET_USB</a></td><td> = </td><td>7</td></tr><tr><td><a name="VIR_KEYCODE_SET_WIN32" id="VIR_KEYCODE_SET_WIN32">VIR_KEYCODE_SET_WIN32</a></td><td> = </td><td>8</td></tr><tr><td><a name="VIR_KEYCODE_SET_RFB" id="VIR_KEYCODE_SET_RFB">VIR_KEYCODE_SET_RFB</a></td><td> = </td><td>9</td></tr><tr><td><a name="VIR_KEYCODE_SET_LAST" id="VIR_KEYCODE_SET_LAST">VIR_KEYCODE_SET_LAST</a></td><td> = </td><td>10</td><td><div class="comment">NB: this enum value will increase over time as new events are added to the libvirt API. It reflects the last keycode set supported by this version of the libvirt API.</div></td></tr></table><pre>}
</pre></div><h3><a name="virMemoryParameter" id="virMemoryParameter"><code>virMemoryParameter</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virMemoryParameter {
</pre><table><tr><td><span class="type">char field[VIR_TYPED_PARAM_FIELD_LENGTH]</span></td><td>field</td><td><div class="comment">parameter name</div></td></tr><tr><td><span class="type">int</span></td><td>type</td><td><div class="comment">parameter type, <a href="libvirt-libvirt.html#virTypedParameterType">virTypedParameterType</a></div></td></tr><tr><td><span class="keyword">union</span> {</td></tr><tr><td><table><tr><td><span class="type">int</span></td><td>i</td><td><div class="comment">type is INT</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>ui</td><td><div class="comment">type is UINT</div></td></tr><tr><td><span class="type">long long int</span></td><td>l</td><td><div class="comment">type is LLONG</div></td></tr><tr><td><span class="type">unsigned long long int</span></td><td>ul</td><td><div class="comment">type is ULLONG</div></td></tr><tr><td><span class="type">double</span></td><td>d</td><td><div class="comment">type is DOUBLE</div></td></tr><tr><td><span class="type">char</span></td><td>b</td><td><div class="comment">type is BOOLEAN</div></td></tr><tr><td><span class="type">char *</span></td><td>s</td><td><div class="comment">type is STRING, may not be NULL</div></td></tr></table></td><td></td></tr><tr><td>}</td><td>value</td><td><div class="comment">parameter value</div></td><td></td></tr></table><pre>
}
</pre></div><h3><a name="virMemoryParameterType" id="virMemoryParameterType"><code>virMemoryParameterType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virMemoryParameterType {
</pre><table><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_BOOLEAN" id="VIR_DOMAIN_MEMORY_PARAM_BOOLEAN">VIR_DOMAIN_MEMORY_PARAM_BOOLEAN</a></td><td> = </td><td>VIR_TYPED_PARAM_BOOLEAN</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_DOUBLE" id="VIR_DOMAIN_MEMORY_PARAM_DOUBLE">VIR_DOMAIN_MEMORY_PARAM_DOUBLE</a></td><td> = </td><td>VIR_TYPED_PARAM_DOUBLE</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_INT" id="VIR_DOMAIN_MEMORY_PARAM_INT">VIR_DOMAIN_MEMORY_PARAM_INT</a></td><td> = </td><td>VIR_TYPED_PARAM_INT</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_LLONG" id="VIR_DOMAIN_MEMORY_PARAM_LLONG">VIR_DOMAIN_MEMORY_PARAM_LLONG</a></td><td> = </td><td>VIR_TYPED_PARAM_LLONG</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_UINT" id="VIR_DOMAIN_MEMORY_PARAM_UINT">VIR_DOMAIN_MEMORY_PARAM_UINT</a></td><td> = </td><td>VIR_TYPED_PARAM_UINT</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_ULLONG" id="VIR_DOMAIN_MEMORY_PARAM_ULLONG">VIR_DOMAIN_MEMORY_PARAM_ULLONG</a></td><td> = </td><td>VIR_TYPED_PARAM_ULLONG</td></tr></table><pre>}
</pre></div><h3><a name="virNWFilter" id="virNWFilter"><code>virNWFilter</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virNWFilter {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virNetwork" id="virNetwork"><code>virNetwork</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virNetwork {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virNetworkUpdateCommand" id="virNetworkUpdateCommand"><code>virNetworkUpdateCommand</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virNetworkUpdateCommand {
</pre><table><tr><td><a name="VIR_NETWORK_UPDATE_COMMAND_NONE" id="VIR_NETWORK_UPDATE_COMMAND_NONE">VIR_NETWORK_UPDATE_COMMAND_NONE</a></td><td> = </td><td>0</td><td><div class="comment">(invalid)</div></td></tr><tr><td><a name="VIR_NETWORK_UPDATE_COMMAND_MODIFY" id="VIR_NETWORK_UPDATE_COMMAND_MODIFY">VIR_NETWORK_UPDATE_COMMAND_MODIFY</a></td><td> = </td><td>1</td><td><div class="comment">modify an existing element</div></td></tr><tr><td><a name="VIR_NETWORK_UPDATE_COMMAND_DELETE" id="VIR_NETWORK_UPDATE_COMMAND_DELETE">VIR_NETWORK_UPDATE_COMMAND_DELETE</a></td><td> = </td><td>2</td><td><div class="comment">delete an existing element</div></td></tr><tr><td><a name="VIR_NETWORK_UPDATE_COMMAND_ADD_LAST" id="VIR_NETWORK_UPDATE_COMMAND_ADD_LAST">VIR_NETWORK_UPDATE_COMMAND_ADD_LAST</a></td><td> = </td><td>3</td><td><div class="comment">add an element at end of list</div></td></tr><tr><td><a name="VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST" id="VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST">VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST</a></td><td> = </td><td>4</td><td><div class="comment">add an element at start of list</div></td></tr><tr><td><a name="VIR_NETWORK_UPDATE_COMMAND_LAST" id="VIR_NETWORK_UPDATE_COMMAND_LAST">VIR_NETWORK_UPDATE_COMMAND_LAST</a></td><td> = </td><td>5</td></tr></table><pre>}
</pre></div><h3><a name="virNetworkUpdateFlags" id="virNetworkUpdateFlags"><code>virNetworkUpdateFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virNetworkUpdateFlags {
</pre><table><tr><td><a name="VIR_NETWORK_UPDATE_AFFECT_CURRENT" id="VIR_NETWORK_UPDATE_AFFECT_CURRENT">VIR_NETWORK_UPDATE_AFFECT_CURRENT</a></td><td> = </td><td>0</td><td><div class="comment">affect live if network is active, config if it's not active</div></td></tr><tr><td><a name="VIR_NETWORK_UPDATE_AFFECT_LIVE" id="VIR_NETWORK_UPDATE_AFFECT_LIVE">VIR_NETWORK_UPDATE_AFFECT_LIVE</a></td><td> = </td><td>1</td><td><div class="comment">affect live state of network only</div></td></tr><tr><td><a name="VIR_NETWORK_UPDATE_AFFECT_CONFIG" id="VIR_NETWORK_UPDATE_AFFECT_CONFIG">VIR_NETWORK_UPDATE_AFFECT_CONFIG</a></td><td> = </td><td>2</td><td><div class="comment">affect persistent config only</div></td></tr></table><pre>}
</pre></div><h3><a name="virNetworkUpdateSection" id="virNetworkUpdateSection"><code>virNetworkUpdateSection</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virNetworkUpdateSection {
</pre><table><tr><td><a name="VIR_NETWORK_SECTION_NONE" id="VIR_NETWORK_SECTION_NONE">VIR_NETWORK_SECTION_NONE</a></td><td> = </td><td>0</td><td><div class="comment">(invalid)</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_BRIDGE" id="VIR_NETWORK_SECTION_BRIDGE">VIR_NETWORK_SECTION_BRIDGE</a></td><td> = </td><td>1</td><td><div class="comment">&lt;bridge&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_DOMAIN" id="VIR_NETWORK_SECTION_DOMAIN">VIR_NETWORK_SECTION_DOMAIN</a></td><td> = </td><td>2</td><td><div class="comment">&lt;domain&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_IP" id="VIR_NETWORK_SECTION_IP">VIR_NETWORK_SECTION_IP</a></td><td> = </td><td>3</td><td><div class="comment">&lt;ip&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_IP_DHCP_HOST" id="VIR_NETWORK_SECTION_IP_DHCP_HOST">VIR_NETWORK_SECTION_IP_DHCP_HOST</a></td><td> = </td><td>4</td><td><div class="comment">&lt;ip&gt;/&lt;dhcp&gt;/&lt;host&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_IP_DHCP_RANGE" id="VIR_NETWORK_SECTION_IP_DHCP_RANGE">VIR_NETWORK_SECTION_IP_DHCP_RANGE</a></td><td> = </td><td>5</td><td><div class="comment">&lt;ip&gt;/&lt;dhcp&gt;/&lt;range&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_FORWARD" id="VIR_NETWORK_SECTION_FORWARD">VIR_NETWORK_SECTION_FORWARD</a></td><td> = </td><td>6</td><td><div class="comment">&lt;forward&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_FORWARD_INTERFACE" id="VIR_NETWORK_SECTION_FORWARD_INTERFACE">VIR_NETWORK_SECTION_FORWARD_INTERFACE</a></td><td> = </td><td>7</td><td><div class="comment">&lt;forward&gt;/&lt;interface&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_FORWARD_PF" id="VIR_NETWORK_SECTION_FORWARD_PF">VIR_NETWORK_SECTION_FORWARD_PF</a></td><td> = </td><td>8</td><td><div class="comment">&lt;forward&gt;/&lt;pf&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_PORTGROUP" id="VIR_NETWORK_SECTION_PORTGROUP">VIR_NETWORK_SECTION_PORTGROUP</a></td><td> = </td><td>9</td><td><div class="comment">&lt;portgroup&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_DNS_HOST" id="VIR_NETWORK_SECTION_DNS_HOST">VIR_NETWORK_SECTION_DNS_HOST</a></td><td> = </td><td>10</td><td><div class="comment">&lt;dns&gt;/&lt;host&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_DNS_TXT" id="VIR_NETWORK_SECTION_DNS_TXT">VIR_NETWORK_SECTION_DNS_TXT</a></td><td> = </td><td>11</td><td><div class="comment">&lt;dns&gt;/&lt;txt&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_DNS_SRV" id="VIR_NETWORK_SECTION_DNS_SRV">VIR_NETWORK_SECTION_DNS_SRV</a></td><td> = </td><td>12</td><td><div class="comment">&lt;dns&gt;/&lt;srv&gt;</div></td></tr><tr><td><a name="VIR_NETWORK_SECTION_LAST" id="VIR_NETWORK_SECTION_LAST">VIR_NETWORK_SECTION_LAST</a></td><td> = </td><td>13</td></tr></table><pre>}
</pre></div><h3><a name="virNetworkXMLFlags" id="virNetworkXMLFlags"><code>virNetworkXMLFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virNetworkXMLFlags {
</pre><table><tr><td><a name="VIR_NETWORK_XML_INACTIVE" id="VIR_NETWORK_XML_INACTIVE">VIR_NETWORK_XML_INACTIVE</a></td><td> = </td><td>1</td><td><div class="comment">dump inactive network information</div></td></tr></table><pre>}
</pre></div><h3><a name="virNodeCPUStats" id="virNodeCPUStats"><code>virNodeCPUStats</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virNodeCPUStats {
</pre><table><tr><td><span class="type">char field[VIR_NODE_CPU_STATS_FIELD_LENGTH]</span></td><td>field</td></tr><tr><td><span class="type">unsigned long long</span></td><td>value</td></tr></table><pre>
}
</pre></div><h3><a name="virNodeDevice" id="virNodeDevice"><code>virNodeDevice</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virNodeDevice {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virNodeGetCPUStatsAllCPUs" id="virNodeGetCPUStatsAllCPUs"><code>virNodeGetCPUStatsAllCPUs</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virNodeGetCPUStatsAllCPUs {
</pre><table><tr><td><a name="VIR_NODE_CPU_STATS_ALL_CPUS" id="VIR_NODE_CPU_STATS_ALL_CPUS">VIR_NODE_CPU_STATS_ALL_CPUS</a></td><td> = </td><td>-1</td></tr></table><pre>}
</pre></div><h3><a name="virNodeGetMemoryStatsAllCells" id="virNodeGetMemoryStatsAllCells"><code>virNodeGetMemoryStatsAllCells</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virNodeGetMemoryStatsAllCells {
</pre><table><tr><td><a name="VIR_NODE_MEMORY_STATS_ALL_CELLS" id="VIR_NODE_MEMORY_STATS_ALL_CELLS">VIR_NODE_MEMORY_STATS_ALL_CELLS</a></td><td> = </td><td>-1</td></tr></table><pre>}
</pre></div><h3><a name="virNodeInfo" id="virNodeInfo"><code>virNodeInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virNodeInfo {
</pre><table><tr><td><span class="type">char model[32]</span></td><td>model</td><td><div class="comment">string indicating the CPU model</div></td></tr><tr><td><span class="type">unsigned long</span></td><td>memory</td><td><div class="comment">memory size in kilobytes</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>cpus</td><td><div class="comment">the number of active CPUs</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>mhz</td><td><div class="comment">expected CPU frequency</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>nodes</td><td><div class="comment">the number of NUMA cell, 1 for unusual NUMA topologies or uniform memory access; check capabilities XML for the actual NUMA topology</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>sockets</td><td><div class="comment">number of CPU sockets per node if nodes &gt; 1, 1 in case of unusual NUMA topology</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>cores</td><td><div class="comment">number of cores per socket, total number of processors in case of unusual NUMA topolog</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>threads</td><td><div class="comment">number of threads per core, 1 in case of unusual numa topology</div></td></tr></table><pre>
}
</pre></div><h3><a name="virNodeMemoryStats" id="virNodeMemoryStats"><code>virNodeMemoryStats</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virNodeMemoryStats {
</pre><table><tr><td><span class="type">char field[VIR_NODE_MEMORY_STATS_FIELD_LENGTH]</span></td><td>field</td></tr><tr><td><span class="type">unsigned long long</span></td><td>value</td></tr></table><pre>
}
</pre></div><h3><a name="virNodeSuspendTarget" id="virNodeSuspendTarget"><code>virNodeSuspendTarget</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virNodeSuspendTarget {
</pre><table><tr><td><a name="VIR_NODE_SUSPEND_TARGET_MEM" id="VIR_NODE_SUSPEND_TARGET_MEM">VIR_NODE_SUSPEND_TARGET_MEM</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_NODE_SUSPEND_TARGET_DISK" id="VIR_NODE_SUSPEND_TARGET_DISK">VIR_NODE_SUSPEND_TARGET_DISK</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_NODE_SUSPEND_TARGET_HYBRID" id="VIR_NODE_SUSPEND_TARGET_HYBRID">VIR_NODE_SUSPEND_TARGET_HYBRID</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_NODE_SUSPEND_TARGET_LAST" id="VIR_NODE_SUSPEND_TARGET_LAST">VIR_NODE_SUSPEND_TARGET_LAST</a></td><td> = </td><td>3</td><td><div class="comment">This constant is subject to change</div></td></tr></table><pre>}
</pre></div><h3><a name="virSchedParameter" id="virSchedParameter"><code>virSchedParameter</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virSchedParameter {
</pre><table><tr><td><span class="type">char field[VIR_TYPED_PARAM_FIELD_LENGTH]</span></td><td>field</td><td><div class="comment">parameter name</div></td></tr><tr><td><span class="type">int</span></td><td>type</td><td><div class="comment">parameter type, <a href="libvirt-libvirt.html#virTypedParameterType">virTypedParameterType</a></div></td></tr><tr><td><span class="keyword">union</span> {</td></tr><tr><td><table><tr><td><span class="type">int</span></td><td>i</td><td><div class="comment">type is INT</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>ui</td><td><div class="comment">type is UINT</div></td></tr><tr><td><span class="type">long long int</span></td><td>l</td><td><div class="comment">type is LLONG</div></td></tr><tr><td><span class="type">unsigned long long int</span></td><td>ul</td><td><div class="comment">type is ULLONG</div></td></tr><tr><td><span class="type">double</span></td><td>d</td><td><div class="comment">type is DOUBLE</div></td></tr><tr><td><span class="type">char</span></td><td>b</td><td><div class="comment">type is BOOLEAN</div></td></tr><tr><td><span class="type">char *</span></td><td>s</td><td><div class="comment">type is STRING, may not be NULL</div></td></tr></table></td><td></td></tr><tr><td>}</td><td>value</td><td><div class="comment">parameter value</div></td><td></td></tr></table><pre>
}
</pre></div><h3><a name="virSchedParameterType" id="virSchedParameterType"><code>virSchedParameterType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virSchedParameterType {
</pre><table><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_BOOLEAN" id="VIR_DOMAIN_SCHED_FIELD_BOOLEAN">VIR_DOMAIN_SCHED_FIELD_BOOLEAN</a></td><td> = </td><td>VIR_TYPED_PARAM_BOOLEAN</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_DOUBLE" id="VIR_DOMAIN_SCHED_FIELD_DOUBLE">VIR_DOMAIN_SCHED_FIELD_DOUBLE</a></td><td> = </td><td>VIR_TYPED_PARAM_DOUBLE</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_INT" id="VIR_DOMAIN_SCHED_FIELD_INT">VIR_DOMAIN_SCHED_FIELD_INT</a></td><td> = </td><td>VIR_TYPED_PARAM_INT</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_LLONG" id="VIR_DOMAIN_SCHED_FIELD_LLONG">VIR_DOMAIN_SCHED_FIELD_LLONG</a></td><td> = </td><td>VIR_TYPED_PARAM_LLONG</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_UINT" id="VIR_DOMAIN_SCHED_FIELD_UINT">VIR_DOMAIN_SCHED_FIELD_UINT</a></td><td> = </td><td>VIR_TYPED_PARAM_UINT</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_ULLONG" id="VIR_DOMAIN_SCHED_FIELD_ULLONG">VIR_DOMAIN_SCHED_FIELD_ULLONG</a></td><td> = </td><td>VIR_TYPED_PARAM_ULLONG</td></tr></table><pre>}
</pre></div><h3><a name="virSecret" id="virSecret"><code>virSecret</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virSecret {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virSecretUsageType" id="virSecretUsageType"><code>virSecretUsageType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virSecretUsageType {
</pre><table><tr><td><a name="VIR_SECRET_USAGE_TYPE_NONE" id="VIR_SECRET_USAGE_TYPE_NONE">VIR_SECRET_USAGE_TYPE_NONE</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_SECRET_USAGE_TYPE_VOLUME" id="VIR_SECRET_USAGE_TYPE_VOLUME">VIR_SECRET_USAGE_TYPE_VOLUME</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_SECRET_USAGE_TYPE_CEPH" id="VIR_SECRET_USAGE_TYPE_CEPH">VIR_SECRET_USAGE_TYPE_CEPH</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_SECRET_USAGE_TYPE_ISCSI" id="VIR_SECRET_USAGE_TYPE_ISCSI">VIR_SECRET_USAGE_TYPE_ISCSI</a></td><td> = </td><td>3</td></tr><tr><td><a name="VIR_SECRET_USAGE_TYPE_LAST" id="VIR_SECRET_USAGE_TYPE_LAST">VIR_SECRET_USAGE_TYPE_LAST</a></td><td> = </td><td>4</td><td><div class="comment">NB: this enum value will increase over time as new events are added to the libvirt API. It reflects the last secret owner ID supported by this version of the libvirt API.</div></td></tr></table><pre>}
</pre></div><h3><a name="virSecurityLabel" id="virSecurityLabel"><code>virSecurityLabel</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virSecurityLabel {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virSecurityModel" id="virSecurityModel"><code>virSecurityModel</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virSecurityModel {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virStoragePool" id="virStoragePool"><code>virStoragePool</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virStoragePool {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virStoragePoolBuildFlags" id="virStoragePoolBuildFlags"><code>virStoragePoolBuildFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStoragePoolBuildFlags {
</pre><table><tr><td><a name="VIR_STORAGE_POOL_BUILD_NEW" id="VIR_STORAGE_POOL_BUILD_NEW">VIR_STORAGE_POOL_BUILD_NEW</a></td><td> = </td><td>0</td><td><div class="comment">Regular build from scratch</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_BUILD_REPAIR" id="VIR_STORAGE_POOL_BUILD_REPAIR">VIR_STORAGE_POOL_BUILD_REPAIR</a></td><td> = </td><td>1</td><td><div class="comment">Repair / reinitialize</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_BUILD_RESIZE" id="VIR_STORAGE_POOL_BUILD_RESIZE">VIR_STORAGE_POOL_BUILD_RESIZE</a></td><td> = </td><td>2</td><td><div class="comment">Extend existing pool</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_BUILD_NO_OVERWRITE" id="VIR_STORAGE_POOL_BUILD_NO_OVERWRITE">VIR_STORAGE_POOL_BUILD_NO_OVERWRITE</a></td><td> = </td><td>4</td><td><div class="comment">Do not overwrite existing pool</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_BUILD_OVERWRITE" id="VIR_STORAGE_POOL_BUILD_OVERWRITE">VIR_STORAGE_POOL_BUILD_OVERWRITE</a></td><td> = </td><td>8</td><td><div class="comment">Overwrite data</div></td></tr></table><pre>}
</pre></div><h3><a name="virStoragePoolDeleteFlags" id="virStoragePoolDeleteFlags"><code>virStoragePoolDeleteFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStoragePoolDeleteFlags {
</pre><table><tr><td><a name="VIR_STORAGE_POOL_DELETE_NORMAL" id="VIR_STORAGE_POOL_DELETE_NORMAL">VIR_STORAGE_POOL_DELETE_NORMAL</a></td><td> = </td><td>0</td><td><div class="comment">Delete metadata only (fast)</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_DELETE_ZEROED" id="VIR_STORAGE_POOL_DELETE_ZEROED">VIR_STORAGE_POOL_DELETE_ZEROED</a></td><td> = </td><td>1</td><td><div class="comment">Clear all data to zeros (slow)</div></td></tr></table><pre>}
</pre></div><h3><a name="virStoragePoolInfo" id="virStoragePoolInfo"><code>virStoragePoolInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virStoragePoolInfo {
</pre><table><tr><td><span class="type">int</span></td><td>state</td><td><div class="comment"><a href="libvirt-libvirt.html#virStoragePoolState">virStoragePoolState</a> flags</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>capacity</td><td><div class="comment">Logical size bytes</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>allocation</td><td><div class="comment">Current allocation bytes</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>available</td><td><div class="comment">Remaining free space bytes</div></td></tr></table><pre>
}
</pre></div><h3><a name="virStoragePoolState" id="virStoragePoolState"><code>virStoragePoolState</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStoragePoolState {
</pre><table><tr><td><a name="VIR_STORAGE_POOL_INACTIVE" id="VIR_STORAGE_POOL_INACTIVE">VIR_STORAGE_POOL_INACTIVE</a></td><td> = </td><td>0</td><td><div class="comment">Not running</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_BUILDING" id="VIR_STORAGE_POOL_BUILDING">VIR_STORAGE_POOL_BUILDING</a></td><td> = </td><td>1</td><td><div class="comment">Initializing pool, not available</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_RUNNING" id="VIR_STORAGE_POOL_RUNNING">VIR_STORAGE_POOL_RUNNING</a></td><td> = </td><td>2</td><td><div class="comment">Running normally</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_DEGRADED" id="VIR_STORAGE_POOL_DEGRADED">VIR_STORAGE_POOL_DEGRADED</a></td><td> = </td><td>3</td><td><div class="comment">Running degraded</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_INACCESSIBLE" id="VIR_STORAGE_POOL_INACCESSIBLE">VIR_STORAGE_POOL_INACCESSIBLE</a></td><td> = </td><td>4</td><td><div class="comment">Running, but not accessible</div></td></tr><tr><td><a name="VIR_STORAGE_POOL_STATE_LAST" id="VIR_STORAGE_POOL_STATE_LAST">VIR_STORAGE_POOL_STATE_LAST</a></td><td> = </td><td>5</td></tr></table><pre>}
</pre></div><h3><a name="virStorageVol" id="virStorageVol"><code>virStorageVol</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virStorageVol {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virStorageVolCreateFlags" id="virStorageVolCreateFlags"><code>virStorageVolCreateFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStorageVolCreateFlags {
</pre><table><tr><td><a name="VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA" id="VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA">VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virStorageVolDeleteFlags" id="virStorageVolDeleteFlags"><code>virStorageVolDeleteFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStorageVolDeleteFlags {
</pre><table><tr><td><a name="VIR_STORAGE_VOL_DELETE_NORMAL" id="VIR_STORAGE_VOL_DELETE_NORMAL">VIR_STORAGE_VOL_DELETE_NORMAL</a></td><td> = </td><td>0</td><td><div class="comment">Delete metadata only (fast)</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_DELETE_ZEROED" id="VIR_STORAGE_VOL_DELETE_ZEROED">VIR_STORAGE_VOL_DELETE_ZEROED</a></td><td> = </td><td>1</td><td><div class="comment">Clear all data to zeros (slow)</div></td></tr></table><pre>}
</pre></div><h3><a name="virStorageVolInfo" id="virStorageVolInfo"><code>virStorageVolInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virStorageVolInfo {
</pre><table><tr><td><span class="type">int</span></td><td>type</td><td><div class="comment"><a href="libvirt-libvirt.html#virStorageVolType">virStorageVolType</a> flags</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>capacity</td><td><div class="comment">Logical size bytes</div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>allocation</td><td><div class="comment">Current allocation bytes</div></td></tr></table><pre>
}
</pre></div><h3><a name="virStorageVolResizeFlags" id="virStorageVolResizeFlags"><code>virStorageVolResizeFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStorageVolResizeFlags {
</pre><table><tr><td><a name="VIR_STORAGE_VOL_RESIZE_ALLOCATE" id="VIR_STORAGE_VOL_RESIZE_ALLOCATE">VIR_STORAGE_VOL_RESIZE_ALLOCATE</a></td><td> = </td><td>1</td><td><div class="comment">force allocation of new size</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_RESIZE_DELTA" id="VIR_STORAGE_VOL_RESIZE_DELTA">VIR_STORAGE_VOL_RESIZE_DELTA</a></td><td> = </td><td>2</td><td><div class="comment">size is relative to current</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_RESIZE_SHRINK" id="VIR_STORAGE_VOL_RESIZE_SHRINK">VIR_STORAGE_VOL_RESIZE_SHRINK</a></td><td> = </td><td>4</td><td><div class="comment">allow decrease in capacity</div></td></tr></table><pre>}
</pre></div><h3><a name="virStorageVolType" id="virStorageVolType"><code>virStorageVolType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStorageVolType {
</pre><table><tr><td><a name="VIR_STORAGE_VOL_FILE" id="VIR_STORAGE_VOL_FILE">VIR_STORAGE_VOL_FILE</a></td><td> = </td><td>0</td><td><div class="comment">Regular file based volumes</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_BLOCK" id="VIR_STORAGE_VOL_BLOCK">VIR_STORAGE_VOL_BLOCK</a></td><td> = </td><td>1</td><td><div class="comment">Block based volumes</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_DIR" id="VIR_STORAGE_VOL_DIR">VIR_STORAGE_VOL_DIR</a></td><td> = </td><td>2</td><td><div class="comment">Directory-passthrough based volume</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_NETWORK" id="VIR_STORAGE_VOL_NETWORK">VIR_STORAGE_VOL_NETWORK</a></td><td> = </td><td>3</td><td><div class="comment">Network volumes like RBD (RADOS Block Device)</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_NETDIR" id="VIR_STORAGE_VOL_NETDIR">VIR_STORAGE_VOL_NETDIR</a></td><td> = </td><td>4</td><td><div class="comment">Network accessible directory that can contain other network volumes</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_LAST" id="VIR_STORAGE_VOL_LAST">VIR_STORAGE_VOL_LAST</a></td><td> = </td><td>5</td></tr></table><pre>}
</pre></div><h3><a name="virStorageVolWipeAlgorithm" id="virStorageVolWipeAlgorithm"><code>virStorageVolWipeAlgorithm</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStorageVolWipeAlgorithm {
</pre><table><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_ZERO" id="VIR_STORAGE_VOL_WIPE_ALG_ZERO">VIR_STORAGE_VOL_WIPE_ALG_ZERO</a></td><td> = </td><td>0</td><td><div class="comment">1-pass, all zeroes</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_NNSA" id="VIR_STORAGE_VOL_WIPE_ALG_NNSA">VIR_STORAGE_VOL_WIPE_ALG_NNSA</a></td><td> = </td><td>1</td><td><div class="comment">4-pass NNSA Policy Letter NAP-14.1-C (XVI-8)</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_DOD" id="VIR_STORAGE_VOL_WIPE_ALG_DOD">VIR_STORAGE_VOL_WIPE_ALG_DOD</a></td><td> = </td><td>2</td><td><div class="comment">4-pass DoD 5220.22-M section 8-306 procedure</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_BSI" id="VIR_STORAGE_VOL_WIPE_ALG_BSI">VIR_STORAGE_VOL_WIPE_ALG_BSI</a></td><td> = </td><td>3</td><td><div class="comment">9-pass method recommended by the German Center of Security in Information Technologies</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_GUTMANN" id="VIR_STORAGE_VOL_WIPE_ALG_GUTMANN">VIR_STORAGE_VOL_WIPE_ALG_GUTMANN</a></td><td> = </td><td>4</td><td><div class="comment">The canonical 35-pass sequence</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER" id="VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER">VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER</a></td><td> = </td><td>5</td><td><div class="comment">7-pass method described by Bruce Schneier in "Applied Cryptography" (1996)</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7" id="VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7">VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7</a></td><td> = </td><td>6</td><td><div class="comment">7-pass random</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33" id="VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33">VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33</a></td><td> = </td><td>7</td><td><div class="comment">33-pass random</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_RANDOM" id="VIR_STORAGE_VOL_WIPE_ALG_RANDOM">VIR_STORAGE_VOL_WIPE_ALG_RANDOM</a></td><td> = </td><td>8</td><td><div class="comment">1-pass random</div></td></tr><tr><td><a name="VIR_STORAGE_VOL_WIPE_ALG_LAST" id="VIR_STORAGE_VOL_WIPE_ALG_LAST">VIR_STORAGE_VOL_WIPE_ALG_LAST</a></td><td> = </td><td>9</td><td><div class="comment">NB: this enum value will increase over time as new algorithms are added to the libvirt API. It reflects the last algorithm supported by this version of the libvirt API.</div></td></tr></table><pre>}
</pre></div><h3><a name="virStorageXMLFlags" id="virStorageXMLFlags"><code>virStorageXMLFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStorageXMLFlags {
</pre><table><tr><td><a name="VIR_STORAGE_XML_INACTIVE" id="VIR_STORAGE_XML_INACTIVE">VIR_STORAGE_XML_INACTIVE</a></td><td> = </td><td>1</td><td><div class="comment">dump inactive pool/volume information</div></td></tr></table><pre>}
</pre></div><h3><a name="virStream" id="virStream"><code>virStream</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virStream {
</pre><div class="undisclosed">The content of this structure is not made public by the API</div><pre>
}
</pre></div><h3><a name="virStreamEventType" id="virStreamEventType"><code>virStreamEventType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStreamEventType {
</pre><table><tr><td><a name="VIR_STREAM_EVENT_READABLE" id="VIR_STREAM_EVENT_READABLE">VIR_STREAM_EVENT_READABLE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_STREAM_EVENT_WRITABLE" id="VIR_STREAM_EVENT_WRITABLE">VIR_STREAM_EVENT_WRITABLE</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_STREAM_EVENT_ERROR" id="VIR_STREAM_EVENT_ERROR">VIR_STREAM_EVENT_ERROR</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_STREAM_EVENT_HANGUP" id="VIR_STREAM_EVENT_HANGUP">VIR_STREAM_EVENT_HANGUP</a></td><td> = </td><td>8</td></tr></table><pre>}
</pre></div><h3><a name="virStreamFlags" id="virStreamFlags"><code>virStreamFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virStreamFlags {
</pre><table><tr><td><a name="VIR_STREAM_NONBLOCK" id="VIR_STREAM_NONBLOCK">VIR_STREAM_NONBLOCK</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virTypedParameter" id="virTypedParameter"><code>virTypedParameter</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virTypedParameter {
</pre><table><tr><td><span class="type">char field[VIR_TYPED_PARAM_FIELD_LENGTH]</span></td><td>field</td><td><div class="comment">parameter name</div></td></tr><tr><td><span class="type">int</span></td><td>type</td><td><div class="comment">parameter type, <a href="libvirt-libvirt.html#virTypedParameterType">virTypedParameterType</a></div></td></tr><tr><td><span class="keyword">union</span> {</td></tr><tr><td><table><tr><td><span class="type">int</span></td><td>i</td><td><div class="comment">type is INT</div></td></tr><tr><td><span class="type">unsigned int</span></td><td>ui</td><td><div class="comment">type is UINT</div></td></tr><tr><td><span class="type">long long int</span></td><td>l</td><td><div class="comment">type is LLONG</div></td></tr><tr><td><span class="type">unsigned long long int</span></td><td>ul</td><td><div class="comment">type is ULLONG</div></td></tr><tr><td><span class="type">double</span></td><td>d</td><td><div class="comment">type is DOUBLE</div></td></tr><tr><td><span class="type">char</span></td><td>b</td><td><div class="comment">type is BOOLEAN</div></td></tr><tr><td><span class="type">char *</span></td><td>s</td><td><div class="comment">type is STRING, may not be NULL</div></td></tr></table></td><td></td></tr><tr><td>}</td><td>value</td><td><div class="comment">parameter value</div></td><td></td></tr></table><pre>
}
</pre></div><h3><a name="virTypedParameterFlags" id="virTypedParameterFlags"><code>virTypedParameterFlags</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virTypedParameterFlags {
</pre><table><tr><td><a name="VIR_TYPED_PARAM_STRING_OKAY" id="VIR_TYPED_PARAM_STRING_OKAY">VIR_TYPED_PARAM_STRING_OKAY</a></td><td> = </td><td>4</td></tr></table><pre>}
</pre></div><h3><a name="virTypedParameterType" id="virTypedParameterType"><code>virTypedParameterType</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virTypedParameterType {
</pre><table><tr><td><a name="VIR_TYPED_PARAM_INT" id="VIR_TYPED_PARAM_INT">VIR_TYPED_PARAM_INT</a></td><td> = </td><td>1</td><td><div class="comment">integer case</div></td></tr><tr><td><a name="VIR_TYPED_PARAM_UINT" id="VIR_TYPED_PARAM_UINT">VIR_TYPED_PARAM_UINT</a></td><td> = </td><td>2</td><td><div class="comment">unsigned integer case</div></td></tr><tr><td><a name="VIR_TYPED_PARAM_LLONG" id="VIR_TYPED_PARAM_LLONG">VIR_TYPED_PARAM_LLONG</a></td><td> = </td><td>3</td><td><div class="comment">long long case</div></td></tr><tr><td><a name="VIR_TYPED_PARAM_ULLONG" id="VIR_TYPED_PARAM_ULLONG">VIR_TYPED_PARAM_ULLONG</a></td><td> = </td><td>4</td><td><div class="comment">unsigned long long case</div></td></tr><tr><td><a name="VIR_TYPED_PARAM_DOUBLE" id="VIR_TYPED_PARAM_DOUBLE">VIR_TYPED_PARAM_DOUBLE</a></td><td> = </td><td>5</td><td><div class="comment">double case</div></td></tr><tr><td><a name="VIR_TYPED_PARAM_BOOLEAN" id="VIR_TYPED_PARAM_BOOLEAN">VIR_TYPED_PARAM_BOOLEAN</a></td><td> = </td><td>6</td><td><div class="comment">boolean(character) case</div></td></tr><tr><td><a name="VIR_TYPED_PARAM_STRING" id="VIR_TYPED_PARAM_STRING">VIR_TYPED_PARAM_STRING</a></td><td> = </td><td>7</td><td><div class="comment">string case</div></td></tr><tr><td><a name="VIR_TYPED_PARAM_LAST" id="VIR_TYPED_PARAM_LAST">VIR_TYPED_PARAM_LAST</a></td><td> = </td><td>8</td></tr></table><pre>}
</pre></div><h3><a name="virVcpuInfo" id="virVcpuInfo"><code>virVcpuInfo</code></a></h3><div class="api"><pre><span class="keyword">struct </span>virVcpuInfo {
</pre><table><tr><td><span class="type">unsigned int</span></td><td>number</td><td><div class="comment">virtual CPU number</div></td></tr><tr><td><span class="type">int</span></td><td>state</td><td><div class="comment">value from <a href="libvirt-libvirt.html#virVcpuState">virVcpuState</a></div></td></tr><tr><td><span class="type">unsigned long long</span></td><td>cpuTime</td><td><div class="comment">CPU time used, in nanoseconds</div></td></tr><tr><td><span class="type">int</span></td><td>cpu</td><td><div class="comment">real CPU number, or -1 if offline</div></td></tr></table><pre>
}
</pre></div><h3><a name="virVcpuState" id="virVcpuState"><code>virVcpuState</code></a></h3><div class="api"><pre><span class="keyword">enum</span> virVcpuState {
</pre><table><tr><td><a name="VIR_VCPU_OFFLINE" id="VIR_VCPU_OFFLINE">VIR_VCPU_OFFLINE</a></td><td> = </td><td>0</td><td><div class="comment">the virtual CPU is offline</div></td></tr><tr><td><a name="VIR_VCPU_RUNNING" id="VIR_VCPU_RUNNING">VIR_VCPU_RUNNING</a></td><td> = </td><td>1</td><td><div class="comment">the virtual CPU is running</div></td></tr><tr><td><a name="VIR_VCPU_BLOCKED" id="VIR_VCPU_BLOCKED">VIR_VCPU_BLOCKED</a></td><td> = </td><td>2</td><td><div class="comment">the virtual CPU is blocked on resource</div></td></tr><tr><td><a name="VIR_VCPU_LAST" id="VIR_VCPU_LAST">VIR_VCPU_LAST</a></td><td> = </td><td>3</td></tr></table><pre>}
</pre></div><h3><a name="functions" id="functions">Functions</a></h3><h3><a name="virConnectAuthCallbackPtr" id="virConnectAuthCallbackPtr"><code>virConnectAuthCallbackPtr</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virConnectAuthCallbackPtr)	(<span class="type"><a href="libvirt-libvirt.html#virConnectCredentialPtr">virConnectCredentialPtr</a></span> cred,
					 <span class="type">unsigned int</span> ncred,
					 <span class="type">void *</span> cbdata)
</pre><div class="description"><p>When authentication requires one or more interactions, this callback is invoked. For each interaction supplied, data must be gathered from the user and filled in to the 'result' and 'resultlen' fields. If an interaction cannot be filled, fill in NULL and 0.</p></div><dl class="variablelist"><dt>cred</dt><dd>list of <a href="libvirt-libvirt.html#virConnectCredential">virConnectCredential</a> object to fetch from user</dd><dt>ncred</dt><dd>size of cred list</dd><dt>cbdata</dt><dd>opaque data passed to <a href="libvirt-libvirt.html#virConnectOpenAuth">virConnectOpenAuth</a></dd><dt>Returns</dt><dd>0 if all interactions were filled, or -1 upon error</dd></dl><br /><h3><a name="virConnectBaselineCPU" id="virConnectBaselineCPU"><code>virConnectBaselineCPU</code></a></h3><pre class="api"><span class="type">char *</span>	virConnectBaselineCPU		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char **</span> xmlCPUs,
					 <span class="type">unsigned int</span> ncpus,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Computes the most feature-rich CPU which is compatible with all given host CPUs.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES">VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES</a> then libvirt will explicitly list all CPU features that are part of the host CPU, without this flag features that are part of the CPU model will not be listed.</p></div><dl class="variablelist"><dt>conn</dt><dd><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</dd><dt>xmlCPUs</dt><dd>array of XML descriptions of host CPUs</dd><dt>ncpus</dt><dd>number of CPUs in xmlCPUs</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virConnectBaselineCPUFlags">virConnectBaselineCPUFlags</a></dd><dt>Returns</dt><dd>XML description of the computed CPU or NULL on error.</dd></dl><div class="acl"></div><h3><a name="virConnectClose" id="virConnectClose"><code>virConnectClose</code></a></h3><pre class="api"><span class="type">int</span>	virConnectClose			(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>This function closes the connection to the Hypervisor. This should not be called if further interaction with the Hypervisor are needed especially if there is running domain which need further monitoring by the application.</p><p>Connections are reference counted; the count is explicitly increased by the initial open (<a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a>, <a href="libvirt-libvirt.html#virConnectOpenAuth">virConnectOpenAuth</a>, and the like) as well as <a href="libvirt-libvirt.html#virConnectRef">virConnectRef</a>; it is also temporarily increased by other API that depend on the connection remaining alive. The open and every <a href="libvirt-libvirt.html#virConnectRef">virConnectRef</a> call should have a matching <a href="libvirt-libvirt.html#virConnectClose">virConnectClose</a>, and all other references will be released after the corresponding operation completes.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>a positive number if at least 1 reference remains on success. The returned value should not be assumed to be the total reference count. A return of 0 implies no references remain and the connection is closed and memory has been freed. A return of -1 implies a failure. It is possible for the last <a href="libvirt-libvirt.html#virConnectClose">virConnectClose</a> to return a positive value if some other object still has a temporary reference to the connection, but the application should not try to further use a connection after the <a href="libvirt-libvirt.html#virConnectClose">virConnectClose</a> that matches the initial open.</dd></dl><div class="acl"></div><h3><a name="virConnectCloseFunc" id="virConnectCloseFunc"><code>virConnectCloseFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectCloseFunc	)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">int</span> reason,
					 <span class="type">void *</span> opaque)
</pre><div class="description"><p>A callback function to be registered, and called when the connection is closed.</p></div><dl class="variablelist"><dt>conn</dt><dd><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</dd><dt>reason</dt><dd>reason why the connection was closed (one of <a href="libvirt-libvirt.html#virConnectCloseReason">virConnectCloseReason</a>)</dd><dt>opaque</dt><dd>opaque user data</dd></dl><br /><h3><a name="virConnectCompareCPU" id="virConnectCompareCPU"><code>virConnectCompareCPU</code></a></h3><pre class="api"><span class="type">int</span>	virConnectCompareCPU		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xmlDesc,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Compares the given CPU description with the host CPU</p></div><dl class="variablelist"><dt>conn</dt><dd><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</dd><dt>xmlDesc</dt><dd>XML describing the CPU to compare with host CPU</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>comparison result according to enum <a href="libvirt-libvirt.html#virCPUCompareResult">virCPUCompareResult</a></dd></dl><div class="acl"></div><h3><a name="virConnectDomainEventBalloonChangeCallback" id="virConnectDomainEventBalloonChangeCallback"><code>virConnectDomainEventBalloonChangeCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventBalloonChangeCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
							 <span class="type">unsigned long long</span> actual,
							 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE">VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>actual</dt><dd>the new balloon level measured in kibibytes(blocks of 1024 bytes)</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventBlockJobCallback" id="virConnectDomainEventBlockJobCallback"><code>virConnectDomainEventBlockJobCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventBlockJobCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">const char *</span> disk,
						 <span class="type">int</span> type,
						 <span class="type">int</span> status,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_BLOCK_JOB">VIR_DOMAIN_EVENT_ID_BLOCK_JOB</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>disk</dt><dd>fully-qualified filename of the affected disk</dd><dt>type</dt><dd>type of block job (<a href="libvirt-libvirt.html#virDomainBlockJobType">virDomainBlockJobType</a>)</dd><dt>status</dt><dd>final status of the operation (<a href="libvirt-libvirt.html#virConnectDomainEventBlockJobStatus">virConnectDomainEventBlockJobStatus</a>)</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventCallback" id="virConnectDomainEventCallback"><code>virConnectDomainEventCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virConnectDomainEventCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">int</span> event,
					 <span class="type">int</span> detail,
					 <span class="type">void *</span> opaque)
</pre><div class="description"><p>A callback function to be registered, and called when a domain event occurs</p></div><dl class="variablelist"><dt>conn</dt><dd><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</dd><dt>dom</dt><dd>The domain on which the event occurred</dd><dt>event</dt><dd>The specific <a href="libvirt-libvirt.html#virDomainEventType">virDomainEventType</a> which occurred</dd><dt>detail</dt><dd>event specific detail information</dd><dt>opaque</dt><dd>opaque user data</dd><dt>Returns</dt><dd>0 (the return value is currently ignored)</dd></dl><br /><h3><a name="virConnectDomainEventDeregister" id="virConnectDomainEventDeregister"><code>virConnectDomainEventDeregister</code></a></h3><pre class="api"><span class="type">int</span>	virConnectDomainEventDeregister	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a></span> cb)</pre><div class="description"><p>Removes a callback previously registered with the <a href="libvirt-libvirt.html#virConnectDomainEventRegister">virConnectDomainEventRegister</a> function.</p><p>Use of this method is no longer recommended. Instead applications should try virConnectDomainEventUnregisterAny which has a more flexible API contract</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the connection</dd><dt>cb</dt><dd>callback to the function handling domain events</dd><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virConnectDomainEventDeregisterAny" id="virConnectDomainEventDeregisterAny"><code>virConnectDomainEventDeregisterAny</code></a></h3><pre class="api"><span class="type">int</span>	virConnectDomainEventDeregisterAny	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">int</span> callbackID)</pre><div class="description"><p>Removes an event callback. The callbackID parameter should be the vaule obtained from a previous virDomainEventRegisterAny method.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the connection</dd><dt>callbackID</dt><dd>the callback identifier</dd><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virConnectDomainEventDeviceRemovedCallback" id="virConnectDomainEventDeviceRemovedCallback"><code>virConnectDomainEventDeviceRemovedCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventDeviceRemovedCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
							 <span class="type">const char *</span> devAlias,
							 <span class="type">void *</span> opaque)
</pre><div class="description"><p>This callback occurs when a device is removed from the domain.</p><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED">VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>devAlias</dt><dd>device alias</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventDiskChangeCallback" id="virConnectDomainEventDiskChangeCallback"><code>virConnectDomainEventDiskChangeCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventDiskChangeCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">const char *</span> oldSrcPath,
						 <span class="type">const char *</span> newSrcPath,
						 <span class="type">const char *</span> devAlias,
						 <span class="type">int</span> reason,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>This callback occurs when disk gets changed. However, not all @reason will cause both @oldSrcPath and @newSrcPath to be non-NULL. Please see <a href="libvirt-libvirt.html#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a> for more details.</p><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_DISK_CHANGE">VIR_DOMAIN_EVENT_ID_DISK_CHANGE</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>oldSrcPath</dt><dd>old source path</dd><dt>newSrcPath</dt><dd>new source path</dd><dt>devAlias</dt><dd>device alias name</dd><dt>reason</dt><dd>reason why this callback was called; any of <a href="libvirt-libvirt.html#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a></dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventGenericCallback" id="virConnectDomainEventGenericCallback"><code>virConnectDomainEventGenericCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventGenericCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>A generic domain event callback handler. Specific events usually have a customization with extra parameters</p></div><dl class="variablelist"><dt>conn</dt><dd>the connection pointer</dd><dt>dom</dt><dd>the domain pointer</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventGraphicsCallback" id="virConnectDomainEventGraphicsCallback"><code>virConnectDomainEventGraphicsCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventGraphicsCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">int</span> phase,
						 <span class="type">const <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> *</span> local,
						 <span class="type">const <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> *</span> remote,
						 <span class="type">const char *</span> authScheme,
						 <span class="type">const <a href="libvirt-libvirt.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> *</span> subject,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_GRAPHICS">VIR_DOMAIN_EVENT_ID_GRAPHICS</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>phase</dt><dd>the phase of the connection</dd><dt>local</dt><dd>the local server address</dd><dt>remote</dt><dd>the remote client address</dd><dt>authScheme</dt><dd>the authentication scheme activated</dd><dt>subject</dt><dd>the authenticated subject (user)</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventIOErrorCallback" id="virConnectDomainEventIOErrorCallback"><code>virConnectDomainEventIOErrorCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventIOErrorCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">const char *</span> srcPath,
						 <span class="type">const char *</span> devAlias,
						 <span class="type">int</span> action,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_IO_ERROR">VIR_DOMAIN_EVENT_ID_IO_ERROR</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>srcPath</dt><dd>The host file on which the IO error occurred</dd><dt>devAlias</dt><dd>The guest device alias associated with the path</dd><dt>action</dt><dd>action that is to be taken due to the IO error</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventIOErrorReasonCallback" id="virConnectDomainEventIOErrorReasonCallback"><code>virConnectDomainEventIOErrorReasonCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventIOErrorReasonCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
							 <span class="type">const char *</span> srcPath,
							 <span class="type">const char *</span> devAlias,
							 <span class="type">int</span> action,
							 <span class="type">const char *</span> reason,
							 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_IO_ERROR">VIR_DOMAIN_EVENT_ID_IO_ERROR</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>srcPath</dt><dd>The host file on which the IO error occurred</dd><dt>devAlias</dt><dd>The guest device alias associated with the path</dd><dt>action</dt><dd>action that is to be taken due to the IO error</dd><dt>reason</dt><dd>the cause of the IO error</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventPMSuspendCallback" id="virConnectDomainEventPMSuspendCallback"><code>virConnectDomainEventPMSuspendCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventPMSuspendCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">int</span> reason,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>This callback occurs when the guest is waken up.</p><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_PMSUSPEND">VIR_DOMAIN_EVENT_ID_PMSUSPEND</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>reason</dt><dd>reason why the callback was called, unused currently, always passes 0</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventPMSuspendDiskCallback" id="virConnectDomainEventPMSuspendDiskCallback"><code>virConnectDomainEventPMSuspendDiskCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventPMSuspendDiskCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
							 <span class="type">int</span> reason,
							 <span class="type">void *</span> opaque)
</pre><div class="description"><p>This callback occurs when the guest is suspended to disk.</p><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK">VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>reason</dt><dd>reason why the callback was called, unused currently, always passes 0</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventPMWakeupCallback" id="virConnectDomainEventPMWakeupCallback"><code>virConnectDomainEventPMWakeupCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventPMWakeupCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">int</span> reason,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>This callback occurs when the guest is waken up.</p><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_PMWAKEUP">VIR_DOMAIN_EVENT_ID_PMWAKEUP</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>reason</dt><dd>reason why the callback was called, unused currently, always passes 0</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventRTCChangeCallback" id="virConnectDomainEventRTCChangeCallback"><code>virConnectDomainEventRTCChangeCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventRTCChangeCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">long long</span> utcoffset,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_RTC_CHANGE">VIR_DOMAIN_EVENT_ID_RTC_CHANGE</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>utcoffset</dt><dd>the new RTC offset from UTC, measured in seconds</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventRegister" id="virConnectDomainEventRegister"><code>virConnectDomainEventRegister</code></a></h3><pre class="api"><span class="type">int</span>	virConnectDomainEventRegister	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a></span> cb,
					 <span class="type">void *</span> opaque,
					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> freecb)</pre><div class="description"><p>Adds a callback to receive notifications of domain lifecycle events occurring on a connection</p><p>Use of this method is no longer recommended. Instead applications should try <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a> which has a more flexible API contract</p><p>The <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object handle passed into the callback upon delivery of an event is only valid for the duration of execution of the callback. If the callback wishes to keep the domain object after the callback returns, it shall take a reference to it, by calling <a href="libvirt-libvirt.html#virDomainRef">virDomainRef</a>. The reference can be released once the object is no longer required by calling <a href="libvirt-libvirt.html#virDomainFree">virDomainFree</a>.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the connection</dd><dt>cb</dt><dd>callback to the function handling domain events</dd><dt>opaque</dt><dd>opaque data to pass on to the callback</dd><dt>freecb</dt><dd>optional function to deallocate opaque when not used anymore</dd><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virConnectDomainEventRegisterAny" id="virConnectDomainEventRegisterAny"><code>virConnectDomainEventRegisterAny</code></a></h3><pre class="api"><span class="type">int</span>	virConnectDomainEventRegisterAny	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">int</span> eventID,
						 <span class="type"><a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a></span> cb,
						 <span class="type">void *</span> opaque,
						 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> freecb)</pre><div class="description"><p>Adds a callback to receive notifications of arbitrary domain events occurring on a domain.</p><p>If dom is NULL, then events will be monitored for any domain. If dom is non-NULL, then only the specific domain will be monitored</p><p>Most types of event have a callback providing a custom set of parameters for the event. When registering an event, it is thus necessary to use the <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_CALLBACK">VIR_DOMAIN_EVENT_CALLBACK</a>() macro to cast the supplied function pointer to match the signature of this method.</p><p>The <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object handle passed into the callback upon delivery of an event is only valid for the duration of execution of the callback. If the callback wishes to keep the domain object after the callback returns, it shall take a reference to it, by calling <a href="libvirt-libvirt.html#virDomainRef">virDomainRef</a>. The reference can be released once the object is no longer required by calling <a href="libvirt-libvirt.html#virDomainFree">virDomainFree</a>.</p><p>The return value from this method is a positive integer identifier for the callback. To unregister a callback, this callback ID should be passed to the virDomainEventUnregisterAny method</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the connection</dd><dt>dom</dt><dd>pointer to the domain</dd><dt>eventID</dt><dd>the event type to receive</dd><dt>cb</dt><dd>callback to the function handling domain events</dd><dt>opaque</dt><dd>opaque data to pass on to the callback</dd><dt>freecb</dt><dd>optional function to deallocate opaque when not used anymore</dd><dt>Returns</dt><dd>a callback identifier on success, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virConnectDomainEventTrayChangeCallback" id="virConnectDomainEventTrayChangeCallback"><code>virConnectDomainEventTrayChangeCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventTrayChangeCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">const char *</span> devAlias,
						 <span class="type">int</span> reason,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>This callback occurs when the tray of a removable device is moved.</p><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_TRAY_CHANGE">VIR_DOMAIN_EVENT_ID_TRAY_CHANGE</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>devAlias</dt><dd>device alias</dd><dt>reason</dt><dd>why the tray status was changed?</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainEventWatchdogCallback" id="virConnectDomainEventWatchdogCallback"><code>virConnectDomainEventWatchdogCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virConnectDomainEventWatchdogCallback)	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
						 <span class="type">int</span> action,
						 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The callback signature to use when registering for an event of type <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_WATCHDOG">VIR_DOMAIN_EVENT_ID_WATCHDOG</a> with <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>connection object</dd><dt>dom</dt><dd>domain on which the event occurred</dd><dt>action</dt><dd>action that is to be taken due to watchdog firing</dd><dt>opaque</dt><dd>application specified data</dd></dl><br /><h3><a name="virConnectDomainXMLFromNative" id="virConnectDomainXMLFromNative"><code>virConnectDomainXMLFromNative</code></a></h3><pre class="api"><span class="type">char *</span>	virConnectDomainXMLFromNative	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> nativeFormat,
					 <span class="type">const char *</span> nativeConfig,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Reads native configuration data describing a domain, and generates libvirt domain XML. The format of the native data is hypervisor dependant.</p></div><dl class="variablelist"><dt>conn</dt><dd>a connection object</dd><dt>nativeFormat</dt><dd>configuration format importing from</dd><dt>nativeConfig</dt><dd>the configuration data to import</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virConnectDomainXMLToNative" id="virConnectDomainXMLToNative"><code>virConnectDomainXMLToNative</code></a></h3><pre class="api"><span class="type">char *</span>	virConnectDomainXMLToNative	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> nativeFormat,
					 <span class="type">const char *</span> domainXml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Reads a domain XML configuration document, and generates a native configuration file describing the domain. The format of the native data is hypervisor dependant.</p></div><dl class="variablelist"><dt>conn</dt><dd>a connection object</dd><dt>nativeFormat</dt><dd>configuration format exporting to</dd><dt>domainXml</dt><dd>the domain configuration to export</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error. the caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virConnectFindStoragePoolSources" id="virConnectFindStoragePoolSources"><code>virConnectFindStoragePoolSources</code></a></h3><pre class="api"><span class="type">char *</span>	virConnectFindStoragePoolSources	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> type,
						 <span class="type">const char *</span> srcSpec,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Talks to a storage backend and attempts to auto-discover the set of available storage pool sources. e.g. For iSCSI this would be a set of iSCSI targets. For NFS this would be a list of exported paths. The srcSpec (optional for some storage pool types, e.g. local ones) is an instance of the storage pool's source element specifying where to look for the pools.</p><p>srcSpec is not required for some types (e.g., those querying local storage resources only)</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>type</dt><dd>type of storage pool sources to discover</dd><dt>srcSpec</dt><dd>XML document specifying discovery source</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>an xml document consisting of a SourceList element containing a source document appropriate to the given pool type for each discovered source.</dd></dl><div class="acl"></div><h3><a name="virConnectGetCPUModelNames" id="virConnectGetCPUModelNames"><code>virConnectGetCPUModelNames</code></a></h3><pre class="api"><span class="type">int</span>	virConnectGetCPUModelNames	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> arch,
					 <span class="type">char ** *</span> models,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get the list of supported CPU models for a specific architecture.</p></div><dl class="variablelist"><dt>conn</dt><dd><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</dd><dt>arch</dt><dd>Architecture</dd><dt>models</dt><dd>Pointer to a variable to store the NULL-terminated array of the CPU models supported for the specified architecture. Each element and the array itself must be freed by the caller with free. Pass NULL if only the list length is needed.</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0.</dd><dt>Returns</dt><dd>-1 on error, number of elements in @models on success.</dd></dl><div class="acl"></div><h3><a name="virConnectGetCapabilities" id="virConnectGetCapabilities"><code>virConnectGetCapabilities</code></a></h3><pre class="api"><span class="type">char *</span>	virConnectGetCapabilities	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides capabilities of the hypervisor / driver.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>NULL in case of error, or an XML string defining the capabilities. The client must free the returned string after use.</dd></dl><div class="acl"></div><h3><a name="virConnectGetHostname" id="virConnectGetHostname"><code>virConnectGetHostname</code></a></h3><pre class="api"><span class="type">char *</span>	virConnectGetHostname		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>This returns a system hostname on which the hypervisor is running (based on the result of the gethostname system call, but possibly expanded to a fully-qualified domain name via getaddrinfo). If we are connected to a remote system, then this returns the hostname of the remote system.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to a hypervisor connection</dd><dt>Returns</dt><dd>the hostname which must be freed by the caller, or NULL if there was an error.</dd></dl><div class="acl"></div><h3><a name="virConnectGetLibVersion" id="virConnectGetLibVersion"><code>virConnectGetLibVersion</code></a></h3><pre class="api"><span class="type">int</span>	virConnectGetLibVersion		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned long *</span> libVer)</pre><div class="description"><p>Provides @libVer, which is the version of libvirt used by the daemon running on the @conn host</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>libVer</dt><dd>returns the libvirt library version used on the connection (OUT)</dd><dt>Returns</dt><dd>-1 in case of failure, 0 otherwise, and values for @libVer have the format major * 1,000,000 + minor * 1,000 + release.</dd></dl><div class="acl"></div><h3><a name="virConnectGetMaxVcpus" id="virConnectGetMaxVcpus"><code>virConnectGetMaxVcpus</code></a></h3><pre class="api"><span class="type">int</span>	virConnectGetMaxVcpus		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> type)</pre><div class="description"><p>Provides the maximum number of virtual CPUs supported for a guest VM of a specific type. The 'type' parameter here corresponds to the 'type' attribute in the &lt;domain&gt; element of the XML.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>type</dt><dd>value of the 'type' attribute in the &lt;domain&gt; element</dd><dt>Returns</dt><dd>the maximum of virtual CPU or -1 in case of error.</dd></dl><div class="acl"></div><h3><a name="virConnectGetSysinfo" id="virConnectGetSysinfo"><code>virConnectGetSysinfo</code></a></h3><pre class="api"><span class="type">char *</span>	virConnectGetSysinfo		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This returns the XML description of the sysinfo details for the host on which the hypervisor is running, in the same format as the &lt;sysinfo&gt; element of a domain XML. This information is generally available only for hypervisors running with root privileges.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to a hypervisor connection</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the XML string which must be freed by the caller, or NULL if there was an error.</dd></dl><div class="acl"></div><h3><a name="virConnectGetType" id="virConnectGetType"><code>virConnectGetType</code></a></h3><pre class="api"><span class="type">const char *</span>	virConnectGetType	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Get the name of the Hypervisor driver used. This is merely the driver name; for example, both KVM and QEMU guests are serviced by the driver for the qemu:// URI, so a return of "QEMU" does not indicate whether KVM acceleration is present. For more details about the hypervisor, use <a href="libvirt-libvirt.html#virConnectGetCapabilities">virConnectGetCapabilities</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>NULL in case of error, a static zero terminated string otherwise. See also: <a href="http://www.redhat.com/archives/libvir-list/2007-February/msg00096.html">http://www.redhat.com/archives/libvir-list/2007-February/msg00096.html</a></dd></dl><div class="acl"></div><h3><a name="virConnectGetURI" id="virConnectGetURI"><code>virConnectGetURI</code></a></h3><pre class="api"><span class="type">char *</span>	virConnectGetURI		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>This returns the URI (name) of the hypervisor connection. Normally this is the same as or similar to the string passed to the virConnectOpen/virConnectOpenReadOnly call, but the driver may make the URI canonical. If name == NULL was passed to <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a>, then the driver will return a non-NULL URI which can be used to connect to the same hypervisor later.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to a hypervisor connection</dd><dt>Returns</dt><dd>the URI string which must be freed by the caller, or NULL if there was an error.</dd></dl><div class="acl"></div><h3><a name="virConnectGetVersion" id="virConnectGetVersion"><code>virConnectGetVersion</code></a></h3><pre class="api"><span class="type">int</span>	virConnectGetVersion		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned long *</span> hvVer)</pre><div class="description"><p>Get the version level of the Hypervisor running. This may work only with hypervisor call, i.e. with privileged access to the hypervisor, not with a Read-Only connection.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>hvVer</dt><dd>return value for the version of the running hypervisor (OUT)</dd><dt>Returns</dt><dd>-1 in case of error, 0 otherwise. if the version can't be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release</dd></dl><div class="acl"></div><h3><a name="virConnectIsAlive" id="virConnectIsAlive"><code>virConnectIsAlive</code></a></h3><pre class="api"><span class="type">int</span>	virConnectIsAlive		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Determine if the connection to the hypervisor is still alive</p><p>A connection will be classed as alive if it is either local, or running over a channel (TCP or UNIX socket) which is not closed.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the connection object</dd><dt>Returns</dt><dd>1 if alive, 0 if dead, -1 on error</dd></dl><div class="acl"></div><h3><a name="virConnectIsEncrypted" id="virConnectIsEncrypted"><code>virConnectIsEncrypted</code></a></h3><pre class="api"><span class="type">int</span>	virConnectIsEncrypted		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Determine if the connection to the hypervisor is encrypted</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the connection object</dd><dt>Returns</dt><dd>1 if encrypted, 0 if not encrypted, -1 on error</dd></dl><div class="acl"></div><h3><a name="virConnectIsSecure" id="virConnectIsSecure"><code>virConnectIsSecure</code></a></h3><pre class="api"><span class="type">int</span>	virConnectIsSecure		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Determine if the connection to the hypervisor is secure</p><p>A connection will be classed as secure if it is either encrypted, or running over a channel which is not exposed to eavesdropping (eg a UNIX domain socket, or pipe)</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the connection object</dd><dt>Returns</dt><dd>1 if secure, 0 if not secure, -1 on error</dd></dl><div class="acl"></div><h3><a name="virConnectListAllDomains" id="virConnectListAllDomains"><code>virConnectListAllDomains</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListAllDomains	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> **</span> domains,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect a possibly-filtered list of all domains, and return an allocated array of information for each. This API solves the race inherent in <a href="libvirt-libvirt.html#virConnectListDomains">virConnectListDomains</a>() and <a href="libvirt-libvirt.html#virConnectListDefinedDomains">virConnectListDefinedDomains</a>().</p><p>Normally, all domains are returned; however, @flags can be used to filter the results for a smaller list of targeted domains. The valid flags are divided into groups, where each group contains bits that describe mutually exclusive attributes of a domain, and where all bits within a group describe all possible domains. Some hypervisors might reject explicit bits from a group where the hypervisor cannot make a distinction (for example, not all hypervisors can tell whether domains have snapshots). For a group supported by a given hypervisor, the behavior when no bits of a group are set is identical to the behavior when all bits in that group are set. When setting bits from more than one group, it is possible to select an impossible combination (such as an inactive transient domain), in that case a hypervisor may return either 0 or an error.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_ACTIVE">VIR_CONNECT_LIST_DOMAINS_ACTIVE</a> (online domains) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_INACTIVE">VIR_CONNECT_LIST_DOMAINS_INACTIVE</a> (offline domains).</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_PERSISTENT">VIR_CONNECT_LIST_DOMAINS_PERSISTENT</a> (defined domains) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_TRANSIENT">VIR_CONNECT_LIST_DOMAINS_TRANSIENT</a> (running but not defined).</p><p>The next group of @flags covers various domain states: <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_RUNNING">VIR_CONNECT_LIST_DOMAINS_RUNNING</a>, <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_PAUSED">VIR_CONNECT_LIST_DOMAINS_PAUSED</a>, <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_SHUTOFF">VIR_CONNECT_LIST_DOMAINS_SHUTOFF</a>, and a catch-all for all other states (such as crashed, this catch-all covers the possibility of adding new states).</p><p>The remaining groups cover boolean attributes commonly asked about domains; they include <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE</a> and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE</a>, for filtering based on whether a managed save image exists; <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_AUTOSTART</a> and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART</a>, for filtering based on autostart; <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT">VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT</a> and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT">VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT</a>, for filtering based on whether a domain has snapshots.</p></div><dl class="variablelist"><dt>conn</dt><dd>Pointer to the hypervisor connection.</dd><dt>domains</dt><dd>Pointer to a variable to store the array containing domain objects or NULL if the list is not required (just returns number of guests).</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virConnectListAllDomainsFlags">virConnectListAllDomainsFlags</a></dd><dt>Returns</dt><dd>the number of domains found or -1 and sets domains to NULL in case of error. On success, the array stored into @domains is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virDomainFree">virDomainFree</a>() on each array element, then calling free() on @domains. Example of usage: <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> *domains; size_t i; int ret; unsigned int flags = <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_RUNNING">VIR_CONNECT_LIST_DOMAINS_RUNNING</a> | <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_DOMAINS_PERSISTENT">VIR_CONNECT_LIST_DOMAINS_PERSISTENT</a>; ret = virConnectListAllDomains(conn, &amp;domains, flags); if (ret &lt; 0) error(); for (i = 0; i &lt; ret; i++) { do_something_with_domain(domains[i]); //here or in a separate loop if needed virDomainFree(domains[i]); } free(domains);</dd></dl><div class="acl"></div><h3><a name="virConnectListAllInterfaces" id="virConnectListAllInterfaces"><code>virConnectListAllInterfaces</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListAllInterfaces	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> **</span> ifaces,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of interfaces, and allocate an array to store those objects. This API solves the race inherent between <a href="libvirt-libvirt.html#virConnectListInterfaces">virConnectListInterfaces</a> and <a href="libvirt-libvirt.html#virConnectListDefinedInterfaces">virConnectListDefinedInterfaces</a>.</p><p>Normally, all interfaces are returned; however, @flags can be used to filter the results for a smaller list of targeted interfaces. The valid flags are divided into groups, where each group contains bits that describe mutually exclusive attributes of a interface, and where all bits within a group describe all possible interfaces.</p><p>The only group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_INTERFACES_ACTIVE">VIR_CONNECT_LIST_INTERFACES_ACTIVE</a> (up) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_INTERFACES_INACTIVE">VIR_CONNECT_LIST_INTERFACES_INACTIVE</a> (down) to filter the interfaces by state.</p></div><dl class="variablelist"><dt>conn</dt><dd>Pointer to the hypervisor connection.</dd><dt>ifaces</dt><dd>Pointer to a variable to store the array containing the interface objects or NULL if the list is not required (just returns number of interfaces).</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virConnectListAllInterfacesFlags">virConnectListAllInterfacesFlags</a>.</dd><dt>Returns</dt><dd>the number of interfaces found or -1 and sets @ifaces to NULL in case of error. On success, the array stored into @ifaces is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virStorageInterfaceFree() on each array element, then calling free() on @ifaces.</dd></dl><div class="acl"></div><h3><a name="virConnectListAllNWFilters" id="virConnectListAllNWFilters"><code>virConnectListAllNWFilters</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListAllNWFilters	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> **</span> filters,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of network filters, and allocate an array to store those objects.</p></div><dl class="variablelist"><dt>conn</dt><dd>Pointer to the hypervisor connection.</dd><dt>filters</dt><dd>Pointer to a variable to store the array containing the network filter objects or NULL if the list is not required (just returns number of network filters).</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the number of network filters found or -1 and sets @filters to NULL in case of error. On success, the array stored into @filters is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virNWFilterFree">virNWFilterFree</a>() on each array element, then calling free() on @filters.</dd></dl><div class="acl"></div><h3><a name="virConnectListAllNetworks" id="virConnectListAllNetworks"><code>virConnectListAllNetworks</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListAllNetworks	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> **</span> nets,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of networks, and allocate an array to store those objects. This API solves the race inherent between <a href="libvirt-libvirt.html#virConnectListNetworks">virConnectListNetworks</a> and <a href="libvirt-libvirt.html#virConnectListDefinedNetworks">virConnectListDefinedNetworks</a>.</p><p>Normally, all networks are returned; however, @flags can be used to filter the results for a smaller list of targeted networks. The valid flags are divided into groups, where each group contains bits that describe mutually exclusive attributes of a network, and where all bits within a group describe all possible networks.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_ACTIVE">VIR_CONNECT_LIST_NETWORKS_ACTIVE</a> (up) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_INACTIVE">VIR_CONNECT_LIST_NETWORKS_INACTIVE</a> (down) to filter the networks by state.</p><p>The second group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_PERSISTENT">VIR_CONNECT_LIST_NETWORKS_PERSISTENT</a> (defined) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_TRANSIENT">VIR_CONNECT_LIST_NETWORKS_TRANSIENT</a> (running but not defined), to filter the networks by whether they have persistent config or not.</p><p>The third group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_AUTOSTART">VIR_CONNECT_LIST_NETWORKS_AUTOSTART</a> and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART">VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART</a>, to filter the networks by whether they are marked as autostart or not.</p></div><dl class="variablelist"><dt>conn</dt><dd>Pointer to the hypervisor connection.</dd><dt>nets</dt><dd>Pointer to a variable to store the array containing the network objects or NULL if the list is not required (just returns number of networks).</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virConnectListAllNetworksFlags">virConnectListAllNetworksFlags</a>.</dd><dt>Returns</dt><dd>the number of networks found or -1 and sets @nets to NULL in case of error. On success, the array stored into @nets is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virNetworkFree">virNetworkFree</a>() on each array element, then calling free() on @nets.</dd></dl><div class="acl"></div><h3><a name="virConnectListAllNodeDevices" id="virConnectListAllNodeDevices"><code>virConnectListAllNodeDevices</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListAllNodeDevices	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> **</span> devices,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of node devices, and allocate an array to store those objects.</p><p>Normally, all node devices are returned; however, @flags can be used to filter the results for a smaller list of targeted node devices. The valid flags are divided into groups, where each group contains bits that describe mutually exclusive attributes of a node device, and where all bits within a group describe all possible node devices.</p><p>Only one group of the @flags is provided to filter the node devices by capability type, flags include: <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE">VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET">VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE">VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST">VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS">VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC</a></p></div><dl class="variablelist"><dt>conn</dt><dd>Pointer to the hypervisor connection.</dd><dt>devices</dt><dd>Pointer to a variable to store the array containing the node device objects or NULL if the list is not required (just returns number of node devices).</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virConnectListAllNodeDevices">virConnectListAllNodeDevices</a>.</dd><dt>Returns</dt><dd>the number of node devices found or -1 and sets @devices to NULL in case of error. On success, the array stored into @devices is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virNodeDeviceFree">virNodeDeviceFree</a>() on each array element, then calling free() on @devices.</dd></dl><div class="acl"></div><h3><a name="virConnectListAllSecrets" id="virConnectListAllSecrets"><code>virConnectListAllSecrets</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListAllSecrets	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> **</span> secrets,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of secrets, and allocate an array to store those objects.</p><p>Normally, all secrets are returned; however, @flags can be used to filter the results for a smaller list of targeted secrets. The valid flags are divided into groups, where each group contains bits that describe mutually exclusive attributes of a secret, and where all bits within a group describe all possible secrets.</p><p>The first group of @flags is used to filter secrets by its storage location. Flag <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_SECRETS_EPHEMERAL">VIR_CONNECT_LIST_SECRETS_EPHEMERAL</a> selects secrets that are kept only in memory. Flag <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL">VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL</a> selects secrets that are kept in persistent storage.</p><p>The second group of @flags is used to filter secrets by privacy. Flag <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_SECRETS_PRIVATE">VIR_CONNECT_LIST_SECRETS_PRIVATE</a> seclets secrets that are never revealed to any caller of libvirt nor to any other node. Flag <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_SECRETS_NO_PRIVATE">VIR_CONNECT_LIST_SECRETS_NO_PRIVATE</a> selects non-private secrets.</p></div><dl class="variablelist"><dt>conn</dt><dd>Pointer to the hypervisor connection.</dd><dt>secrets</dt><dd>Pointer to a variable to store the array containing the secret objects or NULL if the list is not required (just returns the number of secrets).</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the number of secrets found or -1 and sets @secrets to NULL in case of error. On success, the array stored into @secrets is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virSecretFree">virSecretFree</a>() on each array element, then calling free() on @secrets.</dd></dl><div class="acl"></div><h3><a name="virConnectListAllStoragePools" id="virConnectListAllStoragePools"><code>virConnectListAllStoragePools</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListAllStoragePools	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> **</span> pools,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of storage pools, and allocate an array to store those objects. This API solves the race inherent between <a href="libvirt-libvirt.html#virConnectListStoragePools">virConnectListStoragePools</a> and <a href="libvirt-libvirt.html#virConnectListDefinedStoragePools">virConnectListDefinedStoragePools</a>.</p><p>Normally, all storage pools are returned; however, @flags can be used to filter the results for a smaller list of targeted pools. The valid flags are divided into groups, where each group contains bits that describe mutually exclusive attributes of a pool, and where all bits within a group describe all possible pools.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE">VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE</a> (online) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE">VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE</a> (offline) to filter the pools by state.</p><p>The second group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_PERSITENT (defined) and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT">VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT</a> (running but not defined), to filter the pools by whether they have persistent config or not.</p><p>The third group of @flags is <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART">VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART</a> and <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART">VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART</a>, to filter the pools by whether they are marked as autostart or not.</p><p>The last group of @flags is provided to filter the pools by the types, the flags include: <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_DIR">VIR_CONNECT_LIST_STORAGE_POOLS_DIR</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_FS">VIR_CONNECT_LIST_STORAGE_POOLS_FS</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_NETFS">VIR_CONNECT_LIST_STORAGE_POOLS_NETFS</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL">VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_DISK">VIR_CONNECT_LIST_STORAGE_POOLS_DISK</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI">VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_SCSI">VIR_CONNECT_LIST_STORAGE_POOLS_SCSI</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_MPATH">VIR_CONNECT_LIST_STORAGE_POOLS_MPATH</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_RBD">VIR_CONNECT_LIST_STORAGE_POOLS_RBD</a> <a href="libvirt-libvirt.html#VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG">VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG</a></p></div><dl class="variablelist"><dt>conn</dt><dd>Pointer to the hypervisor connection.</dd><dt>pools</dt><dd>Pointer to a variable to store the array containing storage pool objects or NULL if the list is not required (just returns number of pools).</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virConnectListAllStoragePoolsFlags">virConnectListAllStoragePoolsFlags</a>.</dd><dt>Returns</dt><dd>the number of storage pools found or -1 and sets @pools to NULL in case of error. On success, the array stored into @pools is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virStoragePoolFree">virStoragePoolFree</a>() on each array element, then calling free() on @pools.</dd></dl><div class="acl"></div><h3><a name="virConnectListDefinedDomains" id="virConnectListDefinedDomains"><code>virConnectListDefinedDomains</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListDefinedDomains	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>list the defined but inactive domains, stores the pointers to the names in @names</p><p>For active domains, see <a href="libvirt-libvirt.html#virConnectListDomains">virConnectListDomains</a>(). For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllDomains">virConnectListAllDomains</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>names</dt><dd>pointer to an array to store the names</dd><dt>maxnames</dt><dd>size of the array</dd><dt>Returns</dt><dd>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a domain can be defined between a call to <a href="libvirt-libvirt.html#virConnectNumOfDefinedDomains">virConnectNumOfDefinedDomains</a>() and this call; you are only guaranteed that all currently defined domains were listed if the return is less than @maxids. The client must call free() on each returned name.</dd></dl><div class="acl"></div><h3><a name="virConnectListDefinedInterfaces" id="virConnectListDefinedInterfaces"><code>virConnectListDefinedInterfaces</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListDefinedInterfaces	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>Collect the list of defined (inactive) physical host interfaces, and store their names in @names.</p><p>For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllInterfaces">virConnectListAllInterfaces</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>names</dt><dd>array to collect the list of names of interfaces</dd><dt>maxnames</dt><dd>size of @names</dd><dt>Returns</dt><dd>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a interface can be defined between a call to <a href="libvirt-libvirt.html#virConnectNumOfDefinedInterfaces">virConnectNumOfDefinedInterfaces</a>() and this call; you are only guaranteed that all currently defined interfaces were listed if the return is less than @maxnames. The client must call free() on each returned name.</dd></dl><div class="acl"></div><h3><a name="virConnectListDefinedNetworks" id="virConnectListDefinedNetworks"><code>virConnectListDefinedNetworks</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListDefinedNetworks	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>list the inactive networks, stores the pointers to the names in @names</p><p>For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllNetworks">virConnectListAllNetworks</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>names</dt><dd>pointer to an array to store the names</dd><dt>maxnames</dt><dd>size of the array</dd><dt>Returns</dt><dd>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a network can be defined between a call to <a href="libvirt-libvirt.html#virConnectNumOfDefinedNetworks">virConnectNumOfDefinedNetworks</a>() and this call; you are only guaranteed that all currently defined networks were listed if the return is less than @maxnames. The client must call free() on each returned name.</dd></dl><div class="acl"></div><h3><a name="virConnectListDefinedStoragePools" id="virConnectListDefinedStoragePools"><code>virConnectListDefinedStoragePools</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListDefinedStoragePools	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">char ** const</span> names,
						 <span class="type">int</span> maxnames)</pre><div class="description"><p>Provides the list of names of inactive storage pools up to maxnames. If there are more than maxnames, the remaining names will be silently ignored.</p><p>For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllStoragePools">virConnectListAllStoragePools</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>names</dt><dd>array of char * to fill with pool names (allocated by caller)</dd><dt>maxnames</dt><dd>size of the names array</dd><dt>Returns</dt><dd>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a pool can be defined between a call to <a href="libvirt-libvirt.html#virConnectNumOfDefinedStoragePools">virConnectNumOfDefinedStoragePools</a>() and this call; you are only guaranteed that all currently defined pools were listed if the return is less than @maxnames. The client must call free() on each returned name.</dd></dl><div class="acl"></div><h3><a name="virConnectListDomains" id="virConnectListDomains"><code>virConnectListDomains</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListDomains		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">int *</span> ids,
					 <span class="type">int</span> maxids)</pre><div class="description"><p>Collect the list of active domains, and store their IDs in array @ids</p><p>For inactive domains, see <a href="libvirt-libvirt.html#virConnectListDefinedDomains">virConnectListDefinedDomains</a>(). For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllDomains">virConnectListAllDomains</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>ids</dt><dd>array to collect the list of IDs of active domains</dd><dt>maxids</dt><dd>size of @ids</dd><dt>Returns</dt><dd>the number of domains found or -1 in case of error. Note that this command is inherently racy; a domain can be started between a call to <a href="libvirt-libvirt.html#virConnectNumOfDomains">virConnectNumOfDomains</a>() and this call; you are only guaranteed that all currently active domains were listed if the return is less than @maxids.</dd></dl><div class="acl"></div><h3><a name="virConnectListInterfaces" id="virConnectListInterfaces"><code>virConnectListInterfaces</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListInterfaces	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>Collect the list of active physical host interfaces, and store their names in @names</p><p>For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllInterfaces">virConnectListAllInterfaces</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>names</dt><dd>array to collect the list of names of interfaces</dd><dt>maxnames</dt><dd>size of @names</dd><dt>Returns</dt><dd>the number of interfaces found or -1 in case of error. Note that this command is inherently racy; a interface can be started between a call to <a href="libvirt-libvirt.html#virConnectNumOfInterfaces">virConnectNumOfInterfaces</a>() and this call; you are only guaranteed that all currently active interfaces were listed if the return is less than @maxnames. The client must call free() on each returned name.</dd></dl><div class="acl"></div><h3><a name="virConnectListNWFilters" id="virConnectListNWFilters"><code>virConnectListNWFilters</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListNWFilters		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>Collect the list of network filters, and store their names in @names</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>names</dt><dd>array to collect the list of names of network filters</dd><dt>maxnames</dt><dd>size of @names</dd><dt>Returns</dt><dd>the number of network filters found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virConnectListNetworks" id="virConnectListNetworks"><code>virConnectListNetworks</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListNetworks		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>Collect the list of active networks, and store their names in @names</p><p>For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllNetworks">virConnectListAllNetworks</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>names</dt><dd>array to collect the list of names of active networks</dd><dt>maxnames</dt><dd>size of @names</dd><dt>Returns</dt><dd>the number of networks found or -1 in case of error. Note that this command is inherently racy; a network can be started between a call to <a href="libvirt-libvirt.html#virConnectNumOfNetworks">virConnectNumOfNetworks</a>() and this call; you are only guaranteed that all currently active networks were listed if the return is less than @maxnames. The client must call free() on each returned name.</dd></dl><div class="acl"></div><h3><a name="virConnectListSecrets" id="virConnectListSecrets"><code>virConnectListSecrets</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListSecrets		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">char **</span> uuids,
					 <span class="type">int</span> maxuuids)</pre><div class="description"><p>List UUIDs of defined secrets, store pointers to names in uuids.</p></div><dl class="variablelist"><dt>conn</dt><dd><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</dd><dt>uuids</dt><dd>Pointer to an array to store the UUIDs</dd><dt>maxuuids</dt><dd>size of the array.</dd><dt>Returns</dt><dd>the number of UUIDs provided in the array, or -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virConnectListStoragePools" id="virConnectListStoragePools"><code>virConnectListStoragePools</code></a></h3><pre class="api"><span class="type">int</span>	virConnectListStoragePools	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>Provides the list of names of active storage pools up to maxnames. If there are more than maxnames, the remaining names will be silently ignored.</p><p>For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllStoragePools">virConnectListAllStoragePools</a>().</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>names</dt><dd>array of char * to fill with pool names (allocated by caller)</dd><dt>maxnames</dt><dd>size of the names array</dd><dt>Returns</dt><dd>the number of pools found or -1 in case of error. Note that this command is inherently racy; a pool can be started between a call to <a href="libvirt-libvirt.html#virConnectNumOfStoragePools">virConnectNumOfStoragePools</a>() and this call; you are only guaranteed that all currently active pools were listed if the return is less than @maxnames. The client must call free() on each returned name.</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfDefinedDomains" id="virConnectNumOfDefinedDomains"><code>virConnectNumOfDefinedDomains</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfDefinedDomains	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of defined but inactive domains.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>the number of domain found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfDefinedInterfaces" id="virConnectNumOfDefinedInterfaces"><code>virConnectNumOfDefinedInterfaces</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfDefinedInterfaces	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of defined (inactive) interfaces on the physical host.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>the number of defined interface found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfDefinedNetworks" id="virConnectNumOfDefinedNetworks"><code>virConnectNumOfDefinedNetworks</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfDefinedNetworks	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of inactive networks.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>the number of networks found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfDefinedStoragePools" id="virConnectNumOfDefinedStoragePools"><code>virConnectNumOfDefinedStoragePools</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfDefinedStoragePools	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of inactive storage pools</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>Returns</dt><dd>the number of pools found, or -1 on error</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfDomains" id="virConnectNumOfDomains"><code>virConnectNumOfDomains</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfDomains		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of active domains.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>the number of domain found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfInterfaces" id="virConnectNumOfInterfaces"><code>virConnectNumOfInterfaces</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfInterfaces	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of active interfaces on the physical host.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>the number of active interfaces found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfNWFilters" id="virConnectNumOfNWFilters"><code>virConnectNumOfNWFilters</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfNWFilters	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of nwfilters.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>the number of nwfilters found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfNetworks" id="virConnectNumOfNetworks"><code>virConnectNumOfNetworks</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfNetworks		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of active networks.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>the number of network found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfSecrets" id="virConnectNumOfSecrets"><code>virConnectNumOfSecrets</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfSecrets		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Fetch number of currently defined secrets.</p></div><dl class="variablelist"><dt>conn</dt><dd><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</dd><dt>Returns</dt><dd>the number currently defined secrets.</dd></dl><div class="acl"></div><h3><a name="virConnectNumOfStoragePools" id="virConnectNumOfStoragePools"><code>virConnectNumOfStoragePools</code></a></h3><pre class="api"><span class="type">int</span>	virConnectNumOfStoragePools	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Provides the number of active storage pools</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>Returns</dt><dd>the number of pools found, or -1 on error</dd></dl><div class="acl"></div><h3><a name="virConnectOpen" id="virConnectOpen"><code>virConnectOpen</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virConnectOpen		(<span class="type">const char *</span> name)</pre><div class="description"><p>This function should be called first to get a connection to the Hypervisor and xen store</p></div><dl class="variablelist"><dt>name</dt><dd>(optional) URI of the hypervisor</dd><dt>Returns</dt><dd>a pointer to the hypervisor connection or NULL in case of error If @name is NULL, if the LIBVIRT_DEFAULT_URI environment variable is set, then it will be used. Otherwise if the client configuration file has the "uri_default" parameter set, then it will be used. Finally probing will be done to determine a suitable default driver to activate. This involves trying each hypervisor in turn until one successfully opens. If connecting to an unprivileged hypervisor driver which requires the libvirtd daemon to be active, it will automatically be launched if not already running. This can be prevented by setting the environment variable LIBVIRT_AUTOSTART=0 URIs are documented at <a href="http://libvirt.org/uri.html">http://libvirt.org/uri.html</a></dd></dl><div class="acl"></div><h3><a name="virConnectOpenAuth" id="virConnectOpenAuth"><code>virConnectOpenAuth</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virConnectOpenAuth	(<span class="type">const char *</span> name,
					 <span class="type"><a href="libvirt-libvirt.html#virConnectAuthPtr">virConnectAuthPtr</a></span> auth,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This function should be called first to get a connection to the Hypervisor. If necessary, authentication will be performed fetching credentials via the callback</p><p>See <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> for notes about environment variables which can have an effect on opening drivers</p></div><dl class="variablelist"><dt>name</dt><dd>(optional) URI of the hypervisor</dd><dt>auth</dt><dd>Authenticate callback parameters</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virConnectFlags">virConnectFlags</a></dd><dt>Returns</dt><dd>a pointer to the hypervisor connection or NULL in case of error URIs are documented at <a href="http://libvirt.org/uri.html">http://libvirt.org/uri.html</a></dd></dl><div class="acl"></div><h3><a name="virConnectOpenReadOnly" id="virConnectOpenReadOnly"><code>virConnectOpenReadOnly</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virConnectOpenReadOnly	(<span class="type">const char *</span> name)</pre><div class="description"><p>This function should be called first to get a restricted connection to the library functionalities. The set of APIs usable are then restricted on the available methods to control the domains.</p><p>See <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> for notes about environment variables which can have an effect on opening drivers</p></div><dl class="variablelist"><dt>name</dt><dd>(optional) URI of the hypervisor</dd><dt>Returns</dt><dd>a pointer to the hypervisor connection or NULL in case of error URIs are documented at <a href="http://libvirt.org/uri.html">http://libvirt.org/uri.html</a></dd></dl><div class="acl"></div><h3><a name="virConnectRef" id="virConnectRef"><code>virConnectRef</code></a></h3><pre class="api"><span class="type">int</span>	virConnectRef			(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>Increment the reference count on the connection. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virConnectClose">virConnectClose</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using a connection would increment the reference count.</p></div><dl class="variablelist"><dt>conn</dt><dd>the connection to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure</dd></dl><div class="acl"></div><h3><a name="virConnectRegisterCloseCallback" id="virConnectRegisterCloseCallback"><code>virConnectRegisterCloseCallback</code></a></h3><pre class="api"><span class="type">int</span>	virConnectRegisterCloseCallback	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virConnectCloseFunc">virConnectCloseFunc</a></span> cb,
					 <span class="type">void *</span> opaque,
					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> freecb)</pre><div class="description"><p>Registers a callback to be invoked when the connection is closed. This callback is invoked when there is any condition that causes the socket connection to the hypervisor to be closed.</p><p>This function is only applicable to hypervisor drivers which maintain a persistent open connection. Drivers which open a new connection for every operation will not invoke this.</p><p>The @freecb must not invoke any other libvirt public APIs, since it is not called from a re-entrant safe context.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to connection object</dd><dt>cb</dt><dd>callback to invoke upon close</dd><dt>opaque</dt><dd>user data to pass to @cb</dd><dt>freecb</dt><dd>callback to free @opaque</dd><dt>Returns</dt><dd>0 on success, -1 on error</dd></dl><div class="acl"></div><h3><a name="virConnectSetKeepAlive" id="virConnectSetKeepAlive"><code>virConnectSetKeepAlive</code></a></h3><pre class="api"><span class="type">int</span>	virConnectSetKeepAlive		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">int</span> interval,
					 <span class="type">unsigned int</span> count)</pre><div class="description"><p>Start sending keepalive messages after interval second of inactivity and consider the connection to be broken when no response is received after count keepalive messages sent in a row. In other words, sending count + 1 keepalive message results in closing the connection. When interval is &lt;= 0, no keepalive messages will be sent. When count is 0, the connection will be automatically closed after interval seconds of inactivity without sending any keepalive messages.</p><p>Note: client has to implement and run event loop to be able to use keepalive messages. Failure to do so may result in connections being closed unexpectedly.</p><p>Note: This API function controls only keepalive messages sent by the client. If the server is configured to use keepalive you still need to run the event loop to respond to them, even if you disable keepalives by this function.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to a hypervisor connection</dd><dt>interval</dt><dd>number of seconds of inactivity before a keepalive message is sent</dd><dt>count</dt><dd>number of messages that can be sent in a row</dd><dt>Returns</dt><dd>-1 on error, 0 on success, 1 when remote party doesn't support keepalive messages.</dd></dl><div class="acl"></div><h3><a name="virConnectUnregisterCloseCallback" id="virConnectUnregisterCloseCallback"><code>virConnectUnregisterCloseCallback</code></a></h3><pre class="api"><span class="type">int</span>	virConnectUnregisterCloseCallback	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type"><a href="libvirt-libvirt.html#virConnectCloseFunc">virConnectCloseFunc</a></span> cb)</pre><div class="description"><p>Unregisters the callback previously set with the <a href="libvirt-libvirt.html#virConnectRegisterCloseCallback">virConnectRegisterCloseCallback</a> method. The callback will no longer receive notifications when the connection closes. If a <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> was provided at time of registration, it will be invoked</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to connection object</dd><dt>cb</dt><dd>pointer to the current registered callback</dd><dt>Returns</dt><dd>0 on success, -1 on error</dd></dl><div class="acl"></div><h3><a name="virDomainAbortJob" id="virDomainAbortJob"><code>virDomainAbortJob</code></a></h3><pre class="api"><span class="type">int</span>	virDomainAbortJob		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Requests that the current background job be aborted at the soonest opportunity.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainAttachDevice" id="virDomainAttachDevice"><code>virDomainAttachDevice</code></a></h3><pre class="api"><span class="type">int</span>	virDomainAttachDevice		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> xml)</pre><div class="description"><p>Create a virtual device attachment to backend. This function, having hotplug semantics, is only allowed on an active domain.</p><p>For compatibility, this method can also be used to change the media in an existing CDROM/Floppy device, however, applications are recommended to use the virDomainUpdateDeviceFlag method instead.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>xml</dt><dd>pointer to XML description of one device</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainAttachDeviceFlags" id="virDomainAttachDeviceFlags"><code>virDomainAttachDeviceFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainAttachDeviceFlags	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> xml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Attach a virtual device to a domain, using the flags parameter to control how the device is attached. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a> specifies that the device allocation is made based on current domain state. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be allocated to the active domain instance only and is not added to the persisted domain configuration. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> specifies that the device shall be allocated to the persisted domain configuration only. Note that the target hypervisor must return an error if unable to satisfy flags. E.g. the hypervisor driver will return failure if LIVE is specified but it only supports modifying the persisted device allocation.</p><p>For compatibility, this method can also be used to change the media in an existing CDROM/Floppy device, however, applications are recommended to use the virDomainUpdateDeviceFlag method instead.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>xml</dt><dd>pointer to XML description of one device</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainBlockCommit" id="virDomainBlockCommit"><code>virDomainBlockCommit</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockCommit		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type">const char *</span> base,
					 <span class="type">const char *</span> top,
					 <span class="type">unsigned long</span> bandwidth,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Commit changes that were made to temporary top-level files within a disk image backing file chain into a lower-level base file. In other words, take all the difference between @base and @top, and update @base to contain that difference; after the commit, any portion of the chain that previously depended on @top will now depend on @base, and all files after @base up to and including @top will now be invalidated. A typical use of this command is to reduce the length of a backing file chain after taking an external disk snapshot. To move data in the opposite direction, see <a href="libvirt-libvirt.html#virDomainBlockPull">virDomainBlockPull</a>().</p><p>This command starts a long-running commit block job, whose status may be tracked by <a href="libvirt-libvirt.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a>() with a job type of <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT">VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT</a>, and the operation can be aborted with <a href="libvirt-libvirt.html#virDomainBlockJobAbort">virDomainBlockJobAbort</a>(). When finished, an asynchronous event is raised to indicate the final status, and the job no longer exists. If the job is aborted, it is up to the hypervisor whether starting a new job will resume from the same point, or start over.</p><p>Be aware that this command may invalidate files even if it is aborted; the user is cautioned against relying on the contents of invalidated intermediate files such as @top without manually rebasing those files to use a backing file of a read-only copy of @base prior to the point where the commit operation was started (although such a rebase cannot be safely done until the commit has successfully completed). However, the domain itself will not have any issues; the active layer remains valid throughout the entire commit operation. As a convenience, if @flags contains <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_COMMIT_DELETE">VIR_DOMAIN_BLOCK_COMMIT_DELETE</a>, this command will unlink all files that were invalidated, after the commit successfully completes.</p><p>By default, if @base is NULL, the commit target will be the bottom of the backing chain; if @flags contains <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_COMMIT_SHALLOW">VIR_DOMAIN_BLOCK_COMMIT_SHALLOW</a>, then the immediate backing file of @top will be used instead. If @top is NULL, the active image at the top of the chain will be used. Some hypervisors place restrictions on how much can be committed, and might fail if @base is not the immediate backing file of @top, or if @top is the active layer in use by a running domain, or if @top is not the top-most file; restrictions may differ for online vs. offline domains.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p><p>The maximum bandwidth (in MiB/s) that will be used to do the commit can be specified with the bandwidth parameter. If set to 0, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if bandwidth is not 0; in this case, it might still be possible for a later call to <a href="libvirt-libvirt.html#virDomainBlockJobSetSpeed">virDomainBlockJobSetSpeed</a>() to succeed. The actual speed can be determined with <a href="libvirt-libvirt.html#virDomainGetBlockJobInfo">virDomainGetBlockJobInfo</a>().</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>base</dt><dd>path to backing file to merge into, or NULL for default</dd><dt>top</dt><dd>path to file within backing chain that contains data to be merged, or NULL to merge all possible data</dd><dt>bandwidth</dt><dd>(optional) specify commit bandwidth limit in MiB/s</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainBlockCommitFlags">virDomainBlockCommitFlags</a></dd><dt>Returns</dt><dd>0 if the operation has started, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virDomainBlockJobAbort" id="virDomainBlockJobAbort"><code>virDomainBlockJobAbort</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockJobAbort		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Cancel the active block job on the given disk.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or (since 0.9.5) the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p><p>If the current block job for @disk is <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_TYPE_PULL">VIR_DOMAIN_BLOCK_JOB_TYPE_PULL</a>, then by default, this function performs a synchronous operation and the caller may assume that the operation has completed when 0 is returned. However, BlockJob operations may take a long time to cancel, and during this time further domain interactions may be unresponsive. To avoid this problem, pass <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC">VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC</a> in the @flags argument to enable asynchronous behavior, returning as soon as possible. When the job has been canceled, a BlockJob event will be emitted, with status <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_CANCELED">VIR_DOMAIN_BLOCK_JOB_CANCELED</a> (even if the ABORT_ASYNC flag was not used); it is also possible to poll <a href="libvirt-libvirt.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a>() to see if the job cancellation is still pending. This type of job can be restarted to pick up from where it left off.</p><p>If the current block job for @disk is <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_TYPE_COPY">VIR_DOMAIN_BLOCK_JOB_TYPE_COPY</a>, then the default is to abort the mirroring and revert to the source disk; adding @flags of <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT">VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT</a> causes this call to fail with <a href="libvirt-virterror.html#VIR_ERR_BLOCK_COPY_ACTIVE">VIR_ERR_BLOCK_COPY_ACTIVE</a> if the copy is not fully populated, otherwise it will swap the disk over to the copy to end the mirroring. An event will be issued when the job is ended, and it is possible to use <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC">VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC</a> to control whether this command waits for the completion of the job. Restarting this job requires starting over from the beginning of the first phase.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainBlockJobAbortFlags">virDomainBlockJobAbortFlags</a></dd><dt>Returns</dt><dd>-1 in case of failure, 0 when successful.</dd></dl><div class="acl"></div><h3><a name="virDomainBlockJobSetSpeed" id="virDomainBlockJobSetSpeed"><code>virDomainBlockJobSetSpeed</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockJobSetSpeed	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type">unsigned long</span> bandwidth,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Set the maximimum allowable bandwidth that a block job may consume. If bandwidth is 0, the limit will revert to the hypervisor default.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or (since 0.9.5) the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>bandwidth</dt><dd>specify bandwidth limit in MiB/s</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>-1 in case of failure, 0 when successful.</dd></dl><div class="acl"></div><h3><a name="virDomainBlockPeek" id="virDomainBlockPeek"><code>virDomainBlockPeek</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockPeek		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type">unsigned long long</span> offset,
					 <span class="type">size_t</span> size,
					 <span class="type">void *</span> buffer,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This function allows you to read the contents of a domain's disk device.</p><p>Typical uses for this are to determine if the domain has written a Master Boot Record (indicating that the domain has completed installation), or to try to work out the state of the domain's filesystems.</p><p>(Note that in the local case you might try to open the block device or file directly, but that won't work in the remote case, nor if you don't have sufficient permission. Hence the need for this call).</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or (since 0.9.5) the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p><p>'offset' and 'size' represent an area which must lie entirely within the device or file. 'size' may be 0 to test if the call would succeed.</p><p>'buffer' is the return buffer and must be at least 'size' bytes.</p><p>NB. The remote driver imposes a 64K byte limit on 'size'. For your program to be able to work reliably over a remote connection you should split large requests to &lt;= 65536 bytes. However, with 0.9.13 this RPC limit has been raised to 1M byte. Starting with version 1.0.6 the RPC limit has been raised again. Now large requests up to 16M byte are supported.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>offset</dt><dd>offset within block device</dd><dt>size</dt><dd>size to read</dd><dt>buffer</dt><dd>return buffer (must be at least size bytes)</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success or -1 in case of failure. really 64 bits</dd></dl><div class="acl"></div><h3><a name="virDomainBlockPull" id="virDomainBlockPull"><code>virDomainBlockPull</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockPull		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type">unsigned long</span> bandwidth,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Populate a disk image with data from its backing image. Once all data from its backing image has been pulled, the disk no longer depends on a backing image. This function pulls data for the entire device in the background. Progress of the operation can be checked with <a href="libvirt-libvirt.html#virDomainGetBlockJobInfo">virDomainGetBlockJobInfo</a>() and the operation can be aborted with <a href="libvirt-libvirt.html#virDomainBlockJobAbort">virDomainBlockJobAbort</a>(). When finished, an asynchronous event is raised to indicate the final status. To move data in the opposite direction, see <a href="libvirt-libvirt.html#virDomainBlockCommit">virDomainBlockCommit</a>().</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or (since 0.9.5) the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p><p>The maximum bandwidth (in MiB/s) that will be used to do the copy can be specified with the bandwidth parameter. If set to 0, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if bandwidth is not 0; in this case, it might still be possible for a later call to <a href="libvirt-libvirt.html#virDomainBlockJobSetSpeed">virDomainBlockJobSetSpeed</a>() to succeed. The actual speed can be determined with <a href="libvirt-libvirt.html#virDomainGetBlockJobInfo">virDomainGetBlockJobInfo</a>().</p><p>This is shorthand for <a href="libvirt-libvirt.html#virDomainBlockRebase">virDomainBlockRebase</a>() with a NULL base.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>bandwidth</dt><dd>(optional) specify copy bandwidth limit in MiB/s</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 if the operation has started, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virDomainBlockRebase" id="virDomainBlockRebase"><code>virDomainBlockRebase</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockRebase		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type">const char *</span> base,
					 <span class="type">unsigned long</span> bandwidth,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Populate a disk image with data from its backing image chain, and setting the backing image to @base, or alternatively copy an entire backing chain to a new file @base.</p><p>When @flags is 0, this starts a pull, where @base must be the absolute path of one of the backing images further up the chain, or NULL to convert the disk image so that it has no backing image. Once all data from its backing image chain has been pulled, the disk no longer depends on those intermediate backing images. This function pulls data for the entire device in the background. Progress of the operation can be checked with <a href="libvirt-libvirt.html#virDomainGetBlockJobInfo">virDomainGetBlockJobInfo</a>() with a job type of <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_TYPE_PULL">VIR_DOMAIN_BLOCK_JOB_TYPE_PULL</a>, and the operation can be aborted with <a href="libvirt-libvirt.html#virDomainBlockJobAbort">virDomainBlockJobAbort</a>(). When finished, an asynchronous event is raised to indicate the final status, and the job no longer exists. If the job is aborted, a new one can be started later to resume from the same point.</p><p>When @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_REBASE_COPY">VIR_DOMAIN_BLOCK_REBASE_COPY</a>, this starts a copy, where @base must be the name of a new file to copy the chain to. By default, the copy will pull the entire source chain into the destination file, but if @flags also contains <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_REBASE_SHALLOW">VIR_DOMAIN_BLOCK_REBASE_SHALLOW</a>, then only the top of the source chain will be copied (the source and destination have a common backing file). By default, @base will be created with the same file format as the source, but this can be altered by adding <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_REBASE_COPY_RAW">VIR_DOMAIN_BLOCK_REBASE_COPY_RAW</a> to force the copy to be raw (does not make sense with the shallow flag unless the source is also raw), or by using <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT">VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT</a> to reuse an existing file with initial contents identical to the backing file of the source (this allows a management app to pre-create files with relative backing file names, rather than the default of absolute backing file names; as a security precaution, you should generally only use reuse_ext with the shallow flag and a non-raw destination file).</p><p>A copy job has two parts; in the first phase, the @bandwidth parameter affects how fast the source is pulled into the destination, and the job can only be canceled by reverting to the source file; progress in this phase can be tracked via the <a href="libvirt-libvirt.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a>() command, with a job type of <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_JOB_TYPE_COPY">VIR_DOMAIN_BLOCK_JOB_TYPE_COPY</a>. The job transitions to the second phase when the job info states cur == end, and remains alive to mirror all further changes to both source and destination. The user must call <a href="libvirt-libvirt.html#virDomainBlockJobAbort">virDomainBlockJobAbort</a>() to end the mirroring while choosing whether to revert to source or pivot to the destination. An event is issued when the job ends, and depending on the hypervisor, an event may also be issued when the job transitions from pulling to mirroring. If the job is aborted, a new job will have to start over from the beginning of the first phase.</p><p>Some hypervisors will restrict certain actions, such as <a href="libvirt-libvirt.html#virDomainSave">virDomainSave</a>() or <a href="libvirt-libvirt.html#virDomainDetachDevice">virDomainDetachDevice</a>(), while a copy job is active; they may also restrict a copy job to transient domains.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p><p>The maximum bandwidth (in MiB/s) that will be used to do the copy can be specified with the bandwidth parameter. If set to 0, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if bandwidth is not 0; in this case, it might still be possible for a later call to <a href="libvirt-libvirt.html#virDomainBlockJobSetSpeed">virDomainBlockJobSetSpeed</a>() to succeed. The actual speed can be determined with <a href="libvirt-libvirt.html#virDomainGetBlockJobInfo">virDomainGetBlockJobInfo</a>().</p><p>When @base is NULL and @flags is 0, this is identical to <a href="libvirt-libvirt.html#virDomainBlockPull">virDomainBlockPull</a>().</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>base</dt><dd>path to backing file to keep, or NULL for no backing file</dd><dt>bandwidth</dt><dd>(optional) specify copy bandwidth limit in MiB/s</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainBlockRebaseFlags">virDomainBlockRebaseFlags</a></dd><dt>Returns</dt><dd>0 if the operation has started, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virDomainBlockResize" id="virDomainBlockResize"><code>virDomainBlockResize</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockResize		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type">unsigned long long</span> size,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Resize a block device of domain while the domain is running. If @flags is 0, then @size is in kibibytes (blocks of 1024 bytes); since 0.9.11, if @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_BLOCK_RESIZE_BYTES">VIR_DOMAIN_BLOCK_RESIZE_BYTES</a>, @size is in bytes instead. @size is taken directly as the new size. Depending on the file format, the hypervisor may round up to the next alignment boundary.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or (since 0.9.5) the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p><p>Note that this call may fail if the underlying virtualization hypervisor does not support it; this call requires privileged access to the hypervisor.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>disk</dt><dd>path to the block image, or shorthand</dd><dt>size</dt><dd>new size of the block image, see below for unit</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainBlockResizeFlags">virDomainBlockResizeFlags</a></dd><dt>Returns</dt><dd>0 in case of success or -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainBlockStats" id="virDomainBlockStats"><code>virDomainBlockStats</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockStats		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a></span> stats,
					 <span class="type">size_t</span> size)</pre><div class="description"><p>This function returns block device (disk) stats for block devices attached to the domain.</p><p>The @disk parameter is either the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"), or (since 0.9.8) an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p><p>Domains may have more than one block device. To get stats for each you should make multiple calls to this function.</p><p>Individual fields within the stats structure may be returned as -1, which indicates that the hypervisor does not support that particular statistic.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>stats</dt><dd>block device stats (returned)</dd><dt>size</dt><dd>size of stats structure</dd><dt>Returns</dt><dd>0 in case of success or -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainBlockStatsFlags" id="virDomainBlockStatsFlags"><code>virDomainBlockStatsFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainBlockStatsFlags	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This function is to get block stats parameters for block devices attached to the domain.</p><p>The @disk parameter is either the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"), or (since 0.9.8) an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p><p>Domains may have more than one block device. To get stats for each you should make multiple calls to this function.</p><p>On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value.</p><p>As a special case, calling with @params as NULL and @nparams as 0 on input will cause @nparams on output to contain the number of parameters supported by the hypervisor. (Note that block devices of different types might support different parameters, so it might be necessary to compute @nparams for each block device). The caller should then allocate @params array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API again. See <a href="libvirt-libvirt.html#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>() for more details.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>params</dt><dd>pointer to block stats parameter object (return value)</dd><dt>nparams</dt><dd>pointer to number of block stats; input and output</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainCoreDump" id="virDomainCoreDump"><code>virDomainCoreDump</code></a></h3><pre class="api"><span class="type">int</span>	virDomainCoreDump		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> to,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This method will dump the core of a domain on a given file for analysis. Note that for remote Xen Daemon the file path will be interpreted in the remote host. Hypervisors may require the user to manually ensure proper permissions on the file named by @to.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DUMP_CRASH">VIR_DUMP_CRASH</a>, then leave the guest shut off with a crashed state after the dump completes. If @flags includes <a href="libvirt-libvirt.html#VIR_DUMP_LIVE">VIR_DUMP_LIVE</a>, then make the core dump while continuing to allow the guest to run; otherwise, the guest is suspended during the dump. <a href="libvirt-libvirt.html#VIR_DUMP_RESET">VIR_DUMP_RESET</a> flag forces reset of the quest after dump. The above three flags are mutually exclusive.</p><p>Additionally, if @flags includes <a href="libvirt-libvirt.html#VIR_DUMP_BYPASS_CACHE">VIR_DUMP_BYPASS_CACHE</a>, then libvirt will attempt to bypass the file system cache while creating the file, or fail if it cannot do so for the given system; this can allow less pressure on file system cache, but also risks slowing saves to NFS.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>to</dt><dd>path for the core file</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a></dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainCreate" id="virDomainCreate"><code>virDomainCreate</code></a></h3><pre class="api"><span class="type">int</span>	virDomainCreate			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Launch a defined domain. If the call succeeds the domain moves from the defined to the running domains pools. The domain will be paused only if restoring from managed state created from a paused domain. For more control, see <a href="libvirt-libvirt.html#virDomainCreateWithFlags">virDomainCreateWithFlags</a>().</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to a defined domain</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virDomainCreateLinux" id="virDomainCreateLinux"><code>virDomainCreateLinux</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainCreateLinux	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xmlDesc,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Deprecated after 0.4.6. Renamed to <a href="libvirt-libvirt.html#virDomainCreateXML">virDomainCreateXML</a>() providing identical functionality. This existing name will left indefinitely for API compatibility.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xmlDesc</dt><dd>string containing an XML description of the domain</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a new domain object or NULL in case of failure</dd></dl><div class="acl"></div><h3><a name="virDomainCreateWithFiles" id="virDomainCreateWithFiles"><code>virDomainCreateWithFiles</code></a></h3><pre class="api"><span class="type">int</span>	virDomainCreateWithFiles	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> nfiles,
					 <span class="type">int *</span> files,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Launch a defined domain. If the call succeeds the domain moves from the defined to the running domains pools.</p><p>@files provides an array of file descriptors which will be made available to the 'init' process of the guest. The file handles exposed to the guest will be renumbered to start from 3 (ie immediately following stderr). This is only supported for guests which use container based virtualization technology.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, or if the guest domain has a managed save image that requested paused state (see <a href="libvirt-libvirt.html#virDomainManagedSave">virDomainManagedSave</a>()) the guest domain will be started, but its CPUs will remain paused. The CPUs can later be manually started using <a href="libvirt-libvirt.html#virDomainResume">virDomainResume</a>(). In all other cases, the guest domain will be running.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest domain will be automatically destroyed when the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> object is finally released. This will also happen if the client application crashes / loses its connection to the libvirtd daemon. Any domains marked for auto destroy will block attempts at migration, save-to-file, or snapshots.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a> flag is set, and there is a managed save file for this domain (created by <a href="libvirt-libvirt.html#virDomainManagedSave">virDomainManagedSave</a>()), then libvirt will attempt to bypass the file system cache while restoring the file, or fail if it cannot do so for the given system; this can allow less pressure on file system cache, but also risks slowing loads from NFS.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a> flag is set, then any managed save file for this domain is discarded, and the domain boots from scratch.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to a defined domain</dd><dt>nfiles</dt><dd>number of file descriptors passed</dd><dt>files</dt><dd>list of file descriptors passed</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virDomainCreateWithFlags" id="virDomainCreateWithFlags"><code>virDomainCreateWithFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainCreateWithFlags	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Launch a defined domain. If the call succeeds the domain moves from the defined to the running domains pools.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, or if the guest domain has a managed save image that requested paused state (see <a href="libvirt-libvirt.html#virDomainManagedSave">virDomainManagedSave</a>()) the guest domain will be started, but its CPUs will remain paused. The CPUs can later be manually started using <a href="libvirt-libvirt.html#virDomainResume">virDomainResume</a>(). In all other cases, the guest domain will be running.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest domain will be automatically destroyed when the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> object is finally released. This will also happen if the client application crashes / loses its connection to the libvirtd daemon. Any domains marked for auto destroy will block attempts at migration, save-to-file, or snapshots.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a> flag is set, and there is a managed save file for this domain (created by <a href="libvirt-libvirt.html#virDomainManagedSave">virDomainManagedSave</a>()), then libvirt will attempt to bypass the file system cache while restoring the file, or fail if it cannot do so for the given system; this can allow less pressure on file system cache, but also risks slowing loads from NFS.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a> flag is set, then any managed save file for this domain is discarded, and the domain boots from scratch.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to a defined domain</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virDomainCreateXML" id="virDomainCreateXML"><code>virDomainCreateXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainCreateXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xmlDesc,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Launch a new guest domain, based on an XML description similar to the one returned by <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() This function may require privileged access to the hypervisor. The domain is not persistent, so its definition will disappear when it is destroyed, or if the host is restarted (see <a href="libvirt-libvirt.html#virDomainDefineXML">virDomainDefineXML</a>() to define persistent domains).</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, the guest domain will be started, but its CPUs will remain paused. The CPUs can later be manually started using <a href="libvirt-libvirt.html#virDomainResume">virDomainResume</a>.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest domain will be automatically destroyed when the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> object is finally released. This will also happen if the client application crashes / loses its connection to the libvirtd daemon. Any domains marked for auto destroy will block attempts at migration, save-to-file, or snapshots.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xmlDesc</dt><dd>string containing an XML description of the domain</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></dd><dt>Returns</dt><dd>a new domain object or NULL in case of failure</dd></dl><div class="acl"></div><h3><a name="virDomainCreateXMLWithFiles" id="virDomainCreateXMLWithFiles"><code>virDomainCreateXMLWithFiles</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainCreateXMLWithFiles	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> xmlDesc,
						 <span class="type">unsigned int</span> nfiles,
						 <span class="type">int *</span> files,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Launch a new guest domain, based on an XML description similar to the one returned by <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() This function may require privileged access to the hypervisor. The domain is not persistent, so its definition will disappear when it is destroyed, or if the host is restarted (see <a href="libvirt-libvirt.html#virDomainDefineXML">virDomainDefineXML</a>() to define persistent domains).</p><p>@files provides an array of file descriptors which will be made available to the 'init' process of the guest. The file handles exposed to the guest will be renumbered to start from 3 (ie immediately following stderr). This is only supported for guests which use container based virtualization technology.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, the guest domain will be started, but its CPUs will remain paused. The CPUs can later be manually started using <a href="libvirt-libvirt.html#virDomainResume">virDomainResume</a>.</p><p>If the <a href="libvirt-libvirt.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest domain will be automatically destroyed when the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> object is finally released. This will also happen if the client application crashes / loses its connection to the libvirtd daemon. Any domains marked for auto destroy will block attempts at migration, save-to-file, or snapshots.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xmlDesc</dt><dd>string containing an XML description of the domain</dd><dt>nfiles</dt><dd>number of file descriptors passed</dd><dt>files</dt><dd>list of file descriptors passed</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></dd><dt>Returns</dt><dd>a new domain object or NULL in case of failure</dd></dl><div class="acl"></div><h3><a name="virDomainDefineXML" id="virDomainDefineXML"><code>virDomainDefineXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainDefineXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xml)</pre><div class="description"><p>Define a domain, but does not start it. This definition is persistent, until explicitly undefined with <a href="libvirt-libvirt.html#virDomainUndefine">virDomainUndefine</a>(). A previous definition for this domain would be overridden if it already exists.</p><p>Some hypervisors may prevent this operation if there is a current block copy operation on a transient domain with the same id as the domain being defined; in that case, use <a href="libvirt-libvirt.html#virDomainBlockJobAbort">virDomainBlockJobAbort</a>() to stop the block copy first.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xml</dt><dd>the XML description for the domain, preferably in UTF-8</dd><dt>Returns</dt><dd>NULL in case of error, a pointer to the domain otherwise</dd></dl><div class="acl"></div><h3><a name="virDomainDestroy" id="virDomainDestroy"><code>virDomainDestroy</code></a></h3><pre class="api"><span class="type">int</span>	virDomainDestroy		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Destroy the domain object. The running instance is shutdown if not down already and all resources used by it are given back to the hypervisor. This does not free the associated <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object. This function may require privileged access.</p><p><a href="libvirt-libvirt.html#virDomainDestroy">virDomainDestroy</a> first requests that a guest terminate (e.g. SIGTERM), then waits for it to comply. After a reasonable timeout, if the guest still exists, <a href="libvirt-libvirt.html#virDomainDestroy">virDomainDestroy</a> will forcefully terminate the guest (e.g. SIGKILL) if necessary (which may produce undesirable results, for example unflushed disk cache in the guest). To avoid this possibility, it's recommended to instead call <a href="libvirt-libvirt.html#virDomainDestroyFlags">virDomainDestroyFlags</a>, sending the <a href="libvirt-libvirt.html#VIR_DOMAIN_DESTROY_GRACEFUL">VIR_DOMAIN_DESTROY_GRACEFUL</a> flag.</p><p>If the domain is transient and has any snapshot metadata (see <a href="libvirt-libvirt.html#virDomainSnapshotNum">virDomainSnapshotNum</a>()), then that metadata will automatically be deleted when the domain quits.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainDestroyFlags" id="virDomainDestroyFlags"><code>virDomainDestroyFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainDestroyFlags		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Destroy the domain object. The running instance is shutdown if not down already and all resources used by it are given back to the hypervisor. This does not free the associated <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object. This function may require privileged access.</p><p>Calling this function with no @flags set (equal to zero) is equivalent to calling <a href="libvirt-libvirt.html#virDomainDestroy">virDomainDestroy</a>, and after a reasonable timeout will forcefully terminate the guest (e.g. SIGKILL) if necessary (which may produce undesirable results, for example unflushed disk cache in the guest). Including <a href="libvirt-libvirt.html#VIR_DOMAIN_DESTROY_GRACEFUL">VIR_DOMAIN_DESTROY_GRACEFUL</a> in the flags will prevent the forceful termination of the guest, and <a href="libvirt-libvirt.html#virDomainDestroyFlags">virDomainDestroyFlags</a> will instead return an error if the guest doesn't terminate by the end of the timeout; at that time, the management application can decide if calling again without <a href="libvirt-libvirt.html#VIR_DOMAIN_DESTROY_GRACEFUL">VIR_DOMAIN_DESTROY_GRACEFUL</a> is appropriate.</p><p>Another alternative which may produce cleaner results for the guest's disks is to use <a href="libvirt-libvirt.html#virDomainShutdown">virDomainShutdown</a>() instead, but that depends on guest support (some hypervisor/guest combinations may ignore the shutdown request).</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainDestroyFlagsValues">virDomainDestroyFlagsValues</a></dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainDetachDevice" id="virDomainDetachDevice"><code>virDomainDetachDevice</code></a></h3><pre class="api"><span class="type">int</span>	virDomainDetachDevice		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> xml)</pre><div class="description"><p>Destroy a virtual device attachment to backend. This function, having hot-unplug semantics, is only allowed on an active domain.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>xml</dt><dd>pointer to XML description of one device</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainDetachDeviceFlags" id="virDomainDetachDeviceFlags"><code>virDomainDetachDeviceFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainDetachDeviceFlags	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> xml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Detach a virtual device from a domain, using the flags parameter to control how the device is detached. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a> specifies that the device allocation is removed based on current domain state. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be deallocated from the active domain instance only and is not from the persisted domain configuration. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> specifies that the device shall be deallocated from the persisted domain configuration only. Note that the target hypervisor must return an error if unable to satisfy flags. E.g. the hypervisor driver will return failure if LIVE is specified but it only supports removing the persisted device allocation.</p><p>Some hypervisors may prevent this operation if there is a current block copy operation on the device being detached; in that case, use <a href="libvirt-libvirt.html#virDomainBlockJobAbort">virDomainBlockJobAbort</a>() to stop the block copy first.</p><p>Beware that depending on the hypervisor and device type, detaching a device from a running domain may be asynchronous. That is, calling <a href="libvirt-libvirt.html#virDomainDetachDeviceFlags">virDomainDetachDeviceFlags</a> may just request device removal while the device is actually removed later (in cooperation with a guest OS). Previously, this fact was ignored and the device could have been removed from domain configuration before it was actually removed by the hypervisor causing various failures on subsequent operations. To check whether the device was successfully removed, either recheck domain configuration using <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() or add handler for <a href="libvirt-libvirt.html#VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED">VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED</a> event. In case the device is already gone when <a href="libvirt-libvirt.html#virDomainDetachDeviceFlags">virDomainDetachDeviceFlags</a></p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>xml</dt><dd>pointer to XML description of one device</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></dd><dt>Returns</dt><dd>the event is delivered before this API call ends. To help existing clients work better in most cases, this API will try to transform an asynchronous device removal that finishes shortly after the request into a synchronous removal. In other words, this API may wait a bit for the removal to complete in case it was not synchronous. Returns 0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainFSTrim" id="virDomainFSTrim"><code>virDomainFSTrim</code></a></h3><pre class="api"><span class="type">int</span>	virDomainFSTrim			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> mountPoint,
					 <span class="type">unsigned long long</span> minimum,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Calls FITRIM within the guest (hence guest agent may be required depending on hypervisor used). Either call it on each mounted filesystem (@mountPoint is NULL) or just on specified @mountPoint. @minimum hints that free ranges smaller than this may be ignored (this is a hint and the guest may not respect it). By increasing this value, the fstrim operation will complete more quickly for filesystems with badly fragmented free space, although not all blocks will be discarded. If @minimum is not zero, the command may fail.</p></div><dl class="variablelist"><dt>dom</dt><dd>a domain object</dd><dt>mountPoint</dt><dd>which mount point to trim</dd><dt>minimum</dt><dd>Minimum contiguous free range to discard in bytes</dd><dt>flags</dt><dd>extra flags, not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 on success, -1 otherwise.</dd></dl><div class="acl"></div><h3><a name="virDomainFree" id="virDomainFree"><code>virDomainFree</code></a></h3><pre class="api"><span class="type">int</span>	virDomainFree			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Free the domain object. The running instance is kept alive. The data structure is freed and should not be used thereafter.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetAutostart" id="virDomainGetAutostart"><code>virDomainGetAutostart</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetAutostart		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int *</span> autostart)</pre><div class="description"><p>Provides a boolean value indicating whether the domain configured to be automatically started when the host machine boots.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>autostart</dt><dd>the value returned</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virDomainGetBlkioParameters" id="virDomainGetBlkioParameters"><code>virDomainGetBlkioParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetBlkioParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get all blkio parameters. On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value.</p><p>As a special case, calling with @params as NULL and @nparams as 0 on input will cause @nparams on output to contain the number of parameters supported by the hypervisor. The caller should then allocate @params array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API again.</p><p>See <a href="libvirt-libvirt.html#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>() for an equivalent usage example.</p><p>This function may require privileged access to the hypervisor. This function expects the caller to allocate the @params.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to blkio parameter object (return value, allocated by the caller)</dd><dt>nparams</dt><dd>pointer to number of blkio parameters; input and output</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainGetBlockInfo" id="virDomainGetBlockInfo"><code>virDomainGetBlockInfo</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetBlockInfo		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> disk,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a></span> info,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Extract information about a domain's block device.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or (since 0.9.5) the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>info</dt><dd>pointer to a <a href="libvirt-libvirt.html#virDomainBlockInfo">virDomainBlockInfo</a> structure allocated by the user</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetBlockIoTune" id="virDomainGetBlockIoTune"><code>virDomainGetBlockIoTune</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetBlockIoTune		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get all block IO tunable parameters for a given device. On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value.</p><p>As a special case, calling with @params as NULL and @nparams as 0 on input will cause @nparams on output to contain the number of parameters supported by the hypervisor, either for the given @disk (note that block devices of different types might support different parameters), or if @disk is NULL, for all possible disks. The caller should then allocate @params array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API again. See <a href="libvirt-libvirt.html#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>() for more details.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk. This parameter cannot be NULL unless @nparams is 0 on input.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>params</dt><dd>Pointer to blkio parameter object (return value, allocated by the caller)</dd><dt>nparams</dt><dd>Pointer to number of blkio parameters</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainGetBlockJobInfo" id="virDomainGetBlockJobInfo"><code>virDomainGetBlockJobInfo</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetBlockJobInfo	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a></span> info,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Request block job information for the given disk. If an operation is active @info will be updated with the current progress.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or (since 0.9.5) the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>info</dt><dd>pointer to a <a href="libvirt-libvirt.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a> structure</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>-1 in case of failure, 0 when nothing found, 1 when info was found.</dd></dl><div class="acl"></div><h3><a name="virDomainGetCPUStats" id="virDomainGetCPUStats"><code>virDomainGetCPUStats</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetCPUStats		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">unsigned int</span> nparams,
					 <span class="type">int</span> start_cpu,
					 <span class="type">unsigned int</span> ncpus,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get statistics relating to CPU usage attributable to a single domain (in contrast to the statistics returned by <a href="libvirt-libvirt.html#virNodeGetCPUStats">virNodeGetCPUStats</a>() for all processes on the host). @dom must be running (an inactive domain has no attributable cpu usage). On input, @params must contain at least @nparams * @ncpus entries, allocated by the caller.</p><p>If @start_cpu is -1, then @ncpus must be 1, and the returned results reflect the statistics attributable to the entire domain (such as user and system time for the process as a whole). Otherwise, @start_cpu represents which cpu to start with, and @ncpus represents how many consecutive processors to query, with statistics attributable per processor (such as per-cpu usage). If @ncpus is larger than the number of cpus available to query, then the trailing part of the array will be unpopulated.</p><p>The remote driver imposes a limit of 128 @ncpus and 16 @nparams; the number of parameters per cpu should not exceed 16, but if you have a host with more than 128 CPUs, your program should split the request into multiple calls.</p><p>As special cases, if @params is NULL and @nparams is 0 and @ncpus is 1, and the return value will be how many statistics are available for the given @start_cpu. This number may be different for @start_cpu of -1 than for any non-negative value, but will be the same for all non-negative @start_cpu. Likewise, if @params is NULL and @nparams is 0 and @ncpus is 0, the number of cpus available to query is returned. From the host perspective, this would typically match the cpus member of <a href="libvirt-libvirt.html#virNodeGetInfo">virNodeGetInfo</a>(), but might be less due to host cpu hotplug.</p><p>For now, @flags is unused, and the statistics all relate to the usage from the host perspective. It is possible that a future version will support a flag that queries the cpu usage from the guest's perspective, where the maximum cpu to query would be related to <a href="libvirt-libvirt.html#virDomainGetVcpusFlags">virDomainGetVcpusFlags</a>() rather than <a href="libvirt-libvirt.html#virNodeGetInfo">virNodeGetInfo</a>(). An individual guest vcpu cannot be reliably mapped back to a specific host cpu unless a single-processor vcpu pinning was used, but when @start_cpu is -1, any difference in usage between a host and guest perspective would serve as a measure of hypervisor overhead.</p><p>Typical use sequence is below.</p><p>getting total stats: set start_cpu as -1, ncpus 1 virDomainGetCPUStats(dom, NULL, 0, -1, 1, 0) =&gt; nparams params = calloc(nparams, sizeof(virTypedParameter)) virDomainGetCPUStats(dom, params, nparams, -1, 1, 0) =&gt; total stats.</p><p>getting per-cpu stats: virDomainGetCPUStats(dom, NULL, 0, 0, 0, 0) =&gt; ncpus virDomainGetCPUStats(dom, NULL, 0, 0, 1, 0) =&gt; nparams params = calloc(ncpus * nparams, sizeof(virTypedParameter)) virDomainGetCPUStats(dom, params, nparams, 0, ncpus, 0) =&gt; per-cpu stats</p></div><dl class="variablelist"><dt>domain</dt><dd>domain to query</dd><dt>params</dt><dd>array to populate on output</dd><dt>nparams</dt><dd>number of parameters per cpu</dd><dt>start_cpu</dt><dd>which cpu to start with, or -1 for summary</dd><dt>ncpus</dt><dd>how many cpus to query</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></dd><dt>Returns</dt><dd>-1 on failure, or the number of statistics that were populated per cpu on success (this will be less than the total number of populated @params, unless @ncpus was 1; and may be less than @nparams). The populated parameters start at each stride of @nparams, which means the results may be discontiguous; any unpopulated parameters will be zeroed on success (this includes skipped elements if @nparams is too large, and tail elements if @ncpus is too large). The caller is responsible for freeing any returned string parameters.</dd></dl><div class="acl"></div><h3><a name="virDomainGetConnect" id="virDomainGetConnect"><code>virDomainGetConnect</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virDomainGetConnect	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom)</pre><div class="description"><p>Provides the connection pointer associated with a domain. The reference counter on the connection is not increased by this call.</p><p>WARNING: When writing libvirt bindings in other languages, do not use this function. Instead, store the connection and the domain object together.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to a domain</dd><dt>Returns</dt><dd>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetControlInfo" id="virDomainGetControlInfo"><code>virDomainGetControlInfo</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetControlInfo		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainControlInfoPtr">virDomainControlInfoPtr</a></span> info,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Extract details about current state of control interface to a domain.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>info</dt><dd>pointer to a <a href="libvirt-libvirt.html#virDomainControlInfo">virDomainControlInfo</a> structure allocated by the user</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetDiskErrors" id="virDomainGetDiskErrors"><code>virDomainGetDiskErrors</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetDiskErrors		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainDiskErrorPtr">virDomainDiskErrorPtr</a></span> errors,
					 <span class="type">unsigned int</span> maxerrors,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>The function populates @errors array with all disks that encountered an I/O error. Disks with no error will not be returned in the @errors array. Each disk is identified by its target (the dev attribute of target subelement in domain XML), such as "vda", and accompanied with the error that was seen on it. The caller is also responsible for calling free() on each disk name returned.</p><p>In a special case when @errors is NULL and @maxerrors is 0, the function</p></div><dl class="variablelist"><dt>dom</dt><dd>a domain object</dd><dt>errors</dt><dd>array to populate on output</dd><dt>maxerrors</dt><dd>size of @errors array</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>preferred size of @errors that the caller should use to get all disk errors. Since calling virDomainGetDiskErrors(dom, NULL, 0, 0) to get preferred size of @errors array and getting the errors are two separate operations, new disks may be hotplugged to the domain and new errors may be encountered between the two calls. Thus, this function may not return all disk errors because the supplied array is not large enough. Such errors may, however, be detected by listening to domain events. Returns number of disks with errors filled in the @errors array or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virDomainGetEmulatorPinInfo" id="virDomainGetEmulatorPinInfo"><code>virDomainGetEmulatorPinInfo</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetEmulatorPinInfo	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned char *</span> cpumap,
					 <span class="type">int</span> maplen,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Query the CPU affinity setting of all emulator threads of domain, store it in cpumap.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>cpumap</dt><dd>pointer to a bit map of real CPUs for all emulator threads of this domain (in 8-bit bytes) (OUT) There is only one cpumap for all emulator threads. Must not be NULL.</dd><dt>maplen</dt><dd>the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive.</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> Must not be <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> concurrently.</dd><dt>Returns</dt><dd>1 in case of success, 0 in case of no emulator threads are pined to pcpus, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetHostname" id="virDomainGetHostname"><code>virDomainGetHostname</code></a></h3><pre class="api"><span class="type">char *</span>	virDomainGetHostname		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get the hostname for that domain.</p><p>Dependent on hypervisor used, this may require a guest agent to be available.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the hostname which must be freed by the caller, or NULL if there was an error.</dd></dl><div class="acl"></div><h3><a name="virDomainGetID" id="virDomainGetID"><code>virDomainGetID</code></a></h3><pre class="api"><span class="type">unsigned int</span>	virDomainGetID		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Get the hypervisor ID number for the domain</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>the domain ID number or (unsigned int) -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virDomainGetInfo" id="virDomainGetInfo"><code>virDomainGetInfo</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetInfo		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainInfoPtr">virDomainInfoPtr</a></span> info)</pre><div class="description"><p>Extract information about a domain. Note that if the connection used to get the domain is limited only a partial set of the information can be extracted.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>info</dt><dd>pointer to a <a href="libvirt-libvirt.html#virDomainInfo">virDomainInfo</a> structure allocated by the user</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetInterfaceParameters" id="virDomainGetInterfaceParameters"><code>virDomainGetInterfaceParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetInterfaceParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> device,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get all interface parameters. On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value.</p><p>As a special case, calling with @params as NULL and @nparams as 0 on input will cause @nparams on output to contain the number of parameters supported by the hypervisor. The caller should then allocate @params array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API again. See <a href="libvirt-libvirt.html#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>() for an equivalent usage example.</p><p>This function may require privileged access to the hypervisor. This function expects the caller to allocate the @params.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>device</dt><dd>the interface name or mac address</dd><dt>params</dt><dd>pointer to interface parameter objects (return value, allocated by the caller)</dd><dt>nparams</dt><dd>pointer to number of interface parameter; input and output</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainGetJobInfo" id="virDomainGetJobInfo"><code>virDomainGetJobInfo</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetJobInfo		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainJobInfoPtr">virDomainJobInfoPtr</a></span> info)</pre><div class="description"><p>Extract information about progress of a background job on a domain. Will return an error if the domain is not active.</p><p>This function returns a limited amount of information in comparison to <a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a>().</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>info</dt><dd>pointer to a <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a> structure allocated by the user</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetJobStats" id="virDomainGetJobStats"><code>virDomainGetJobStats</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetJobStats		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int *</span> type,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Extract information about progress of a background job on a domain. Will return an error if the domain is not active. The function returns a superset of progress information provided by <a href="libvirt-libvirt.html#virDomainGetJobInfo">virDomainGetJobInfo</a>. Possible fields returned in @params are defined by VIR_DOMAIN_JOB_* macros and new fields will likely be introduced in the future so callers may receive fields that they do not understand in case they talk to a newer server.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>type</dt><dd>where to store the job type (one of <a href="libvirt-libvirt.html#virDomainJobType">virDomainJobType</a>)</dd><dt>params</dt><dd>where to store job statistics</dd><dt>nparams</dt><dd>number of items in @params</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetMaxMemory" id="virDomainGetMaxMemory"><code>virDomainGetMaxMemory</code></a></h3><pre class="api"><span class="type">unsigned long</span>	virDomainGetMaxMemory	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Retrieve the maximum amount of physical memory allocated to a domain. If domain is NULL, then this get the amount of memory reserved to Domain0 i.e. the domain where the application runs.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object or NULL</dd><dt>Returns</dt><dd>the memory size in kibibytes (blocks of 1024 bytes), or 0 in case of error.</dd></dl><div class="acl"></div><h3><a name="virDomainGetMaxVcpus" id="virDomainGetMaxVcpus"><code>virDomainGetMaxVcpus</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetMaxVcpus		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Provides the maximum number of virtual CPUs supported for the guest VM. If the guest is inactive, this is basically the same as <a href="libvirt-libvirt.html#virConnectGetMaxVcpus">virConnectGetMaxVcpus</a>(). If the guest is running this will reflect the maximum number of virtual CPUs the guest was booted with. For more details, see <a href="libvirt-libvirt.html#virDomainGetVcpusFlags">virDomainGetVcpusFlags</a>().</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>Returns</dt><dd>the maximum of virtual CPU or -1 in case of error.</dd></dl><div class="acl"></div><h3><a name="virDomainGetMemoryParameters" id="virDomainGetMemoryParameters"><code>virDomainGetMemoryParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetMemoryParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get all memory parameters. On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value.</p><p>As a special case, calling with @params as NULL and @nparams as 0 on input will cause @nparams on output to contain the number of parameters supported by the hypervisor. The caller should then allocate @params array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API again.</p><p>Here is a sample code snippet:</p><pre class="code">if ((virDomainGetMemoryParameters(dom, NULL, &amp;nparams, 0) == 0) &amp;&amp;
    (nparams != 0)) {
    if ((params = malloc(sizeof(*params) * nparams)) == NULL)
        goto error;
    memset(params, 0, sizeof(*params) * nparams);
    if (virDomainGetMemoryParameters(dom, params, &amp;nparams, 0))
        goto error;
}</pre><p>This function may require privileged access to the hypervisor. This function expects the caller to allocate the @params.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to memory parameter object (return value, allocated by the caller)</dd><dt>nparams</dt><dd>pointer to number of memory parameters; input and output</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainGetMetadata" id="virDomainGetMetadata"><code>virDomainGetMetadata</code></a></h3><pre class="api"><span class="type">char *</span>	virDomainGetMetadata		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int</span> type,
					 <span class="type">const char *</span> uri,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Retrieves the appropriate domain element given by @type. If <a href="libvirt-libvirt.html#VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a> is requested parameter @uri must be set to the name of the namespace the requested elements belong to, otherwise must be NULL.</p><p>If an element of the domain XML is not present, the resulting error will be <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_METADATA">VIR_ERR_NO_DOMAIN_METADATA</a>. This method forms a shortcut for seeing information from <a href="libvirt-libvirt.html#virDomainSetMetadata">virDomainSetMetadata</a>() without having to go through <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>().</p><p>@flags controls whether the live domain or persistent configuration will be queried.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>type</dt><dd>type of description, from <a href="libvirt-libvirt.html#virDomainMetadataType">virDomainMetadataType</a></dd><dt>uri</dt><dd>XML namespace identifier</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>the metadata string on success (caller must free), or NULL in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetName" id="virDomainGetName"><code>virDomainGetName</code></a></h3><pre class="api"><span class="type">const char *</span>	virDomainGetName	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Get the public name for that domain</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.</dd></dl><div class="acl"></div><h3><a name="virDomainGetNumaParameters" id="virDomainGetNumaParameters"><code>virDomainGetNumaParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetNumaParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get all numa parameters. On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value.</p><p>As a special case, calling with @params as NULL and @nparams as 0 on input will cause @nparams on output to contain the number of parameters supported by the hypervisor. The caller should then allocate @params array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API again.</p><p>See <a href="libvirt-libvirt.html#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>() for an equivalent usage example.</p><p>This function may require privileged access to the hypervisor. This function expects the caller to allocate the @params.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to numa parameter object (return value, allocated by the caller)</dd><dt>nparams</dt><dd>pointer to number of numa parameters</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainGetOSType" id="virDomainGetOSType"><code>virDomainGetOSType</code></a></h3><pre class="api"><span class="type">char *</span>	virDomainGetOSType		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Get the type of domain operation system.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>the new string or NULL in case of error, the string must be freed by the caller.</dd></dl><div class="acl"></div><h3><a name="virDomainGetSchedulerParameters" id="virDomainGetSchedulerParameters"><code>virDomainGetSchedulerParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetSchedulerParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int *</span> nparams)</pre><div class="description"><p>Get all scheduler parameters. On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value. @nparams cannot be 0.</p><p>It is hypervisor specific whether this returns the live or persistent state; for more control, use <a href="libvirt-libvirt.html#virDomainGetSchedulerParametersFlags">virDomainGetSchedulerParametersFlags</a>().</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to scheduler parameter objects (return value)</dd><dt>nparams</dt><dd>pointer to number of scheduler parameter objects (this value should generally be as large as the returned value nparams of <a href="libvirt-libvirt.html#virDomainGetSchedulerType">virDomainGetSchedulerType</a>()); input and output</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainGetSchedulerParametersFlags" id="virDomainGetSchedulerParametersFlags"><code>virDomainGetSchedulerParametersFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetSchedulerParametersFlags	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
						 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
						 <span class="type">int *</span> nparams,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get all scheduler parameters. On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value. @nparams cannot be 0.</p><p>The value of @flags can be exactly <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>, <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a>, or <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a>.</p><p>Here is a sample code snippet:</p><p>char *ret = virDomainGetSchedulerType(dom, &amp;nparams); if (ret &amp;&amp; nparams != 0) { if ((params = malloc(sizeof(*params) * nparams)) == NULL) goto error; memset(params, 0, sizeof(*params) * nparams); if (virDomainGetSchedulerParametersFlags(dom, params, &amp;nparams, 0)) goto error; }</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to scheduler parameter object (return value)</dd><dt>nparams</dt><dd>pointer to number of scheduler parameter (this value should be same than the returned value nparams of <a href="libvirt-libvirt.html#virDomainGetSchedulerType">virDomainGetSchedulerType</a>()); input and output</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt.html#virTypedParameterFlags">virTypedParameterFlags</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainGetSchedulerType" id="virDomainGetSchedulerType"><code>virDomainGetSchedulerType</code></a></h3><pre class="api"><span class="type">char *</span>	virDomainGetSchedulerType	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int *</span> nparams)</pre><div class="description"><p>Get the scheduler type and the number of scheduler parameters.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>nparams</dt><dd>pointer to number of scheduler parameters, can be NULL (return value)</dd><dt>Returns</dt><dd>NULL in case of error. The caller must free the returned string.</dd></dl><div class="acl"></div><h3><a name="virDomainGetSecurityLabel" id="virDomainGetSecurityLabel"><code>virDomainGetSecurityLabel</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetSecurityLabel	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a></span> seclabel)</pre><div class="description"><p>Extract security label of an active domain. The 'label' field in the @seclabel argument will be initialized to the empty string if the domain is not running under a security model.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>seclabel</dt><dd>pointer to a <a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> structure</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure</dd></dl><div class="acl"></div><h3><a name="virDomainGetSecurityLabelList" id="virDomainGetSecurityLabelList"><code>virDomainGetSecurityLabelList</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetSecurityLabelList	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> *</span> seclabels)</pre><div class="description"><p>Extract the security labels of an active domain. The 'label' field in the @seclabels argument will be initialized to the empty string if the domain is not running under a security model.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>seclabels</dt><dd>will be auto-allocated and filled with domains' security labels. Caller must free memory on return.</dd><dt>Returns</dt><dd>number of elemnets in @seclabels on success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetState" id="virDomainGetState"><code>virDomainGetState</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetState		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int *</span> state,
					 <span class="type">int *</span> reason,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Extract domain state. Each state can be accompanied with a reason (if known) which led to the state.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>state</dt><dd>returned state of the domain (one of <a href="libvirt-libvirt.html#virDomainState">virDomainState</a>)</dd><dt>reason</dt><dd>returned reason which led to @state (one of virDomain*Reason corresponding to the current state); it is allowed to be NULL</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetUUID" id="virDomainGetUUID"><code>virDomainGetUUID</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetUUID		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned char *</span> uuid)</pre><div class="description"><p>Get the UUID for a domain</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>uuid</dt><dd>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virDomainGetUUIDString" id="virDomainGetUUIDString"><code>virDomainGetUUIDString</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetUUIDString		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">char *</span> buf)</pre><div class="description"><p>Get the UUID for a domain as string. For more information about UUID see RFC4122.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>buf</dt><dd>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virDomainGetVcpuPinInfo" id="virDomainGetVcpuPinInfo"><code>virDomainGetVcpuPinInfo</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetVcpuPinInfo		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int</span> ncpumaps,
					 <span class="type">unsigned char *</span> cpumaps,
					 <span class="type">int</span> maplen,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Query the CPU affinity setting of all virtual CPUs of domain, store it in cpumaps.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>ncpumaps</dt><dd>the number of cpumap (listed first to match <a href="libvirt-libvirt.html#virDomainGetVcpus">virDomainGetVcpus</a>)</dd><dt>cpumaps</dt><dd>pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) It's assumed there is &lt;ncpumaps&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (ncpumaps * maplen) bytes (ie: calloc(ncpumaps, maplen)). One cpumap inside cpumaps has the format described in <a href="libvirt-libvirt.html#virDomainPinVcpu">virDomainPinVcpu</a>() API. Must not be NULL.</dd><dt>maplen</dt><dd>the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive.</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a> Must not be <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> concurrently.</dd><dt>Returns</dt><dd>the number of virtual CPUs in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetVcpus" id="virDomainGetVcpus"><code>virDomainGetVcpus</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetVcpus		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virVcpuInfoPtr">virVcpuInfoPtr</a></span> info,
					 <span class="type">int</span> maxinfo,
					 <span class="type">unsigned char *</span> cpumaps,
					 <span class="type">int</span> maplen)</pre><div class="description"><p>Extract information about virtual CPUs of domain, store it in info array and also in cpumaps if this pointer isn't NULL. This call may fail on an inactive domain.</p><p>See also <a href="libvirt-libvirt.html#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a> for querying just cpumaps, including on an inactive domain.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>info</dt><dd>pointer to an array of <a href="libvirt-libvirt.html#virVcpuInfo">virVcpuInfo</a> structures (OUT)</dd><dt>maxinfo</dt><dd>number of structures in info array</dd><dt>cpumaps</dt><dd>pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cpumap information is returned by the API. It's assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in <a href="libvirt-libvirt.html#virDomainPinVcpu">virDomainPinVcpu</a>() API.</dd><dt>maplen</dt><dd>number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). Must be zero when cpumaps is NULL and positive when it is non-NULL.</dd><dt>Returns</dt><dd>the number of info filled in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetVcpusFlags" id="virDomainGetVcpusFlags"><code>virDomainGetVcpusFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainGetVcpusFlags		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Query the number of virtual CPUs used by the domain. Note that this call may fail if the underlying virtualization hypervisor does not support it. This function may require privileged access to the hypervisor.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a>, this will query a running domain (which will fail if domain is not active); if it includes <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a>, this will query the XML description of the domain. It is an error to set both flags. If neither flag is set (that is, <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>), then the configuration queried depends on whether the domain is currently running.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_VCPU_MAXIMUM">VIR_DOMAIN_VCPU_MAXIMUM</a>, then the maximum virtual CPU limit is queried. Otherwise, this call queries the current virtual CPU count.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_VCPU_GUEST">VIR_DOMAIN_VCPU_GUEST</a>, then the state of the processors is modified in the guest instead of the hypervisor. This flag is only usable on live domains. Guest agent may be needed for this flag to be available.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainVcpuFlags">virDomainVcpuFlags</a></dd><dt>Returns</dt><dd>the number of vCPUs in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainGetXMLDesc" id="virDomainGetXMLDesc"><code>virDomainGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virDomainGetXMLDesc		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Provide an XML description of the domain. The description may be reused later to relaunch the domain with <a href="libvirt-libvirt.html#virDomainCreateXML">virDomainCreateXML</a>().</p><p>No security-sensitive data will be included unless @flags contains <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_SECURE">VIR_DOMAIN_XML_SECURE</a>; this flag is rejected on read-only connections. If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_INACTIVE">VIR_DOMAIN_XML_INACTIVE</a>, then the XML represents the configuration that will be used on the next boot of a persistent domain; otherwise, the configuration represents the currently running domain. If @flags contains <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_UPDATE_CPU">VIR_DOMAIN_XML_UPDATE_CPU</a>, then the portion of the domain XML describing CPU capabilities is modified to match actual capabilities of the host.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainXMLFlags">virDomainXMLFlags</a></dd><dt>Returns</dt><dd>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virDomainHasCurrentSnapshot" id="virDomainHasCurrentSnapshot"><code>virDomainHasCurrentSnapshot</code></a></h3><pre class="api"><span class="type">int</span>	virDomainHasCurrentSnapshot	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Determine if the domain has a current snapshot.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to the domain object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>1 if such snapshot exists, 0 if it doesn't, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virDomainHasManagedSaveImage" id="virDomainHasManagedSaveImage"><code>virDomainHasManagedSaveImage</code></a></h3><pre class="api"><span class="type">int</span>	virDomainHasManagedSaveImage	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Check if a domain has a managed save image as created by <a href="libvirt-libvirt.html#virDomainManagedSave">virDomainManagedSave</a>(). Note that any running domain should not have such an image, as it should have been removed on restart.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 if no image is present, 1 if an image is present, and -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virDomainInjectNMI" id="virDomainInjectNMI"><code>virDomainInjectNMI</code></a></h3><pre class="api"><span class="type">int</span>	virDomainInjectNMI		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Send NMI to the guest</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainInterfaceStats" id="virDomainInterfaceStats"><code>virDomainInterfaceStats</code></a></h3><pre class="api"><span class="type">int</span>	virDomainInterfaceStats		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> path,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a></span> stats,
					 <span class="type">size_t</span> size)</pre><div class="description"><p>This function returns network interface stats for interfaces attached to the domain.</p><p>The path parameter is the name of the network interface.</p><p>Domains may have more than one network interface. To get stats for each you should make multiple calls to this function.</p><p>Individual fields within the stats structure may be returned as -1, which indicates that the hypervisor does not support that particular statistic.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>path</dt><dd>path to the interface</dd><dt>stats</dt><dd>network interface stats (returned)</dd><dt>size</dt><dd>size of stats structure</dd><dt>Returns</dt><dd>0 in case of success or -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainIsActive" id="virDomainIsActive"><code>virDomainIsActive</code></a></h3><pre class="api"><span class="type">int</span>	virDomainIsActive		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom)</pre><div class="description"><p>Determine if the domain is currently running</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>Returns</dt><dd>1 if running, 0 if inactive, -1 on error</dd></dl><div class="acl"></div><h3><a name="virDomainIsPersistent" id="virDomainIsPersistent"><code>virDomainIsPersistent</code></a></h3><pre class="api"><span class="type">int</span>	virDomainIsPersistent		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom)</pre><div class="description"><p>Determine if the domain has a persistent configuration which means it will still exist after shutting down</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>Returns</dt><dd>1 if persistent, 0 if transient, -1 on error</dd></dl><div class="acl"></div><h3><a name="virDomainIsUpdated" id="virDomainIsUpdated"><code>virDomainIsUpdated</code></a></h3><pre class="api"><span class="type">int</span>	virDomainIsUpdated		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom)</pre><div class="description"><p>Determine if the domain has been updated.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>Returns</dt><dd>1 if updated, 0 if not, -1 on error</dd></dl><div class="acl"></div><h3><a name="virDomainListAllSnapshots" id="virDomainListAllSnapshots"><code>virDomainListAllSnapshots</code></a></h3><pre class="api"><span class="type">int</span>	virDomainListAllSnapshots	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> **</span> snaps,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of domain snapshots for the given domain, and allocate an array to store those objects. This API solves the race inherent in <a href="libvirt-libvirt.html#virDomainSnapshotListNames">virDomainSnapshotListNames</a>().</p><p>By default, this command covers all snapshots; it is also possible to limit things to just snapshots with no parents, when @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ROOTS">VIR_DOMAIN_SNAPSHOT_LIST_ROOTS</a>. Additional filters are provided in groups, where each group contains bits that describe mutually exclusive attributes of a snapshot, and where all bits within a group describe all possible snapshots. Some hypervisors might reject explicit bits from a group where the hypervisor cannot make a distinction. For a group supported by a given hypervisor, the behavior when no bits of a group are set is identical to the behavior when all bits in that group are set. When setting bits from more than one group, it is possible to select an impossible combination, in that case a hypervisor may return either 0 or an error.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES</a>, to filter based on snapshots that have no further children (a leaf snapshot).</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA</a>, for filtering snapshots based on whether they have metadata that would prevent the removal of the last reference to a domain.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE</a>, <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE</a>, and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY</a>, for filtering snapshots based on what domain state is tracked by the snapshot.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL</a>, for filtering snapshots based on whether the snapshot is stored inside the disk images or as additional files.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>snaps</dt><dd>pointer to variable to store the array containing snapshot objects, or NULL if the list is not required (just returns number of snapshots)</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></dd><dt>Returns</dt><dd>the number of domain snapshots found or -1 and sets @snaps to NULL in case of error. On success, the array stored into @snaps is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virDomainSnapshotFree">virDomainSnapshotFree</a>() on each array element, then calling free() on @snaps.</dd></dl><div class="acl"></div><h3><a name="virDomainLookupByID" id="virDomainLookupByID"><code>virDomainLookupByID</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainLookupByID	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">int</span> id)</pre><div class="description"><p>Try to find a domain based on the hypervisor ID number Note that this won't work for inactive domains which have an ID of -1, in that case a lookup based on the Name or UUId need to be done instead.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>id</dt><dd>the domain ID number</dd><dt>Returns</dt><dd>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virDomainLookupByName" id="virDomainLookupByName"><code>virDomainLookupByName</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainLookupByName	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> name)</pre><div class="description"><p>Try to lookup a domain on the given hypervisor based on its name.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>name</dt><dd>name for the domain</dd><dt>Returns</dt><dd>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virDomainLookupByUUID" id="virDomainLookupByUUID"><code>virDomainLookupByUUID</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainLookupByUUID	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const unsigned char *</span> uuid)</pre><div class="description"><p>Try to lookup a domain on the given hypervisor based on its UUID.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>uuid</dt><dd>the raw UUID for the domain</dd><dt>Returns</dt><dd>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virDomainLookupByUUIDString" id="virDomainLookupByUUIDString"><code>virDomainLookupByUUIDString</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainLookupByUUIDString	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> uuidstr)</pre><div class="description"><p>Try to lookup a domain on the given hypervisor based on its UUID.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>uuidstr</dt><dd>the string UUID for the domain</dd><dt>Returns</dt><dd>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virDomainManagedSave" id="virDomainManagedSave"><code>virDomainManagedSave</code></a></h3><pre class="api"><span class="type">int</span>	virDomainManagedSave		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This method will suspend a domain and save its memory contents to a file on disk. After the call, if successful, the domain is not listed as running anymore. The difference from <a href="libvirt-libvirt.html#virDomainSave">virDomainSave</a>() is that libvirt is keeping track of the saved state itself, and will reuse it once the domain is being restarted (automatically or via an explicit libvirt call). As a result any running domain is sure to not have a managed saved image. This also implies that managed save only works on persistent domains, since the domain must still exist in order to use <a href="libvirt-libvirt.html#virDomainCreate">virDomainCreate</a>() to restart it.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_BYPASS_CACHE">VIR_DOMAIN_SAVE_BYPASS_CACHE</a>, then libvirt will attempt to bypass the file system cache while creating the file, or fail if it cannot do so for the given system; this can allow less pressure on file system cache, but also risks slowing saves to NFS.</p><p>Normally, the managed saved state will remember whether the domain was running or paused, and start will resume to the same state. Specifying <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in @flags will override the default saved into the file. These two flags are mutually exclusive.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></dd><dt>Returns</dt><dd>0 in case of success or -1 in case of failure</dd></dl><div class="acl"></div><h3><a name="virDomainManagedSaveRemove" id="virDomainManagedSaveRemove"><code>virDomainManagedSaveRemove</code></a></h3><pre class="api"><span class="type">int</span>	virDomainManagedSaveRemove	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Remove any managed save image for this domain.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, and -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virDomainMemoryPeek" id="virDomainMemoryPeek"><code>virDomainMemoryPeek</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMemoryPeek		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">unsigned long long</span> start,
					 <span class="type">size_t</span> size,
					 <span class="type">void *</span> buffer,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This function allows you to read the contents of a domain's memory.</p><p>The memory which is read is controlled by the 'start', 'size' and 'flags' parameters.</p><p>If 'flags' is <a href="libvirt-libvirt.html#VIR_MEMORY_VIRTUAL">VIR_MEMORY_VIRTUAL</a> then the 'start' and 'size' parameters are interpreted as virtual memory addresses for whichever task happens to be running on the domain at the moment. Although this sounds haphazard it is in fact what you want in order to read Linux kernel state, because it ensures that pointers in the kernel image can be interpreted coherently.</p><p>'buffer' is the return buffer and must be at least 'size' bytes. 'size' may be 0 to test if the call would succeed.</p><p>NB. The remote driver imposes a 64K byte limit on 'size'. For your program to be able to work reliably over a remote connection you should split large requests to &lt;= 65536 bytes. However, with 0.9.13 this RPC limit has been raised to 1M byte. Starting with version 1.0.6 the RPC limit has been raised again. Now large requests up to 16M byte are supported.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>start</dt><dd>start of memory to peek</dd><dt>size</dt><dd>size of memory to peek</dd><dt>buffer</dt><dd>return buffer (must be at least size bytes)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMemoryFlags">virDomainMemoryFlags</a></dd><dt>Returns</dt><dd>0 in case of success or -1 in case of failure. really 64 bits</dd></dl><div class="acl"></div><h3><a name="virDomainMemoryStats" id="virDomainMemoryStats"><code>virDomainMemoryStats</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMemoryStats		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type"><a href="libvirt-libvirt.html#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a></span> stats,
					 <span class="type">unsigned int</span> nr_stats,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This function provides memory statistics for the domain.</p><p>Up to 'nr_stats' elements of 'stats' will be populated with memory statistics from the domain. Only statistics supported by the domain, the driver, and this version of libvirt will be returned.</p><p>Memory Statistics:</p><p><a href="libvirt-libvirt.html#VIR_DOMAIN_MEMORY_STAT_SWAP_IN">VIR_DOMAIN_MEMORY_STAT_SWAP_IN</a>: The total amount of data read from swap space (in kb). <a href="libvirt-libvirt.html#VIR_DOMAIN_MEMORY_STAT_SWAP_OUT">VIR_DOMAIN_MEMORY_STAT_SWAP_OUT</a>: The total amount of memory written out to swap space (in kb). <a href="libvirt-libvirt.html#VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT</a>: The number of page faults that required disk IO to service. <a href="libvirt-libvirt.html#VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT</a>: The number of page faults serviced without disk IO. <a href="libvirt-libvirt.html#VIR_DOMAIN_MEMORY_STAT_UNUSED">VIR_DOMAIN_MEMORY_STAT_UNUSED</a>: The amount of memory which is not being used for any purpose (in kb). <a href="libvirt-libvirt.html#VIR_DOMAIN_MEMORY_STAT_AVAILABLE">VIR_DOMAIN_MEMORY_STAT_AVAILABLE</a>: The total amount of memory available to the domain's OS (in kb). <a href="libvirt-libvirt.html#VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON">VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON</a>: Current balloon value (in kb).</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to the domain object</dd><dt>stats</dt><dd>nr_stats-sized array of stat structures (returned)</dd><dt>nr_stats</dt><dd>number of memory statistics requested</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>The number of stats provided or -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainMigrate" id="virDomainMigrate"><code>virDomainMigrate</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainMigrate	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> dconn,
					 <span class="type">unsigned long</span> flags,
					 <span class="type">const char *</span> dname,
					 <span class="type">const char *</span> uri,
					 <span class="type">unsigned long</span> bandwidth)</pre><div class="description"><p>Migrate the domain object from its current host to the destination host given by dconn (a connection to the destination host).</p><p>Flags may be one of more of the following: <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain on the destination host. <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the domain on the source host. <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side. <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> Migration with non-shared storage with full disk copy <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> Migration with non-shared storage with incremental disk copy <a href="libvirt-libvirt.html#VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> Protect against domain configuration changes during the migration process (set automatically when supported). <a href="libvirt-libvirt.html#VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> Force migration even if it is considered unsafe. <a href="libvirt-libvirt.html#VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> Migrate offline</p><p><a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set. Applications using the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag will probably prefer to invoke <a href="libvirt-libvirt.html#virDomainMigrateToURI">virDomainMigrateToURI</a>, avoiding the need to open connection to the destination host themselves.</p><p>If a hypervisor supports renaming domains during migration, then you may set the dname parameter to the new name (otherwise it keeps the same name). If this is not supported by the hypervisor, dname must be NULL or else you will get an error.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the uri parameter must be a valid libvirt connection URI, by which the source libvirt driver can connect to the destination libvirt. If omitted, the dconn connection object will be queried for its current URI.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the URI parameter takes a hypervisor specific format. The hypervisor capabilities XML includes details of the support URI schemes. If omitted the dconn will be asked for a default URI.</p><p>If you want to copy non-shared storage within migration you can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> as they are mutually exclusive.</p><p>In either case it is typically only necessary to specify a URI if the destination host has multiple interfaces and a specific interface is required to transmit migration data.</p><p>The maximum bandwidth (in MiB/s) that will be used to do migration can be specified with the bandwidth parameter. If set to 0, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if bandwidth is not 0.</p><p>To see which features are supported by the current hypervisor, see <a href="libvirt-libvirt.html#virConnectGetCapabilities">virConnectGetCapabilities</a>, /capabilities/host/migration_features.</p><p>There are many limitations on migration imposed by the underlying technology - for example it may not be possible to migrate between different processors even with the same architecture, or between different types of hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>dconn</dt><dd>destination host (a connection object)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></dd><dt>dname</dt><dd>(optional) rename domain to this at destination</dd><dt>uri</dt><dd>(optional) dest hostname/URI as seen from the source host</dd><dt>bandwidth</dt><dd>(optional) specify migration bandwidth limit in MiB/s</dd><dt>Returns</dt><dd>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</dd></dl><div class="acl"></div><h3><a name="virDomainMigrate2" id="virDomainMigrate2"><code>virDomainMigrate2</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainMigrate2	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> dconn,
					 <span class="type">const char *</span> dxml,
					 <span class="type">unsigned long</span> flags,
					 <span class="type">const char *</span> dname,
					 <span class="type">const char *</span> uri,
					 <span class="type">unsigned long</span> bandwidth)</pre><div class="description"><p>Migrate the domain object from its current host to the destination host given by dconn (a connection to the destination host).</p><p>Flags may be one of more of the following: <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain on the destination host. <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the domain on the source host. <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side. <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> Migration with non-shared storage with full disk copy <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> Migration with non-shared storage with incremental disk copy <a href="libvirt-libvirt.html#VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> Protect against domain configuration changes during the migration process (set automatically when supported). <a href="libvirt-libvirt.html#VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> Force migration even if it is considered unsafe. <a href="libvirt-libvirt.html#VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> Migrate offline</p><p><a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set. Applications using the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag will probably prefer to invoke <a href="libvirt-libvirt.html#virDomainMigrateToURI">virDomainMigrateToURI</a>, avoiding the need to open connection to the destination host themselves.</p><p>If a hypervisor supports renaming domains during migration, then you may set the dname parameter to the new name (otherwise it keeps the same name). If this is not supported by the hypervisor, dname must be NULL or else you will get an error.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the uri parameter must be a valid libvirt connection URI, by which the source libvirt driver can connect to the destination libvirt. If omitted, the dconn connection object will be queried for its current URI.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the URI parameter takes a hypervisor specific format. The hypervisor capabilities XML includes details of the support URI schemes. If omitted the dconn will be asked for a default URI.</p><p>If you want to copy non-shared storage within migration you can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> as they are mutually exclusive.</p><p>In either case it is typically only necessary to specify a URI if the destination host has multiple interfaces and a specific interface is required to transmit migration data.</p><p>The maximum bandwidth (in MiB/s) that will be used to do migration can be specified with the bandwidth parameter. If set to 0, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if bandwidth is not 0.</p><p>To see which features are supported by the current hypervisor, see <a href="libvirt-libvirt.html#virConnectGetCapabilities">virConnectGetCapabilities</a>, /capabilities/host/migration_features.</p><p>There are many limitations on migration imposed by the underlying technology - for example it may not be possible to migrate between different processors even with the same architecture, or between different types of hypervisor.</p><p>If the hypervisor supports it, @dxml can be used to alter host-specific portions of the domain XML that will be used on the destination. For example, it is possible to alter the backing filename that is associated with a disk device, in order to account for naming differences between source and destination in accessing the underlying storage. The migration will fail if @dxml would cause any guest-visible changes. Pass NULL if no changes are needed to the XML between source and destination. @dxml cannot be used to rename the domain during migration (use @dname for that purpose). Domain name in @dxml must match the original domain name.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>dconn</dt><dd>destination host (a connection object)</dd><dt>dxml</dt><dd>(optional) XML config for launching guest on target</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></dd><dt>dname</dt><dd>(optional) rename domain to this at destination</dd><dt>uri</dt><dd>(optional) dest hostname/URI as seen from the source host</dd><dt>bandwidth</dt><dd>(optional) specify migration bandwidth limit in MiB/s</dd><dt>Returns</dt><dd>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</dd></dl><div class="acl"></div><h3><a name="virDomainMigrate3" id="virDomainMigrate3"><code>virDomainMigrate3</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainMigrate3	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> dconn,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">unsigned int</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Migrate the domain object from its current host to the destination host given by dconn (a connection to the destination host).</p><p>See <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a> documentation for description of individual flags.</p><p><a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> and <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> are not supported by this API, use <a href="libvirt-libvirt.html#virDomainMigrateToURI3">virDomainMigrateToURI3</a> instead.</p><p>If you want to copy non-shared storage within migration you can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> as they are mutually exclusive.</p><p>There are many limitations on migration imposed by the underlying technology - for example it may not be possible to migrate between different processors even with the same architecture, or between different types of hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>dconn</dt><dd>destination host (a connection object)</dd><dt>params</dt><dd>(optional) migration parameters</dd><dt>nparams</dt><dd>(optional) number of migration parameters in @params</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></dd><dt>Returns</dt><dd>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</dd></dl><div class="acl"></div><h3><a name="virDomainMigrateGetCompressionCache" id="virDomainMigrateGetCompressionCache"><code>virDomainMigrateGetCompressionCache</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMigrateGetCompressionCache	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
						 <span class="type">unsigned long long *</span> cacheSize,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Gets current size of the cache (in bytes) used for compressing repeatedly transferred memory pages during live migration.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>cacheSize</dt><dd>return value of current size of the cache (in bytes)</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl><div class="acl"></div><h3><a name="virDomainMigrateGetMaxSpeed" id="virDomainMigrateGetMaxSpeed"><code>virDomainMigrateGetMaxSpeed</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMigrateGetMaxSpeed	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned long *</span> bandwidth,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get the current maximum bandwidth (in MiB/s) that will be used if the domain is migrated. Not all hypervisors will support a bandwidth limit.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>bandwidth</dt><dd>return value of current migration bandwidth limit in MiB/s</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl><div class="acl"></div><h3><a name="virDomainMigrateSetCompressionCache" id="virDomainMigrateSetCompressionCache"><code>virDomainMigrateSetCompressionCache</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMigrateSetCompressionCache	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
						 <span class="type">unsigned long long</span> cacheSize,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Sets size of the cache (in bytes) used for compressing repeatedly transferred memory pages during live migration. It's supposed to be called while the domain is being live-migrated as a reaction to migration progress and increasing number of compression cache misses obtained from <a href="libvirt-libvirt.html#virDomainGetJobStats">virDomainGetJobStats</a>.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>cacheSize</dt><dd>size of the cache (in bytes) used for compression</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl><div class="acl"></div><h3><a name="virDomainMigrateSetMaxDowntime" id="virDomainMigrateSetMaxDowntime"><code>virDomainMigrateSetMaxDowntime</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMigrateSetMaxDowntime	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned long long</span> downtime,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Sets maximum tolerable time for which the domain is allowed to be paused at the end of live migration. It's supposed to be called while the domain is being live-migrated as a reaction to migration progress.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>downtime</dt><dd>maximum tolerable downtime for live migration, in milliseconds</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl><div class="acl"></div><h3><a name="virDomainMigrateSetMaxSpeed" id="virDomainMigrateSetMaxSpeed"><code>virDomainMigrateSetMaxSpeed</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMigrateSetMaxSpeed	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned long</span> bandwidth,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>The maximum bandwidth (in MiB/s) that will be used to do migration can be specified with the bandwidth parameter. Not all hypervisors will support a bandwidth cap</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>bandwidth</dt><dd>migration bandwidth limit in MiB/s</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl><div class="acl"></div><h3><a name="virDomainMigrateToURI" id="virDomainMigrateToURI"><code>virDomainMigrateToURI</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMigrateToURI		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> duri,
					 <span class="type">unsigned long</span> flags,
					 <span class="type">const char *</span> dname,
					 <span class="type">unsigned long</span> bandwidth)</pre><div class="description"><p>Migrate the domain object from its current host to the destination host given by duri.</p><p>Flags may be one of more of the following: <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain on the destination host. <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the domain on the source host. <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side. <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> Migration with non-shared storage with full disk copy <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> Migration with non-shared storage with incremental disk copy <a href="libvirt-libvirt.html#VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> Protect against domain configuration changes during the migration process (set automatically when supported). <a href="libvirt-libvirt.html#VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> Force migration even if it is considered unsafe. <a href="libvirt-libvirt.html#VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> Migrate offline</p><p>The operation of this API hinges on the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag. If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the duri parameter takes a hypervisor specific format. The uri_transports element of the hypervisor capabilities XML includes details of the supported URI schemes. Not all hypervisors will support this mode of migration, so if the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is not set, then it may be necessary to use the alternative <a href="libvirt-libvirt.html#virDomainMigrate">virDomainMigrate</a> API providing and explicit <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> for the destination host.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag IS set, the duri parameter must be a valid libvirt connection URI, by which the source libvirt driver can connect to the destination libvirt.</p><p><a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.</p><p>If you want to copy non-shared storage within migration you can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> as they are mutually exclusive.</p><p>If a hypervisor supports renaming domains during migration, the dname parameter specifies the new name for the domain. Setting dname to NULL keeps the domain name the same. If domain renaming is not supported by the hypervisor, dname must be NULL or else an error will be returned.</p><p>The maximum bandwidth (in MiB/s) that will be used to do migration can be specified with the bandwidth parameter. If set to 0, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if bandwidth is not 0.</p><p>To see which features are supported by the current hypervisor, see <a href="libvirt-libvirt.html#virConnectGetCapabilities">virConnectGetCapabilities</a>, /capabilities/host/migration_features.</p><p>There are many limitations on migration imposed by the underlying technology - for example it may not be possible to migrate between different processors even with the same architecture, or between different types of hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>duri</dt><dd>mandatory URI for the destination host</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></dd><dt>dname</dt><dd>(optional) rename domain to this at destination</dd><dt>bandwidth</dt><dd>(optional) specify migration bandwidth limit in MiB/s</dd><dt>Returns</dt><dd>0 if the migration succeeded, -1 upon error.</dd></dl><div class="acl"></div><h3><a name="virDomainMigrateToURI2" id="virDomainMigrateToURI2"><code>virDomainMigrateToURI2</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMigrateToURI2		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> dconnuri,
					 <span class="type">const char *</span> miguri,
					 <span class="type">const char *</span> dxml,
					 <span class="type">unsigned long</span> flags,
					 <span class="type">const char *</span> dname,
					 <span class="type">unsigned long</span> bandwidth)</pre><div class="description"><p>Migrate the domain object from its current host to the destination host given by duri.</p><p>Flags may be one of more of the following: <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain on the destination host. <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the domain on the source host. <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side. <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> Migration with non-shared storage with full disk copy <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> Migration with non-shared storage with incremental disk copy <a href="libvirt-libvirt.html#VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> Protect against domain configuration changes during the migration process (set automatically when supported). <a href="libvirt-libvirt.html#VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> Force migration even if it is considered unsafe. <a href="libvirt-libvirt.html#VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> Migrate offline</p><p>The operation of this API hinges on the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the @dconnuri parameter must be a valid libvirt connection URI, by which the source libvirt driver can connect to the destination libvirt. If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, then @dconnuri must be NULL.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> flag is NOT set, then the @miguri parameter allows specification of a URI to use to initiate the VM migration. It takes a hypervisor specific format. The uri_transports element of the hypervisor capabilities XML includes details of the supported URI schemes.</p><p><a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.</p><p>If you want to copy non-shared storage within migration you can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> as they are mutually exclusive.</p><p>If a hypervisor supports changing the configuration of the guest during migration, the @dxml parameter specifies the new config for the guest. The configuration must include an identical set of virtual devices, to ensure a stable guest ABI across migration. Only parameters related to host side configuration can be changed in the XML. Hypervisors will validate this and refuse to allow migration if the provided XML would cause a change in the guest ABI,</p><p>If a hypervisor supports renaming domains during migration, the dname parameter specifies the new name for the domain. Setting dname to NULL keeps the domain name the same. If domain renaming is not supported by the hypervisor, dname must be NULL or else an error will be returned.</p><p>The maximum bandwidth (in MiB/s) that will be used to do migration can be specified with the bandwidth parameter. If set to 0, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if bandwidth is not 0.</p><p>To see which features are supported by the current hypervisor, see <a href="libvirt-libvirt.html#virConnectGetCapabilities">virConnectGetCapabilities</a>, /capabilities/host/migration_features.</p><p>There are many limitations on migration imposed by the underlying technology - for example it may not be possible to migrate between different processors even with the same architecture, or between different types of hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>dconnuri</dt><dd>(optional) URI for target libvirtd if @flags includes <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a></dd><dt>miguri</dt><dd>(optional) URI for invoking the migration, not if @flags includs <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a></dd><dt>dxml</dt><dd>(optional) XML config for launching guest on target</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></dd><dt>dname</dt><dd>(optional) rename domain to this at destination</dd><dt>bandwidth</dt><dd>(optional) specify migration bandwidth limit in MiB/s</dd><dt>Returns</dt><dd>0 if the migration succeeded, -1 upon error.</dd></dl><div class="acl"></div><h3><a name="virDomainMigrateToURI3" id="virDomainMigrateToURI3"><code>virDomainMigrateToURI3</code></a></h3><pre class="api"><span class="type">int</span>	virDomainMigrateToURI3		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> dconnuri,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">unsigned int</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Migrate the domain object from its current host to the destination host given by URI.</p><p>See <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a> documentation for description of individual flags.</p><p>The operation of this API hinges on the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the @dconnuri parameter must be a valid libvirt connection URI, by which the source libvirt daemon can connect to the destination libvirt.</p><p>If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, then @dconnuri must be NULL and <a href="libvirt-libvirt.html#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a> migration parameter must be filled in with hypervisor specific URI used to initiate the migration. This is called "direct" migration.</p><p><a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.</p><p>If you want to copy non-shared storage within migration you can use either <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> or <a href="libvirt-libvirt.html#VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> as they are mutually exclusive.</p><p>There are many limitations on migration imposed by the underlying technology - for example it may not be possible to migrate between different processors even with the same architecture, or between different types of hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>dconnuri</dt><dd>(optional) URI for target libvirtd if @flags includes <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a></dd><dt>params</dt><dd>(optional) migration parameters</dd><dt>nparams</dt><dd>(optional) number of migration parameters in @params</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMigrateFlags">virDomainMigrateFlags</a></dd><dt>Returns</dt><dd>0 if the migration succeeded, -1 upon error.</dd></dl><div class="acl"></div><h3><a name="virDomainOpenChannel" id="virDomainOpenChannel"><code>virDomainOpenChannel</code></a></h3><pre class="api"><span class="type">int</span>	virDomainOpenChannel		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> name,
					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This opens the host interface associated with a channel device on a guest, if the host interface is supported. If @name is given, it can match either the device alias (e.g. "channel0"), or the virtio target name (e.g. "org.qemu.guest_agent.0"). If @name is omitted, then the first channel is opened. The channel is associated with the passed in @st stream, which should have been opened in non-blocking mode for bi-directional I/O.</p><p>By default, when @flags is 0, the open will fail if libvirt detects that the channel is already in use by another client; passing <a href="libvirt-libvirt.html#VIR_DOMAIN_CHANNEL_FORCE">VIR_DOMAIN_CHANNEL_FORCE</a> will cause libvirt to forcefully remove the other client prior to opening this channel.</p></div><dl class="variablelist"><dt>dom</dt><dd>a domain object</dd><dt>name</dt><dd>the channel name, or NULL</dd><dt>st</dt><dd>a stream to associate with the channel</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainChannelFlags">virDomainChannelFlags</a></dd><dt>Returns</dt><dd>0 if the channel was opened, -1 on error</dd></dl><div class="acl"></div><h3><a name="virDomainOpenConsole" id="virDomainOpenConsole"><code>virDomainOpenConsole</code></a></h3><pre class="api"><span class="type">int</span>	virDomainOpenConsole		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> dev_name,
					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This opens the backend associated with a console, serial or parallel port device on a guest, if the backend is supported. If the @dev_name is omitted, then the first console or serial device is opened. The console is associated with the passed in @st stream, which should have been opened in non-blocking mode for bi-directional I/O.</p><p>By default, when @flags is 0, the open will fail if libvirt detects that the console is already in use by another client; passing <a href="libvirt-libvirt.html#VIR_DOMAIN_CONSOLE_FORCE">VIR_DOMAIN_CONSOLE_FORCE</a> will cause libvirt to forcefully remove the other client prior to opening this console.</p><p>If flag <a href="libvirt-libvirt.html#VIR_DOMAIN_CONSOLE_SAFE">VIR_DOMAIN_CONSOLE_SAFE</a> the console is opened only in the case where the hypervisor driver supports safe (mutually exclusive) console handling.</p><p>Older servers did not support either flag, and also did not forbid simultaneous clients on a console, with potentially confusing results. When passing @flags of 0 in order to support a wider range of server versions, it is up to the client to ensure mutual exclusion.</p></div><dl class="variablelist"><dt>dom</dt><dd>a domain object</dd><dt>dev_name</dt><dd>the console, serial or parallel port device alias, or NULL</dd><dt>st</dt><dd>a stream to associate with the console</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainConsoleFlags">virDomainConsoleFlags</a></dd><dt>Returns</dt><dd>0 if the console was opened, -1 on error</dd></dl><div class="acl"></div><h3><a name="virDomainOpenGraphics" id="virDomainOpenGraphics"><code>virDomainOpenGraphics</code></a></h3><pre class="api"><span class="type">int</span>	virDomainOpenGraphics		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">unsigned int</span> idx,
					 <span class="type">int</span> fd,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This will attempt to connect the file descriptor @fd, to the graphics backend of @dom. If @dom has multiple graphics backends configured, then @idx will determine which one is opened, starting from @idx 0.</p><p>To disable any authentication, pass the <a href="libvirt-libvirt.html#VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH">VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH</a> constant for @flags.</p><p>The caller should use an anonymous socketpair to open @fd before invocation.</p><p>This method can only be used when connected to a local libvirt hypervisor, over a UNIX domain socket. Attempts to use this method over a TCP connection will always fail</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>idx</dt><dd>index of graphics config to open</dd><dt>fd</dt><dd>file descriptor to attach graphics to</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a></dd><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virDomainPMSuspendForDuration" id="virDomainPMSuspendForDuration"><code>virDomainPMSuspendForDuration</code></a></h3><pre class="api"><span class="type">int</span>	virDomainPMSuspendForDuration	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">unsigned int</span> target,
					 <span class="type">unsigned long long</span> duration,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Attempt to have the guest enter the given @target power management suspension level. If @duration is non-zero, also schedule the guest to resume normal operation after that many seconds, if nothing else has resumed it earlier. Some hypervisors require that @duration be 0, for an indefinite suspension.</p><p>Dependent on hypervisor used, this may require a guest agent to be available, e.g. QEMU.</p><p>Beware that at least for QEMU, the domain's process will be terminated when <a href="libvirt-libvirt.html#VIR_NODE_SUSPEND_TARGET_DISK">VIR_NODE_SUSPEND_TARGET_DISK</a> is used and a new process will be launched when libvirt is asked to wake up the domain. As a result of this, any runtime changes, such as device hotplug or memory settings, are lost unless such changes were made with <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> flag.</p></div><dl class="variablelist"><dt>dom</dt><dd>a domain object</dd><dt>target</dt><dd>a value from <a href="libvirt-libvirt.html#virNodeSuspendTarget">virNodeSuspendTarget</a></dd><dt>duration</dt><dd>duration in seconds to suspend, or 0 for indefinite</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 on success, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virDomainPMWakeup" id="virDomainPMWakeup"><code>virDomainPMWakeup</code></a></h3><pre class="api"><span class="type">int</span>	virDomainPMWakeup		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Inject a wakeup into the guest that previously used <a href="libvirt-libvirt.html#virDomainPMSuspendForDuration">virDomainPMSuspendForDuration</a>, rather than waiting for the previously requested duration (if any) to elapse.</p></div><dl class="variablelist"><dt>dom</dt><dd>a domain object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 on success, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virDomainPinEmulator" id="virDomainPinEmulator"><code>virDomainPinEmulator</code></a></h3><pre class="api"><span class="type">int</span>	virDomainPinEmulator		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned char *</span> cpumap,
					 <span class="type">int</span> maplen,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Dynamically change the real CPUs which can be allocated to all emulator threads. This function may require privileged access to the hypervisor.</p><p>@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a>. Both flags may be set. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain and may fail if domain is not alive. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state, and will fail for transient domains. If neither flag is specified (that is, @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>), then an inactive domain modifies persistent setup, while an active domain is hypervisor-dependent on whether just live or both live and persistent state is changed. Not all hypervisors can support all flag combinations.</p><p>See also <a href="libvirt-libvirt.html#virDomainGetEmulatorPinInfo">virDomainGetEmulatorPinInfo</a> for querying this information.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>cpumap</dt><dd>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</dd><dt>maplen</dt><dd>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainPinVcpu" id="virDomainPinVcpu"><code>virDomainPinVcpu</code></a></h3><pre class="api"><span class="type">int</span>	virDomainPinVcpu		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> vcpu,
					 <span class="type">unsigned char *</span> cpumap,
					 <span class="type">int</span> maplen)</pre><div class="description"><p>Dynamically change the real CPUs which can be allocated to a virtual CPU. This function may require privileged access to the hypervisor.</p><p>This command only changes the runtime configuration of the domain, so can only be called on an active domain.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>vcpu</dt><dd>virtual CPU number</dd><dt>cpumap</dt><dd>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</dd><dt>maplen</dt><dd>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainPinVcpuFlags" id="virDomainPinVcpuFlags"><code>virDomainPinVcpuFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainPinVcpuFlags		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> vcpu,
					 <span class="type">unsigned char *</span> cpumap,
					 <span class="type">int</span> maplen,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Dynamically change the real CPUs which can be allocated to a virtual CPU. This function may require privileged access to the hypervisor.</p><p>@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a>. Both flags may be set. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain and may fail if domain is not alive. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state, and will fail for transient domains. If neither flag is specified (that is, @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>), then an inactive domain modifies persistent setup, while an active domain is hypervisor-dependent on whether just live or both live and persistent state is changed. Not all hypervisors can support all flag combinations.</p><p>See also <a href="libvirt-libvirt.html#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a> for querying this information.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>vcpu</dt><dd>virtual CPU number</dd><dt>cpumap</dt><dd>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</dd><dt>maplen</dt><dd>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainReboot" id="virDomainReboot"><code>virDomainReboot</code></a></h3><pre class="api"><span class="type">int</span>	virDomainReboot			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Reboot a domain, the domain object is still usable thereafter, but the domain OS is being stopped for a restart. Note that the guest OS may ignore the request. Additionally, the hypervisor may check and support the domain 'on_reboot' XML setting resulting in a domain that shuts down instead of rebooting.</p><p>If @flags is set to zero, then the hypervisor will choose the method of shutdown it considers best. To have greater control pass one or more of the <a href="libvirt-libvirt.html#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a>. The order in which the hypervisor tries each shutdown method is undefined, and a hypervisor is not required to support all methods.</p><p>To use guest agent (<a href="libvirt-libvirt.html#VIR_DOMAIN_REBOOT_GUEST_AGENT">VIR_DOMAIN_REBOOT_GUEST_AGENT</a>) the domain XML must have &lt;channel&gt; configured.</p><p>Due to implementation limitations in some drivers (the qemu driver, for instance) it is not advised to migrate or save a guest that is rebooting as a result of this API. Migrating such a guest can lead to a plain shutdown on the destination.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainRebootFlagValues">virDomainRebootFlagValues</a></dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainRef" id="virDomainRef"><code>virDomainRef</code></a></h3><pre class="api"><span class="type">int</span>	virDomainRef			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Increment the reference count on the domain. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virDomainFree">virDomainFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using a domain would increment the reference count.</p></div><dl class="variablelist"><dt>domain</dt><dd>the domain to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainReset" id="virDomainReset"><code>virDomainReset</code></a></h3><pre class="api"><span class="type">int</span>	virDomainReset			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Reset a domain immediately without any guest OS shutdown. Reset emulates the power reset button on a machine, where all hardware sees the RST line set and reinitializes internal state.</p><p>Note that there is a risk of data loss caused by reset without any guest OS shutdown.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainRestore" id="virDomainRestore"><code>virDomainRestore</code></a></h3><pre class="api"><span class="type">int</span>	virDomainRestore		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> from)</pre><div class="description"><p>This method will restore a domain saved to disk by <a href="libvirt-libvirt.html#virDomainSave">virDomainSave</a>().</p><p>See <a href="libvirt-libvirt.html#virDomainRestoreFlags">virDomainRestoreFlags</a>() for more control.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>from</dt><dd>path to the input file</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainRestoreFlags" id="virDomainRestoreFlags"><code>virDomainRestoreFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainRestoreFlags		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> from,
					 <span class="type">const char *</span> dxml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This method will restore a domain saved to disk by <a href="libvirt-libvirt.html#virDomainSave">virDomainSave</a>().</p><p>If the hypervisor supports it, @dxml can be used to alter host-specific portions of the domain XML that will be used when restoring an image. For example, it is possible to alter the backing filename that is associated with a disk device, in order to prepare for file renaming done as part of backing up the disk device while the domain is stopped.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_BYPASS_CACHE">VIR_DOMAIN_SAVE_BYPASS_CACHE</a>, then libvirt will attempt to bypass the file system cache while restoring the file, or fail if it cannot do so for the given system; this can allow less pressure on file system cache, but also risks slowing restores from NFS.</p><p>Normally, the saved state file will remember whether the domain was running or paused, and restore defaults to the same state. Specifying <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in @flags will override the default read from the file. These two flags are mutually exclusive.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>from</dt><dd>path to the input file</dd><dt>dxml</dt><dd>(optional) XML config for adjusting guest xml used on restore</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainResume" id="virDomainResume"><code>virDomainResume</code></a></h3><pre class="api"><span class="type">int</span>	virDomainResume			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Resume a suspended domain, the process is restarted from the state where it was frozen by calling <a href="libvirt-libvirt.html#virDomainSuspend">virDomainSuspend</a>(). This function may require privileged access Moreover, resume may not be supported if domain is in some special state like <a href="libvirt-libvirt.html#VIR_DOMAIN_PMSUSPENDED">VIR_DOMAIN_PMSUSPENDED</a>.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainRevertToSnapshot" id="virDomainRevertToSnapshot"><code>virDomainRevertToSnapshot</code></a></h3><pre class="api"><span class="type">int</span>	virDomainRevertToSnapshot	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Revert the domain to a given snapshot.</p><p>Normally, the domain will revert to the same state the domain was in while the snapshot was taken (whether inactive, running, or paused), except that disk snapshots default to reverting to inactive state. Including <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING">VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING</a> in @flags overrides the snapshot state to guarantee a running domain after the revert; or including <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED">VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED</a> in @flags guarantees a paused domain after the revert. These two flags are mutually exclusive. While a persistent domain does not need either flag, it is not possible to revert a transient domain into an inactive state, so transient domains require the use of one of these two flags.</p><p>Reverting to any snapshot discards all configuration changes made since the last snapshot. Additionally, reverting to a snapshot from a running domain is a form of data loss, since it discards whatever is in the guest's RAM at the time. Since the very nature of keeping snapshots implies the intent to roll back state, no additional confirmation is normally required for these lossy effects.</p><p>However, there are two particular situations where reverting will be refused by default, and where @flags must include <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_REVERT_FORCE">VIR_DOMAIN_SNAPSHOT_REVERT_FORCE</a> to acknowledge the risks. 1) Any attempt to revert to a snapshot that lacks the metadata to perform ABI compatibility checks (generally the case for snapshots that lack a full &lt;domain&gt; when listed by <a href="libvirt-libvirt.html#virDomainSnapshotGetXMLDesc">virDomainSnapshotGetXMLDesc</a>(), such as those created prior to libvirt 0.9.5). 2) Any attempt to revert a running domain to an active state that requires starting a new hypervisor instance rather than reusing the existing hypervisor (since this would terminate all connections to the domain, such as such as VNC or Spice graphics) - this condition arises from active snapshots that are provably ABI incomaptible, as well as from inactive snapshots with a @flags request to start the domain after the revert.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a domain snapshot object</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSnapshotRevertFlags">virDomainSnapshotRevertFlags</a></dd><dt>Returns</dt><dd>0 if the creation is successful, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virDomainSave" id="virDomainSave"><code>virDomainSave</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSave			(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> to)</pre><div class="description"><p>This method will suspend a domain and save its memory contents to a file on disk. After the call, if successful, the domain is not listed as running anymore (this ends the life of a transient domain). Use <a href="libvirt-libvirt.html#virDomainRestore">virDomainRestore</a>() to restore a domain after saving.</p><p>See <a href="libvirt-libvirt.html#virDomainSaveFlags">virDomainSaveFlags</a>() for more control. Also, a save file can be inspected or modified slightly with <a href="libvirt-libvirt.html#virDomainSaveImageGetXMLDesc">virDomainSaveImageGetXMLDesc</a>() and <a href="libvirt-libvirt.html#virDomainSaveImageDefineXML">virDomainSaveImageDefineXML</a>().</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>to</dt><dd>path for the output file</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSaveFlags" id="virDomainSaveFlags"><code>virDomainSaveFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSaveFlags		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> to,
					 <span class="type">const char *</span> dxml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This method will suspend a domain and save its memory contents to a file on disk. After the call, if successful, the domain is not listed as running anymore (this ends the life of a transient domain). Use <a href="libvirt-libvirt.html#virDomainRestore">virDomainRestore</a>() to restore a domain after saving.</p><p>If the hypervisor supports it, @dxml can be used to alter host-specific portions of the domain XML that will be used when restoring an image. For example, it is possible to alter the backing filename that is associated with a disk device, in order to prepare for file renaming done as part of backing up the disk device while the domain is stopped.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_BYPASS_CACHE">VIR_DOMAIN_SAVE_BYPASS_CACHE</a>, then libvirt will attempt to bypass the file system cache while creating the file, or fail if it cannot do so for the given system; this can allow less pressure on file system cache, but also risks slowing saves to NFS.</p><p>Normally, the saved state file will remember whether the domain was running or paused, and restore defaults to the same state. Specifying <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in @flags will override what state gets saved into the file. These two flags are mutually exclusive.</p><p>A save file can be inspected or modified slightly with <a href="libvirt-libvirt.html#virDomainSaveImageGetXMLDesc">virDomainSaveImageGetXMLDesc</a>() and <a href="libvirt-libvirt.html#virDomainSaveImageDefineXML">virDomainSaveImageDefineXML</a>().</p><p>Some hypervisors may prevent this operation if there is a current block copy operation; in that case, use <a href="libvirt-libvirt.html#virDomainBlockJobAbort">virDomainBlockJobAbort</a>() to stop the block copy first.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>to</dt><dd>path for the output file</dd><dt>dxml</dt><dd>(optional) XML config for adjusting guest xml used on restore</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSaveImageDefineXML" id="virDomainSaveImageDefineXML"><code>virDomainSaveImageDefineXML</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSaveImageDefineXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> file,
					 <span class="type">const char *</span> dxml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This updates the definition of a domain stored in a saved state file. @file must be a file created previously by <a href="libvirt-libvirt.html#virDomainSave">virDomainSave</a>() or <a href="libvirt-libvirt.html#virDomainSaveFlags">virDomainSaveFlags</a>().</p><p>@dxml can be used to alter host-specific portions of the domain XML that will be used when restoring an image. For example, it is possible to alter the backing filename that is associated with a disk device, to match renaming done as part of backing up the disk device while the domain is stopped.</p><p>Normally, the saved state file will remember whether the domain was running or paused, and restore defaults to the same state. Specifying <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in @flags will override the default saved into the file; omitting both leaves the file's default unchanged. These two flags are mutually exclusive.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>file</dt><dd>path to saved state file</dd><dt>dxml</dt><dd>XML config for adjusting guest xml used on restore</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSaveImageGetXMLDesc" id="virDomainSaveImageGetXMLDesc"><code>virDomainSaveImageGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virDomainSaveImageGetXMLDesc	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> file,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This method will extract the XML describing the domain at the time a saved state file was created. @file must be a file created previously by <a href="libvirt-libvirt.html#virDomainSave">virDomainSave</a>() or <a href="libvirt-libvirt.html#virDomainSaveFlags">virDomainSaveFlags</a>().</p><p>No security-sensitive data will be included unless @flags contains <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_SECURE">VIR_DOMAIN_XML_SECURE</a>; this flag is rejected on read-only connections. For this API, @flags should not contain either <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_INACTIVE">VIR_DOMAIN_XML_INACTIVE</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_UPDATE_CPU">VIR_DOMAIN_XML_UPDATE_CPU</a>.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>file</dt><dd>path to saved state file</dd><dt>flags</dt><dd>bitwise-OR of subset of <a href="libvirt-libvirt.html#virDomainXMLFlags">virDomainXMLFlags</a></dd><dt>Returns</dt><dd>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virDomainScreenshot" id="virDomainScreenshot"><code>virDomainScreenshot</code></a></h3><pre class="api"><span class="type">char *</span>	virDomainScreenshot		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">unsigned int</span> screen,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Take a screenshot of current domain console as a stream. The image format is hypervisor specific. Moreover, some hypervisors supports multiple displays per domain. These can be distinguished by @screen argument.</p><p>This call sets up a stream; subsequent use of stream API is necessary to transfer actual data, determine how much data is successfully transferred, and detect any errors.</p><p>The screen ID is the sequential number of screen. In case of multiple graphics cards, heads are enumerated before devices, e.g. having two graphics cards, both with four heads, screen ID 5 addresses the second head on the second card.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>stream</dt><dd>stream to use as output</dd><dt>screen</dt><dd>monitor ID to take screenshot from</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a string representing the mime-type of the image format, or NULL upon error. The caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virDomainSendKey" id="virDomainSendKey"><code>virDomainSendKey</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSendKey		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> codeset,
					 <span class="type">unsigned int</span> holdtime,
					 <span class="type">unsigned int *</span> keycodes,
					 <span class="type">int</span> nkeycodes,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Send key(s) to the guest.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>codeset</dt><dd>the code set of keycodes, from <a href="libvirt-libvirt.html#virKeycodeSet">virKeycodeSet</a></dd><dt>holdtime</dt><dd>the duration (in milliseconds) that the keys will be held</dd><dt>keycodes</dt><dd>array of keycodes</dd><dt>nkeycodes</dt><dd>number of keycodes, up to <a href="libvirt-libvirt.html#VIR_DOMAIN_SEND_KEY_MAX_KEYS">VIR_DOMAIN_SEND_KEY_MAX_KEYS</a></dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSendProcessSignal" id="virDomainSendProcessSignal"><code>virDomainSendProcessSignal</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSendProcessSignal	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">long long</span> pid_value,
					 <span class="type">unsigned int</span> signum,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Send a signal to the designated process in the guest</p><p>The signal numbers must be taken from the <a href="libvirt-libvirt.html#virDomainProcessSignal">virDomainProcessSignal</a> enum. These will be translated to the corresponding signal number for the guest OS, by the guest agent delivering the signal. If there is no mapping from <a href="libvirt-libvirt.html#virDomainProcessSignal">virDomainProcessSignal</a> to the native OS signals, this API will report an error.</p><p>If @pid_value is an integer greater than zero, it is treated as a process ID. If @pid_value is an integer less than zero, it is treated as a process group ID. All the @pid_value numbers are from the container/guest namespace. The value zero is not valid.</p><p>Not all hypervisors will support sending signals to arbitrary processes or process groups. If this API is implemented the minimum requirement is to be able to use @pid_value==1 (i.e. kill init). No other value is required to be supported.</p><p>If the @signum is <a href="libvirt-libvirt.html#VIR_DOMAIN_PROCESS_SIGNAL_NOP">VIR_DOMAIN_PROCESS_SIGNAL_NOP</a> then this API will simply report whether the process is running in the container/guest.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>pid_value</dt><dd>a positive integer process ID, or negative integer process group ID</dd><dt>signum</dt><dd>a signal from the <a href="libvirt-libvirt.html#virDomainProcessSignal">virDomainProcessSignal</a> enum</dd><dt>flags</dt><dd>one of the virDomainProcessSignalFlag values</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSetAutostart" id="virDomainSetAutostart"><code>virDomainSetAutostart</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetAutostart		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int</span> autostart)</pre><div class="description"><p>Configure the domain to be automatically started when the host machine boots.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>autostart</dt><dd>whether the domain should be automatically started 0 or 1</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virDomainSetBlkioParameters" id="virDomainSetBlkioParameters"><code>virDomainSetBlkioParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetBlkioParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Change all or a subset of the blkio tunables. This function may require privileged access to the hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to blkio parameter objects</dd><dt>nparams</dt><dd>number of blkio parameters (this value can be the same or less than the number of parameters supported)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainSetBlockIoTune" id="virDomainSetBlockIoTune"><code>virDomainSetBlockIoTune</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetBlockIoTune		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> dom,
					 <span class="type">const char *</span> disk,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Change all or a subset of the per-device block IO tunables.</p><p>The @disk parameter is either an unambiguous source name of the block device (the &lt;source file='...'/&gt; sub-element, such as "/path/to/image"), or the device target shorthand (the &lt;target dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and inspecting elements within //domain/devices/disk.</p></div><dl class="variablelist"><dt>dom</dt><dd>pointer to domain object</dd><dt>disk</dt><dd>path to the block device, or device shorthand</dd><dt>params</dt><dd>Pointer to blkio parameter objects</dd><dt>nparams</dt><dd>Number of blkio parameters (this value can be the same or less than the number of parameters supported)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainSetInterfaceParameters" id="virDomainSetInterfaceParameters"><code>virDomainSetInterfaceParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetInterfaceParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> device,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Change a subset or all parameters of interface; currently this includes bandwidth parameters. The value of @flags should be either <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>, or a bitwise-or of values <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a>, although hypervisors vary in which flags are supported.</p><p>This function may require privileged access to the hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>device</dt><dd>the interface name or mac address</dd><dt>params</dt><dd>pointer to interface parameter objects</dd><dt>nparams</dt><dd>number of interface parameter (this value can be the same or less than the number of parameters supported)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainSetMaxMemory" id="virDomainSetMaxMemory"><code>virDomainSetMaxMemory</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetMaxMemory		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned long</span> memory)</pre><div class="description"><p>Dynamically change the maximum amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function may require privileged access to the hypervisor.</p><p>This command is hypervisor-specific for whether active, persistent, or both configurations are changed; for more control, use <a href="libvirt-libvirt.html#virDomainSetMemoryFlags">virDomainSetMemoryFlags</a>().</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object or NULL</dd><dt>memory</dt><dd>the memory size in kibibytes (blocks of 1024 bytes)</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSetMemory" id="virDomainSetMemory"><code>virDomainSetMemory</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetMemory		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned long</span> memory)</pre><div class="description"><p>Dynamically change the target amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function may require privileged access to the hypervisor.</p><p>This command only changes the runtime configuration of the domain, so can only be called on an active domain.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object or NULL</dd><dt>memory</dt><dd>the memory size in kibibytes (blocks of 1024 bytes)</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSetMemoryFlags" id="virDomainSetMemoryFlags"><code>virDomainSetMemoryFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetMemoryFlags		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned long</span> memory,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Dynamically change the target amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function may require privileged access to the hypervisor.</p><p>@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a>. Both flags may be set. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain and will fail if domain is not active. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state, and will fail for transient domains. If neither flag is specified (that is, @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>), then an inactive domain modifies persistent setup, while an active domain is hypervisor-dependent on whether just live or both live and persistent state is changed. If <a href="libvirt-libvirt.html#VIR_DOMAIN_MEM_MAXIMUM">VIR_DOMAIN_MEM_MAXIMUM</a> is set, the change affects domain's maximum memory size rather than current memory size. Not all hypervisors can support all flag combinations.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object or NULL</dd><dt>memory</dt><dd>the memory size in kibibytes (blocks of 1024 bytes)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMemoryModFlags">virDomainMemoryModFlags</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSetMemoryParameters" id="virDomainSetMemoryParameters"><code>virDomainSetMemoryParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetMemoryParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Change all or a subset of the memory tunables. This function may require privileged access to the hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to memory parameter objects</dd><dt>nparams</dt><dd>number of memory parameter (this value can be the same or less than the number of parameters supported)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainSetMemoryStatsPeriod" id="virDomainSetMemoryStatsPeriod"><code>virDomainSetMemoryStatsPeriod</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetMemoryStatsPeriod	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int</span> period,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Dynamically change the domain memory balloon driver statistics collection period. Use 0 to disable and a positive value to enable.</p><p>@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a>. Both flags may be set. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain and will fail if domain is not active. If <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state, and will fail for transient domains. If neither flag is specified (that is, @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>), then an inactive domain modifies persistent setup, while an active domain is hypervisor-dependent on whether just live or both live and persistent state is changed.</p><p>Not all hypervisors can support all flag combinations.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object or NULL</dd><dt>period</dt><dd>the period in seconds for stats collection</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainMemoryModFlags">virDomainMemoryModFlags</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSetMetadata" id="virDomainSetMetadata"><code>virDomainSetMetadata</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetMetadata		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">int</span> type,
					 <span class="type">const char *</span> metadata,
					 <span class="type">const char *</span> key,
					 <span class="type">const char *</span> uri,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Sets the appropriate domain element given by @type to the value of @description. A @type of <a href="libvirt-libvirt.html#VIR_DOMAIN_METADATA_DESCRIPTION">VIR_DOMAIN_METADATA_DESCRIPTION</a> is free-form text; <a href="libvirt-libvirt.html#VIR_DOMAIN_METADATA_TITLE">VIR_DOMAIN_METADATA_TITLE</a> is free-form, but no newlines are permitted, and should be short (although the length is not enforced). For these two options @key and @uri are irrelevant and must be set to NULL.</p><p>For type <a href="libvirt-libvirt.html#VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a> @metadata must be well-formed XML belonging to namespace defined by @uri with local name @key.</p><p>Passing NULL for @metadata says to remove that element from the domain XML (passing the empty string leaves the element present).</p><p>The resulting metadata will be present in <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>(), as well as quick access through <a href="libvirt-libvirt.html#virDomainGetMetadata">virDomainGetMetadata</a>().</p><p>@flags controls whether the live domain, persistent configuration, or both will be modified.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>type</dt><dd>type of description, from <a href="libvirt-libvirt.html#virDomainMetadataType">virDomainMetadataType</a></dd><dt>metadata</dt><dd>new metadata text</dd><dt>key</dt><dd>XML namespace key, or NULL</dd><dt>uri</dt><dd>XML namespace URI, or NULL</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>0 on success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSetNumaParameters" id="virDomainSetNumaParameters"><code>virDomainSetNumaParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetNumaParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Change all or a subset of the numa tunables. This function may require privileged access to the hypervisor.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to numa parameter objects</dd><dt>nparams</dt><dd>number of numa parameters (this value can be the same or less than the number of parameters supported)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainSetSchedulerParameters" id="virDomainSetSchedulerParameters"><code>virDomainSetSchedulerParameters</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetSchedulerParameters	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams)</pre><div class="description"><p>Change all or a subset or the scheduler parameters. It is hypervisor-specific whether this sets live, persistent, or both settings; for more control, use <a href="libvirt-libvirt.html#virDomainSetSchedulerParametersFlags">virDomainSetSchedulerParametersFlags</a>.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to scheduler parameter objects</dd><dt>nparams</dt><dd>number of scheduler parameter objects (this value can be the same or less than the returned value nparams of <a href="libvirt-libvirt.html#virDomainGetSchedulerType">virDomainGetSchedulerType</a>)</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainSetSchedulerParametersFlags" id="virDomainSetSchedulerParametersFlags"><code>virDomainSetSchedulerParametersFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetSchedulerParametersFlags	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
						 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
						 <span class="type">int</span> nparams,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Change a subset or all scheduler parameters. The value of @flags should be either <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>, or a bitwise-or of values from <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>, although hypervisors vary in which flags are supported.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>params</dt><dd>pointer to scheduler parameter objects</dd><dt>nparams</dt><dd>number of scheduler parameter objects (this value can be the same or less than the returned value nparams of <a href="libvirt-libvirt.html#virDomainGetSchedulerType">virDomainGetSchedulerType</a>)</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainModificationImpact">virDomainModificationImpact</a></dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virDomainSetVcpus" id="virDomainSetVcpus"><code>virDomainSetVcpus</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetVcpus		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> nvcpus)</pre><div class="description"><p>Dynamically change the number of virtual CPUs used by the domain. Note that this call may fail if the underlying virtualization hypervisor does not support it or if growing the number is arbitrary limited. This function may require privileged access to the hypervisor.</p><p>This command only changes the runtime configuration of the domain, so can only be called on an active domain. It is hypervisor-dependent whether it also affects persistent configuration; for more control, use <a href="libvirt-libvirt.html#virDomainSetVcpusFlags">virDomainSetVcpusFlags</a>().</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>nvcpus</dt><dd>the new number of virtual CPUs for this domain</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSetVcpusFlags" id="virDomainSetVcpusFlags"><code>virDomainSetVcpusFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSetVcpusFlags		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> nvcpus,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Dynamically change the number of virtual CPUs used by the domain. Note that this call may fail if the underlying virtualization hypervisor does not support it or if growing the number is arbitrary limited. This function may require privileged access to the hypervisor.</p><p>@flags may include <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> to affect a running domain (which may fail if domain is not active), or <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> to affect the next boot via the XML description of the domain. Both flags may be set. If neither flag is specified (that is, @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a>), then an inactive domain modifies persistent setup, while an active domain is hypervisor-dependent on whether just live or both live and persistent state is changed.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_VCPU_MAXIMUM">VIR_DOMAIN_VCPU_MAXIMUM</a>, then <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> must be clear, and only the maximum virtual CPU limit is altered; generally, this value must be less than or equal to <a href="libvirt-libvirt.html#virConnectGetMaxVcpus">virConnectGetMaxVcpus</a>(). Otherwise, this call affects the current virtual CPU limit, which must be less than or equal to the maximum limit.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_VCPU_GUEST">VIR_DOMAIN_VCPU_GUEST</a>, then the state of processors is modified inside the guest instead of the hypervisor. This flag can only be used with live guests and is incompatible with <a href="libvirt-libvirt.html#VIR_DOMAIN_VCPU_MAXIMUM">VIR_DOMAIN_VCPU_MAXIMUM</a>. The usage of this flag may require a guest agent configured.</p><p>Not all hypervisors can support all flag combinations.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object, or NULL for Domain0</dd><dt>nvcpus</dt><dd>the new number of virtual CPUs for this domain, must be at least 1</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainVcpuFlags">virDomainVcpuFlags</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainShutdown" id="virDomainShutdown"><code>virDomainShutdown</code></a></h3><pre class="api"><span class="type">int</span>	virDomainShutdown		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Shutdown a domain, the domain object is still usable thereafter, but the domain OS is being stopped. Note that the guest OS may ignore the request. Additionally, the hypervisor may check and support the domain 'on_poweroff' XML setting resulting in a domain that reboots instead of shutting down. For guests that react to a shutdown request, the differences from <a href="libvirt-libvirt.html#virDomainDestroy">virDomainDestroy</a>() are that the guests disk storage will be in a stable state rather than having the (virtual) power cord pulled, and this command returns as soon as the shutdown request is issued rather than blocking until the guest is no longer running.</p><p>If the domain is transient and has any snapshot metadata (see <a href="libvirt-libvirt.html#virDomainSnapshotNum">virDomainSnapshotNum</a>()), then that metadata will automatically be deleted when the domain quits.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainShutdownFlags" id="virDomainShutdownFlags"><code>virDomainShutdownFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainShutdownFlags		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Shutdown a domain, the domain object is still usable thereafter but the domain OS is being stopped. Note that the guest OS may ignore the request. Additionally, the hypervisor may check and support the domain 'on_poweroff' XML setting resulting in a domain that reboots instead of shutting down. For guests that react to a shutdown request, the differences from <a href="libvirt-libvirt.html#virDomainDestroy">virDomainDestroy</a>() are that the guest's disk storage will be in a stable state rather than having the (virtual) power cord pulled, and this command returns as soon as the shutdown request is issued rather than blocking until the guest is no longer running.</p><p>If the domain is transient and has any snapshot metadata (see <a href="libvirt-libvirt.html#virDomainSnapshotNum">virDomainSnapshotNum</a>()), then that metadata will automatically be deleted when the domain quits.</p><p>If @flags is set to zero, then the hypervisor will choose the method of shutdown it considers best. To have greater control pass one or more of the <a href="libvirt-libvirt.html#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a>. The order in which the hypervisor tries each shutdown method is undefined, and a hypervisor is not required to support all methods.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a></dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotCreateXML" id="virDomainSnapshotCreateXML"><code>virDomainSnapshotCreateXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span>	virDomainSnapshotCreateXML	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
							 <span class="type">const char *</span> xmlDesc,
							 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Creates a new snapshot of a domain based on the snapshot xml contained in xmlDesc.</p><p>If @flags is 0, the domain can be active, in which case the snapshot will be a system checkpoint (both disk state and runtime VM state such as RAM contents), where reverting to the snapshot is the same as resuming from hibernation (TCP connections may have timed out, but everything else picks up where it left off); or the domain can be inactive, in which case the snapshot includes just the disk state prior to booting. The newly created snapshot becomes current (see <a href="libvirt-libvirt.html#virDomainSnapshotCurrent">virDomainSnapshotCurrent</a>()), and is a child of any previous current snapshot.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE">VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE</a>, then this is a request to reinstate snapshot metadata that was previously discarded, rather than creating a new snapshot. This can be used to recreate a snapshot hierarchy on a destination, then remove it on the source, in order to allow migration (since migration normally fails if snapshot metadata still remains on the source machine). When redefining snapshot metadata, the current snapshot will not be altered unless the <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT">VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT</a> flag is also present. It is an error to request the <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT">VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT</a> flag without <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE">VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE</a>. On some hypervisors, redefining an existing snapshot can be used to alter host-specific portions of the domain XML to be used during revert (such as backing filenames associated with disk devices), but must not alter guest-visible layout. When redefining a snapshot name that does not exist, the hypervisor may validate that reverting to the snapshot appears to be possible (for example, disk images have snapshot contents by the requested name). Not all hypervisors support these flags.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA">VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA</a>, then the domain's disk images are modified according to @xmlDesc, but then the just-created snapshot has its metadata deleted. This flag is incompatible with <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE">VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE</a>.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_HALT">VIR_DOMAIN_SNAPSHOT_CREATE_HALT</a>, then the domain will be inactive after the snapshot completes, regardless of whether it was active before; otherwise, a running domain will still be running after the snapshot. This flag is invalid on transient domains, and is incompatible with <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE">VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE</a>.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_LIVE">VIR_DOMAIN_SNAPSHOT_CREATE_LIVE</a>, then the domain is not paused while creating the snapshot. This increases the size of the memory dump file, but reduces downtime of the guest while taking the snapshot. Some hypervisors only support this flag during external checkpoints.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY</a>, then the snapshot will be limited to the disks described in @xmlDesc, and no VM state will be saved. For an active guest, the disk image may be inconsistent (as if power had been pulled), and specifying this with the <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_HALT">VIR_DOMAIN_SNAPSHOT_CREATE_HALT</a> flag risks data loss.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE">VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE</a>, then the libvirt will attempt to use guest agent to freeze and thaw all file systems in use within domain OS. However, if the guest agent is not present, an error is thrown. Moreover, this flag requires <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY</a> to be passed as well.</p><p>By default, if the snapshot involves external files, and any of the destination files already exist as a non-empty regular file, the snapshot is rejected to avoid losing contents of those files. However, if @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT">VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT</a>, then the destination files must already exist and contain content identical to the source files (this allows a management app to pre-create files with relative backing file names, rather than the default of creating with absolute backing file names).</p><p>Be aware that although libvirt prefers to report errors up front with no other effect, some hypervisors have certain types of failures where the overall command can easily fail even though the guest configuration was partially altered (for example, if a disk snapshot request for two disks fails on the second disk, but the first disk alteration cannot be rolled back). If this API call fails, it is therefore normally necessary to follow up with <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a>() and check each disk to determine if any partial changes occurred. However, if @flags contains <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC">VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC</a>, then libvirt guarantees that this command will not alter any disks unless the entire set of changes can be done atomically, making failure recovery simpler (note that it is still possible to fail after disks have changed, but only in the much rarer cases of running out of memory or disk space).</p><p>Some hypervisors may prevent this operation if there is a current block copy operation; in that case, use <a href="libvirt-libvirt.html#virDomainBlockJobAbort">virDomainBlockJobAbort</a>() to stop the block copy first.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>xmlDesc</dt><dd>string containing an XML description of the domain</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainSnapshotCreateFlags">virDomainSnapshotCreateFlags</a></dd><dt>Returns</dt><dd>an (opaque) <a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> on success, NULL on failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotCurrent" id="virDomainSnapshotCurrent"><code>virDomainSnapshotCurrent</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span>	virDomainSnapshotCurrent	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
							 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get the current snapshot for a domain, if any.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a domain snapshot object or NULL in case of failure. If the current domain snapshot cannot be found, then the <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_SNAPSHOT">VIR_ERR_NO_DOMAIN_SNAPSHOT</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotDelete" id="virDomainSnapshotDelete"><code>virDomainSnapshotDelete</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotDelete		(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Delete the snapshot.</p><p>If @flags is 0, then just this snapshot is deleted, and changes from this snapshot are automatically merged into children snapshots. If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN">VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN</a>, then this snapshot and any descendant snapshots are deleted. If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY">VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY</a>, then any descendant snapshots are deleted, but this snapshot remains. These two flags are mutually exclusive.</p><p>If @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY">VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY</a>, then any snapshot metadata tracked by libvirt is removed while keeping the snapshot contents intact; if a hypervisor does not require any libvirt metadata to track snapshots, then this flag is silently ignored.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a domain snapshot object</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotDeleteFlags">virDomainSnapshotDeleteFlags</a></dd><dt>Returns</dt><dd>0 if the selected snapshot(s) were successfully deleted, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotFree" id="virDomainSnapshotFree"><code>virDomainSnapshotFree</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotFree		(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)</pre><div class="description"><p>Free the domain snapshot object. The snapshot itself is not modified. The data structure is freed and should not be used thereafter.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a domain snapshot object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotGetConnect" id="virDomainSnapshotGetConnect"><code>virDomainSnapshotGetConnect</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virDomainSnapshotGetConnect	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)</pre><div class="description"><p>Provides the connection pointer associated with a snapshot. The reference counter on the connection is not increased by this call.</p><p>WARNING: When writing libvirt bindings in other languages, do not use this function. Instead, store the connection and the snapshot object together.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a snapshot object</dd><dt>Returns</dt><dd>the connection or NULL.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotGetDomain" id="virDomainSnapshotGetDomain"><code>virDomainSnapshotGetDomain</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span>	virDomainSnapshotGetDomain	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)</pre><div class="description"><p>Provides the domain pointer associated with a snapshot. The reference counter on the domain is not increased by this call.</p><p>WARNING: When writing libvirt bindings in other languages, do not use this function. Instead, store the domain and the snapshot object together.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a snapshot object</dd><dt>Returns</dt><dd>the domain or NULL.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotGetName" id="virDomainSnapshotGetName"><code>virDomainSnapshotGetName</code></a></h3><pre class="api"><span class="type">const char *</span>	virDomainSnapshotGetName	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)</pre><div class="description"><p>Get the public name for that snapshot</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a snapshot object</dd><dt>Returns</dt><dd>a pointer to the name or NULL, the string need not be deallocated as its lifetime will be the same as the snapshot object.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotGetParent" id="virDomainSnapshotGetParent"><code>virDomainSnapshotGetParent</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span>	virDomainSnapshotGetParent	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
							 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get the parent snapshot for @snapshot, if any.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a snapshot object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a domain snapshot object or NULL in case of failure. If the given snapshot is a root (no parent), then the <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_SNAPSHOT">VIR_ERR_NO_DOMAIN_SNAPSHOT</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotGetXMLDesc" id="virDomainSnapshotGetXMLDesc"><code>virDomainSnapshotGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virDomainSnapshotGetXMLDesc	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Provide an XML description of the domain snapshot.</p><p>No security-sensitive data will be included unless @flags contains <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_SECURE">VIR_DOMAIN_XML_SECURE</a>; this flag is rejected on read-only connections. For this API, @flags should not contain either <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_INACTIVE">VIR_DOMAIN_XML_INACTIVE</a> or <a href="libvirt-libvirt.html#VIR_DOMAIN_XML_UPDATE_CPU">VIR_DOMAIN_XML_UPDATE_CPU</a>.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a domain snapshot object</dd><dt>flags</dt><dd>bitwise-OR of subset of <a href="libvirt-libvirt.html#virDomainXMLFlags">virDomainXMLFlags</a></dd><dt>Returns</dt><dd>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotHasMetadata" id="virDomainSnapshotHasMetadata"><code>virDomainSnapshotHasMetadata</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotHasMetadata	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Determine if the given snapshot is associated with libvirt metadata that would prevent the deletion of the domain.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a snapshot object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>1 if the snapshot has metadata, 0 if the snapshot exists without help from libvirt, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotIsCurrent" id="virDomainSnapshotIsCurrent"><code>virDomainSnapshotIsCurrent</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotIsCurrent	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Determine if the given snapshot is the domain's current snapshot. See also <a href="libvirt-libvirt.html#virDomainHasCurrentSnapshot">virDomainHasCurrentSnapshot</a>().</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a snapshot object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>1 if current, 0 if not current, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotListAllChildren" id="virDomainSnapshotListAllChildren"><code>virDomainSnapshotListAllChildren</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotListAllChildren	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
						 <span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> **</span> snaps,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of domain snapshots that are children of the given snapshot, and allocate an array to store those objects. This API solves the race inherent in <a href="libvirt-libvirt.html#virDomainSnapshotListChildrenNames">virDomainSnapshotListChildrenNames</a>().</p><p>By default, this command covers only direct children; it is also possible to expand things to cover all descendants, when @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS">VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS</a>. Also, some filters are provided in groups, where each group contains bits that describe mutually exclusive attributes of a snapshot, and where all bits within a group describe all possible snapshots. Some hypervisors might reject explicit bits from a group where the hypervisor cannot make a distinction. For a group supported by a given hypervisor, the behavior when no bits of a group are set is identical to the behavior when all bits in that group are set. When setting bits from more than one group, it is possible to select an impossible combination, in that case a hypervisor may return either 0 or an error.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES</a>, to filter based on snapshots that have no further children (a leaf snapshot).</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA</a>, for filtering snapshots based on whether they have metadata that would prevent the removal of the last reference to a domain.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE</a>, <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE</a>, and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY</a>, for filtering snapshots based on what domain state is tracked by the snapshot.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL</a>, for filtering snapshots based on whether the snapshot is stored inside the disk images or as additional files.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a domain snapshot object</dd><dt>snaps</dt><dd>pointer to variable to store the array containing snapshot objects, or NULL if the list is not required (just returns number of snapshots)</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></dd><dt>Returns</dt><dd>the number of domain snapshots found or -1 and sets @snaps to NULL in case of error. On success, the array stored into @snaps is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virDomainSnapshotFree">virDomainSnapshotFree</a>() on each array element, then calling free() on @snaps.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotListChildrenNames" id="virDomainSnapshotListChildrenNames"><code>virDomainSnapshotListChildrenNames</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotListChildrenNames	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
						 <span class="type">char **</span> names,
						 <span class="type">int</span> nameslen,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of domain snapshots that are children of the given snapshot, and store their names in @names. The value to use for @nameslen can be determined by <a href="libvirt-libvirt.html#virDomainSnapshotNumChildren">virDomainSnapshotNumChildren</a>() with the same @flags.</p><p>By default, this command covers only direct children; it is also possible to expand things to cover all descendants, when @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS">VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS</a>. Also, some filters are provided in groups, where each group contains bits that describe mutually exclusive attributes of a snapshot, and where all bits within a group describe all possible snapshots. Some hypervisors might reject explicit bits from a group where the hypervisor cannot make a distinction. For a group supported by a given hypervisor, the behavior when no bits of a group are set is identical to the behavior when all bits in that group are set. When setting bits from more than one group, it is possible to select an impossible combination, in that case a hypervisor may return either 0 or an error.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES</a>, to filter based on snapshots that have no further children (a leaf snapshot).</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA</a>, for filtering snapshots based on whether they have metadata that would prevent the removal of the last reference to a domain.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE</a>, <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE</a>, and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY</a>, for filtering snapshots based on what domain state is tracked by the snapshot.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL</a>, for filtering snapshots based on whether the snapshot is stored inside the disk images or as additional files.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a domain snapshot object</dd><dt>names</dt><dd>array to collect the list of names of snapshots</dd><dt>nameslen</dt><dd>size of @names</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></dd><dt>Returns</dt><dd>the number of domain snapshots found or -1 in case of error. Note that this command is inherently racy: another connection can define a new snapshot between a call to <a href="libvirt-libvirt.html#virDomainSnapshotNumChildren">virDomainSnapshotNumChildren</a>() and this call. You are only guaranteed that all currently defined snapshots were listed if the return is less than @nameslen. Likewise, you should be prepared for <a href="libvirt-libvirt.html#virDomainSnapshotLookupByName">virDomainSnapshotLookupByName</a>() to fail when converting a name from this call into a snapshot object, if another connection deletes the snapshot in the meantime. For more control over the results, see <a href="libvirt-libvirt.html#virDomainSnapshotListAllChildren">virDomainSnapshotListAllChildren</a>(). Returns the number of domain snapshots found or -1 in case of error. The caller is responsible to call free() for each member of the array.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotListNames" id="virDomainSnapshotListNames"><code>virDomainSnapshotListNames</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotListNames	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">char **</span> names,
					 <span class="type">int</span> nameslen,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of domain snapshots for the given domain, and store their names in @names. The value to use for @nameslen can be determined by <a href="libvirt-libvirt.html#virDomainSnapshotNum">virDomainSnapshotNum</a>() with the same @flags.</p><p>By default, this command covers all snapshots; it is also possible to limit things to just snapshots with no parents, when @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ROOTS">VIR_DOMAIN_SNAPSHOT_LIST_ROOTS</a>. Additional filters are provided in groups, where each group contains bits that describe mutually exclusive attributes of a snapshot, and where all bits within a group describe all possible snapshots. Some hypervisors might reject explicit bits from a group where the hypervisor cannot make a distinction. For a group supported by a given hypervisor, the behavior when no bits of a group are set is identical to the behavior when all bits in that group are set. When setting bits from more than one group, it is possible to select an impossible combination, in that case a hypervisor may return either 0 or an error.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES</a>, to filter based on snapshots that have no further children (a leaf snapshot).</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA</a>, for filtering snapshots based on whether they have metadata that would prevent the removal of the last reference to a domain.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE</a>, <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE</a>, and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY</a>, for filtering snapshots based on what domain state is tracked by the snapshot.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL</a>, for filtering snapshots based on whether the snapshot is stored inside the disk images or as additional files.</p><p>Note that this command is inherently racy: another connection can define a new snapshot between a call to <a href="libvirt-libvirt.html#virDomainSnapshotNum">virDomainSnapshotNum</a>() and this call. You are only guaranteed that all currently defined snapshots were listed if the return is less than @nameslen. Likewise, you should be prepared for <a href="libvirt-libvirt.html#virDomainSnapshotLookupByName">virDomainSnapshotLookupByName</a>() to fail when converting a name from this call into a snapshot object, if another connection deletes the snapshot in the meantime. For more control over the results, see <a href="libvirt-libvirt.html#virDomainListAllSnapshots">virDomainListAllSnapshots</a>().</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>names</dt><dd>array to collect the list of names of snapshots</dd><dt>nameslen</dt><dd>size of @names</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></dd><dt>Returns</dt><dd>the number of domain snapshots found or -1 in case of error. The caller is responsible to call free() for each member of the array.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotLookupByName" id="virDomainSnapshotLookupByName"><code>virDomainSnapshotLookupByName</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span>	virDomainSnapshotLookupByName	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
							 <span class="type">const char *</span> name,
							 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Try to lookup a domain snapshot based on its name.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>name</dt><dd>name for the domain snapshot</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a domain snapshot object or NULL in case of failure. If the domain snapshot cannot be found, then the <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_SNAPSHOT">VIR_ERR_NO_DOMAIN_SNAPSHOT</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotNum" id="virDomainSnapshotNum"><code>virDomainSnapshotNum</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotNum		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Provides the number of domain snapshots for this domain.</p><p>By default, this command covers all snapshots; it is also possible to limit things to just snapshots with no parents, when @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ROOTS">VIR_DOMAIN_SNAPSHOT_LIST_ROOTS</a>. Additional filters are provided in groups, where each group contains bits that describe mutually exclusive attributes of a snapshot, and where all bits within a group describe all possible snapshots. Some hypervisors might reject explicit bits from a group where the hypervisor cannot make a distinction. For a group supported by a given hypervisor, the behavior when no bits of a group are set is identical to the behavior when all bits in that group are set. When setting bits from more than one group, it is possible to select an impossible combination, in that case a hypervisor may return either 0 or an error.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES</a>, to filter based on snapshots that have no further children (a leaf snapshot).</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA</a>, for filtering snapshots based on whether they have metadata that would prevent the removal of the last reference to a domain.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE</a>, <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE</a>, and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY</a>, for filtering snapshots based on what domain state is tracked by the snapshot.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL</a>, for filtering snapshots based on whether the snapshot is stored inside the disk images or as additional files.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></dd><dt>Returns</dt><dd>the number of domain snapshots found or -1 in case of error.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotNumChildren" id="virDomainSnapshotNumChildren"><code>virDomainSnapshotNumChildren</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotNumChildren	(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Provides the number of child snapshots for this domain snapshot.</p><p>By default, this command covers only direct children; it is also possible to expand things to cover all descendants, when @flags includes <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS">VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS</a>. Also, some filters are provided in groups, where each group contains bits that describe mutually exclusive attributes of a snapshot, and where all bits within a group describe all possible snapshots. Some hypervisors might reject explicit bits from a group where the hypervisor cannot make a distinction. For a group supported by a given hypervisor, the behavior when no bits of a group are set is identical to the behavior when all bits in that group are set. When setting bits from more than one group, it is possible to select an impossible combination, in that case a hypervisor may return either 0 or an error.</p><p>The first group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_LEAVES</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES">VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES</a>, to filter based on snapshots that have no further children (a leaf snapshot).</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_METADATA</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA">VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA</a>, for filtering snapshots based on whether they have metadata that would prevent the removal of the last reference to a domain.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE</a>, <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE">VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE</a>, and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY">VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY</a>, for filtering snapshots based on what domain state is tracked by the snapshot.</p><p>The next group of @flags is <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL</a> and <a href="libvirt-libvirt.html#VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL">VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL</a>, for filtering snapshots based on whether the snapshot is stored inside the disk images or as additional files.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>a domain snapshot object</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainSnapshotListFlags">virDomainSnapshotListFlags</a></dd><dt>Returns</dt><dd>the number of domain snapshots found or -1 in case of error.</dd></dl><div class="acl"></div><h3><a name="virDomainSnapshotRef" id="virDomainSnapshotRef"><code>virDomainSnapshotRef</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSnapshotRef		(<span class="type"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a></span> snapshot)</pre><div class="description"><p>Increment the reference count on the snapshot. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virDomainSnapshotFree">virDomainSnapshotFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection and domain remain open until all threads have finished using the snapshot. ie, each new thread using a snapshot would increment the reference count.</p></div><dl class="variablelist"><dt>snapshot</dt><dd>the snapshot to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainSuspend" id="virDomainSuspend"><code>virDomainSuspend</code></a></h3><pre class="api"><span class="type">int</span>	virDomainSuspend		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Suspends an active domain, the process is frozen without further access to CPU resources and I/O but the memory used by the domain at the hypervisor level will stay allocated. Use <a href="libvirt-libvirt.html#virDomainResume">virDomainResume</a>() to reactivate the domain. This function may require privileged access. Moreover, suspend may not be supported if domain is in some special state like <a href="libvirt-libvirt.html#VIR_DOMAIN_PMSUSPENDED">VIR_DOMAIN_PMSUSPENDED</a>.</p></div><dl class="variablelist"><dt>domain</dt><dd>a domain object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virDomainUndefine" id="virDomainUndefine"><code>virDomainUndefine</code></a></h3><pre class="api"><span class="type">int</span>	virDomainUndefine		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain)</pre><div class="description"><p>Undefine a domain. If the domain is running, it's converted to transient domain, without stopping it. If the domain is inactive, the domain configuration is removed.</p><p>If the domain has a managed save image (see <a href="libvirt-libvirt.html#virDomainHasManagedSaveImage">virDomainHasManagedSaveImage</a>()), or if it is inactive and has any snapshot metadata (see <a href="libvirt-libvirt.html#virDomainSnapshotNum">virDomainSnapshotNum</a>()), then the undefine will fail. See <a href="libvirt-libvirt.html#virDomainUndefineFlags">virDomainUndefineFlags</a>() for more control.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to a defined domain</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virDomainUndefineFlags" id="virDomainUndefineFlags"><code>virDomainUndefineFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainUndefineFlags		(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Undefine a domain. If the domain is running, it's converted to transient domain, without stopping it. If the domain is inactive, the domain configuration is removed.</p><p>If the domain has a managed save image (see <a href="libvirt-libvirt.html#virDomainHasManagedSaveImage">virDomainHasManagedSaveImage</a>()), then including <a href="libvirt-libvirt.html#VIR_DOMAIN_UNDEFINE_MANAGED_SAVE">VIR_DOMAIN_UNDEFINE_MANAGED_SAVE</a> in @flags will also remove that file, and omitting the flag will cause the undefine process to fail.</p><p>If the domain is inactive and has any snapshot metadata (see <a href="libvirt-libvirt.html#virDomainSnapshotNum">virDomainSnapshotNum</a>()), then including <a href="libvirt-libvirt.html#VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA">VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA</a> in @flags will also remove that metadata. Omitting the flag will cause the undefine of an inactive domain to fail. Active snapshots will retain snapshot metadata until the (now-transient) domain halts, regardless of whether this flag is present. On hypervisors where snapshots do not use libvirt metadata, this flag has no effect.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to a defined domain</dd><dt>flags</dt><dd>bitwise-OR of supported <a href="libvirt-libvirt.html#virDomainUndefineFlagsValues">virDomainUndefineFlagsValues</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virDomainUpdateDeviceFlags" id="virDomainUpdateDeviceFlags"><code>virDomainUpdateDeviceFlags</code></a></h3><pre class="api"><span class="type">int</span>	virDomainUpdateDeviceFlags	(<span class="type"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a></span> domain,
					 <span class="type">const char *</span> xml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Change a virtual device on a domain, using the flags parameter to control how the device is changed. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a> specifies that the device change is made based on current domain state. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be changed on the active domain instance only and is not added to the persisted domain configuration. <a href="libvirt-libvirt.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> specifies that the device shall be changed on the persisted domain configuration only. Note that the target hypervisor must return an error if unable to satisfy flags. E.g. the hypervisor driver will return failure if LIVE is specified but it only supports modifying the persisted device allocation.</p><p>This method is used for actions such changing CDROM/Floppy device media, altering the graphics configuration such as password, reconfiguring the NIC device backend connectivity, etc.</p></div><dl class="variablelist"><dt>domain</dt><dd>pointer to domain object</dd><dt>xml</dt><dd>pointer to XML description of one device</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virEventAddHandle" id="virEventAddHandle"><code>virEventAddHandle</code></a></h3><pre class="api"><span class="type">int</span>	virEventAddHandle		(<span class="type">int</span> fd,
					 <span class="type">int</span> events,
					 <span class="type"><a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a></span> cb,
					 <span class="type">void *</span> opaque,
					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)</pre><div class="description"><p>Register a callback for monitoring file handle events.</p></div><dl class="variablelist"><dt>fd</dt><dd>file handle to monitor for events</dd><dt>events</dt><dd>bitset of events to watch from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</dd><dt>cb</dt><dd>callback to invoke when an event occurs</dd><dt>opaque</dt><dd>user data to pass to callback</dd><dt>ff</dt><dd>callback to free opaque when handle is removed</dd><dt>Returns</dt><dd>-1 if the file handle cannot be registered, otherwise a handle watch number to be used for updating and unregistering for events</dd></dl><div class="acl"></div><h3><a name="virEventAddHandleFunc" id="virEventAddHandleFunc"><code>virEventAddHandleFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virEventAddHandleFunc	)	(<span class="type">int</span> fd,
					 <span class="type">int</span> event,
					 <span class="type"><a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a></span> cb,
					 <span class="type">void *</span> opaque,
					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)
</pre><div class="description"><p>Part of the EventImpl, this callback adds a file handle callback to listen for specific events. The same file handle can be registered multiple times provided the requested event sets are non-overlapping</p><p>If the opaque user data requires free'ing when the handle is unregistered, then a 2nd callback can be supplied for this purpose. This callback needs to be invoked from a clean stack. If 'ff' callbacks are invoked directly from the <a href="libvirt-libvirt.html#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a> they will likely deadlock in libvirt.</p></div><dl class="variablelist"><dt>fd</dt><dd>file descriptor to listen on</dd><dt>event</dt><dd>bitset of events on which to fire the callback</dd><dt>cb</dt><dd>the callback to be called when an event occurrs</dd><dt>opaque</dt><dd>user data to pass to the callback</dd><dt>ff</dt><dd>the callback invoked to free opaque data blob</dd><dt>Returns</dt><dd>-1 if the file handle cannot be registered, otherwise a handle watch number to be used for updating and unregistering for events</dd></dl><br /><h3><a name="virEventAddTimeout" id="virEventAddTimeout"><code>virEventAddTimeout</code></a></h3><pre class="api"><span class="type">int</span>	virEventAddTimeout		(<span class="type">int</span> timeout,
					 <span class="type"><a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a></span> cb,
					 <span class="type">void *</span> opaque,
					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)</pre><div class="description"><p>Register a callback for a timer event.</p><p>Setting timeout to -1 will disable the timer. Setting the timeout to zero will cause it to fire on every event loop iteration.</p></div><dl class="variablelist"><dt>timeout</dt><dd>time between events in milliseconds</dd><dt>cb</dt><dd>callback to invoke when an event occurs</dd><dt>opaque</dt><dd>user data to pass to callback</dd><dt>ff</dt><dd>callback to free opaque when timeout is removed</dd><dt>Returns</dt><dd>-1 if the timer cannot be registered, a positive integer timer id upon success.</dd></dl><div class="acl"></div><h3><a name="virEventAddTimeoutFunc" id="virEventAddTimeoutFunc"><code>virEventAddTimeoutFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virEventAddTimeoutFunc	)	(<span class="type">int</span> timeout,
					 <span class="type"><a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a></span> cb,
					 <span class="type">void *</span> opaque,
					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)
</pre><div class="description"><p>Part of the EventImpl, this user-defined callback handles adding an event timeout.</p><p>If the opaque user data requires free'ing when the handle is unregistered, then a 2nd callback can be supplied for this purpose.</p></div><dl class="variablelist"><dt>timeout</dt><dd>The timeout to monitor</dd><dt>cb</dt><dd>the callback to call when timeout has expired</dd><dt>opaque</dt><dd>user data to pass to the callback</dd><dt>ff</dt><dd>the callback invoked to free opaque data blob</dd><dt>Returns</dt><dd>a timer value</dd></dl><br /><h3><a name="virEventHandleCallback" id="virEventHandleCallback"><code>virEventHandleCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virEventHandleCallback	)	(<span class="type">int</span> watch,
					 <span class="type">int</span> fd,
					 <span class="type">int</span> events,
					 <span class="type">void *</span> opaque)
</pre><div class="description"><p>Callback for receiving file handle events. The callback will be invoked once for each event which is pending.</p></div><dl class="variablelist"><dt>watch</dt><dd>watch on which the event occurred</dd><dt>fd</dt><dd>file handle on which the event occurred</dd><dt>events</dt><dd>bitset of events from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</dd><dt>opaque</dt><dd>user data registered with handle</dd></dl><br /><h3><a name="virEventRegisterDefaultImpl" id="virEventRegisterDefaultImpl"><code>virEventRegisterDefaultImpl</code></a></h3><pre class="api"><span class="type">int</span>	virEventRegisterDefaultImpl	(<span class="type">void</span>)</pre><div class="description"><p>Registers a default event implementation based on the poll() system call. This is a generic implementation that can be used by any client application which does not have a need to integrate with an external event loop impl.</p><p>Once registered, the application has to invoke <a href="libvirt-libvirt.html#virEventRunDefaultImpl">virEventRunDefaultImpl</a> in a loop to process events. Failure to do so may result in connections being closed unexpectedly as a result of keepalive timeout.</p></div><dl class="variablelist"><dt>Returns</dt><dd>0 on success, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virEventRegisterImpl" id="virEventRegisterImpl"><code>virEventRegisterImpl</code></a></h3><pre class="api"><span class="type">void</span>	virEventRegisterImpl		(<span class="type"><a href="libvirt-libvirt.html#virEventAddHandleFunc">virEventAddHandleFunc</a></span> addHandle,
					 <span class="type"><a href="libvirt-libvirt.html#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a></span> updateHandle,
					 <span class="type"><a href="libvirt-libvirt.html#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a></span> removeHandle,
					 <span class="type"><a href="libvirt-libvirt.html#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a></span> addTimeout,
					 <span class="type"><a href="libvirt-libvirt.html#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a></span> updateTimeout,
					 <span class="type"><a href="libvirt-libvirt.html#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a></span> removeTimeout)</pre><div class="description"><p>Registers an event implementation, to allow integration with an external event loop. Applications would use this to integrate with the libglib2 event loop, or libevent or the QT event loop.</p><p>If an application does not need to integrate with an existing event loop implementation, then the <a href="libvirt-libvirt.html#virEventRegisterDefaultImpl">virEventRegisterDefaultImpl</a> method can be used to setup the generic libvirt implementation.</p></div><dl class="variablelist"><dt>addHandle</dt><dd>the callback to add fd handles</dd><dt>updateHandle</dt><dd>the callback to update fd handles</dd><dt>removeHandle</dt><dd>the callback to remove fd handles</dd><dt>addTimeout</dt><dd>the callback to add a timeout</dd><dt>updateTimeout</dt><dd>the callback to update a timeout</dd><dt>removeTimeout</dt><dd>the callback to remove a timeout</dd></dl><div class="acl"></div><h3><a name="virEventRemoveHandle" id="virEventRemoveHandle"><code>virEventRemoveHandle</code></a></h3><pre class="api"><span class="type">int</span>	virEventRemoveHandle		(<span class="type">int</span> watch)</pre><div class="description"><p>Unregister a callback from a file handle.</p></div><dl class="variablelist"><dt>watch</dt><dd>watch whose file handle to remove</dd><dt>Returns</dt><dd>-1 if the file handle was not registered, 0 upon success.</dd></dl><div class="acl"></div><h3><a name="virEventRemoveHandleFunc" id="virEventRemoveHandleFunc"><code>virEventRemoveHandleFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virEventRemoveHandleFunc)	(<span class="type">int</span> watch)
</pre><div class="description"><p>Part of the EventImpl, this user-provided callback is notified when an fd is no longer being listened on.</p><p>If a virEventHandleFreeFunc was supplied when the handle was registered, it will be invoked some time during, or after this function call, when it is safe to release the user data.</p></div><dl class="variablelist"><dt>watch</dt><dd>file descriptor watch to stop listening on</dd><dt>Returns</dt><dd>-1 if the file handle was not registered, 0 upon success</dd></dl><br /><h3><a name="virEventRemoveTimeout" id="virEventRemoveTimeout"><code>virEventRemoveTimeout</code></a></h3><pre class="api"><span class="type">int</span>	virEventRemoveTimeout		(<span class="type">int</span> timer)</pre><div class="description"><p>Unregister a callback for a timer.</p></div><dl class="variablelist"><dt>timer</dt><dd>the timer id to remove</dd><dt>Returns</dt><dd>-1 if the timer was not registered, 0 upon success.</dd></dl><div class="acl"></div><h3><a name="virEventRemoveTimeoutFunc" id="virEventRemoveTimeoutFunc"><code>virEventRemoveTimeoutFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virEventRemoveTimeoutFunc)	(<span class="type">int</span> timer)
</pre><div class="description"><p>Part of the EventImpl, this user-defined callback removes a timer</p><p>If a virEventTimeoutFreeFunc was supplied when the handle was registered, it will be invoked some time during, or after this function call, when it is safe to release the user data.</p></div><dl class="variablelist"><dt>timer</dt><dd>the timer to remove</dd><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl><br /><h3><a name="virEventRunDefaultImpl" id="virEventRunDefaultImpl"><code>virEventRunDefaultImpl</code></a></h3><pre class="api"><span class="type">int</span>	virEventRunDefaultImpl		(<span class="type">void</span>)</pre><div class="description"><p>Run one iteration of the event loop. Applications will generally want to have a thread which invokes this method in an infinite loop</p><p>static bool quit = false;</p><p>while (!quit) { if (<a href="libvirt-libvirt.html#virEventRunDefaultImpl">virEventRunDefaultImpl</a>() &lt; 0) ...print error... }</p></div><dl class="variablelist"><dt>Returns</dt><dd>0 on success, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virEventTimeoutCallback" id="virEventTimeoutCallback"><code>virEventTimeoutCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virEventTimeoutCallback	)	(<span class="type">int</span> timer,
					 <span class="type">void *</span> opaque)
</pre><div class="description"><p>callback for receiving timer events</p></div><dl class="variablelist"><dt>timer</dt><dd>timer id emitting the event</dd><dt>opaque</dt><dd>user data registered with handle</dd></dl><br /><h3><a name="virEventUpdateHandle" id="virEventUpdateHandle"><code>virEventUpdateHandle</code></a></h3><pre class="api"><span class="type">void</span>	virEventUpdateHandle		(<span class="type">int</span> watch,
					 <span class="type">int</span> events)</pre><div class="description"><p>Change event set for a monitored file handle.</p><p>Will not fail if fd exists</p></div><dl class="variablelist"><dt>watch</dt><dd>watch whose file handle to update</dd><dt>events</dt><dd>bitset of events to watch from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</dd></dl><div class="acl"></div><h3><a name="virEventUpdateHandleFunc" id="virEventUpdateHandleFunc"><code>virEventUpdateHandleFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virEventUpdateHandleFunc)	(<span class="type">int</span> watch,
					 <span class="type">int</span> event)
</pre><div class="description"><p>Part of the EventImpl, this user-provided callback is notified when events to listen on change</p></div><dl class="variablelist"><dt>watch</dt><dd>file descriptor watch to modify</dd><dt>event</dt><dd>new events to listen on</dd></dl><br /><h3><a name="virEventUpdateTimeout" id="virEventUpdateTimeout"><code>virEventUpdateTimeout</code></a></h3><pre class="api"><span class="type">void</span>	virEventUpdateTimeout		(<span class="type">int</span> timer,
					 <span class="type">int</span> timeout)</pre><div class="description"><p>Change frequency for a timer.</p><p>Setting frequency to -1 will disable the timer. Setting the frequency to zero will cause it to fire on every event loop iteration.</p><p>Will not fail if timer exists</p></div><dl class="variablelist"><dt>timer</dt><dd>timer id to change</dd><dt>timeout</dt><dd>time between events in milliseconds</dd></dl><div class="acl"></div><h3><a name="virEventUpdateTimeoutFunc" id="virEventUpdateTimeoutFunc"><code>virEventUpdateTimeoutFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virEventUpdateTimeoutFunc)	(<span class="type">int</span> timer,
					 <span class="type">int</span> timeout)
</pre><div class="description"><p>Part of the EventImpl, this user-defined callback updates an event timeout.</p></div><dl class="variablelist"><dt>timer</dt><dd>the timer to modify</dd><dt>timeout</dt><dd>the new timeout value</dd></dl><br /><h3><a name="virFreeCallback" id="virFreeCallback"><code>virFreeCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virFreeCallback		)	(<span class="type">void *</span> opaque)
</pre><div class="description"><p>Type for a callback cleanup function to be paired with a callback. This function will be called as a final chance to clean up the @opaque registered with the primary callback, at the time when the primary callback is deregistered.</p><p>It is forbidden to call any other libvirt APIs from an implementation of this callback, since it can be invoked from a context which is not re-entrant safe. Failure to abide by this requirement may lead to application deadlocks or crashes.</p></div><dl class="variablelist"><dt>opaque</dt><dd>opaque user data provided at registration</dd></dl><br /><h3><a name="virGetVersion" id="virGetVersion"><code>virGetVersion</code></a></h3><pre class="api"><span class="type">int</span>	virGetVersion			(<span class="type">unsigned long *</span> libVer,
					 <span class="type">const char *</span> type,
					 <span class="type">unsigned long *</span> typeVer)</pre><div class="description"><p>Provides version information. @libVer is the version of the library and will always be set unless an error occurs, in which case an error code will be returned. @typeVer exists for historical compatibility; if it is not NULL it will duplicate @libVer (it was originally intended to return hypervisor information based on @type, but due to the design of remote clients this is not reliable). To get the version of the running hypervisor use the <a href="libvirt-libvirt.html#virConnectGetVersion">virConnectGetVersion</a> function instead. To get the libvirt library version used by a connection use the <a href="libvirt-libvirt.html#virConnectGetLibVersion">virConnectGetLibVersion</a> instead.</p></div><dl class="variablelist"><dt>libVer</dt><dd>return value for the library version (OUT)</dd><dt>type</dt><dd>ignored; pass NULL</dd><dt>typeVer</dt><dd>pass NULL; for historical purposes duplicates @libVer if non-NULL</dd><dt>Returns</dt><dd>-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release.</dd></dl><div class="acl"></div><h3><a name="virInitialize" id="virInitialize"><code>virInitialize</code></a></h3><pre class="api"><span class="type">int</span>	virInitialize			(<span class="type">void</span>)</pre><div class="description"><p>Initialize the library.</p><p>This method is invoked automatically by any of the <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> API calls. Since release 1.0.0, there is no need to call this method even in a multithreaded application, since initialization is performed in a thread safe manner.</p><p>The only time it would be necessary to call <a href="libvirt-libvirt.html#virInitialize">virInitialize</a> is if the application did not invoke <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> as its first API call.</p></div><dl class="variablelist"><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virInterfaceChangeBegin" id="virInterfaceChangeBegin"><code>virInterfaceChangeBegin</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceChangeBegin		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This function creates a restore point to which one can return later by calling <a href="libvirt-libvirt.html#virInterfaceChangeRollback">virInterfaceChangeRollback</a>(). This function should be called before any transaction with interface configuration. Once it is known that a new configuration works, it can be committed via <a href="libvirt-libvirt.html#virInterfaceChangeCommit">virInterfaceChangeCommit</a>(), which frees the restore point.</p><p>If <a href="libvirt-libvirt.html#virInterfaceChangeBegin">virInterfaceChangeBegin</a>() is called when a transaction is already opened, this function will fail, and a VIR_ERR_INVALID_OPERATION will be logged.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virInterfaceChangeCommit" id="virInterfaceChangeCommit"><code>virInterfaceChangeCommit</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceChangeCommit	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This commits the changes made to interfaces and frees the restore point created by <a href="libvirt-libvirt.html#virInterfaceChangeBegin">virInterfaceChangeBegin</a>().</p><p>If <a href="libvirt-libvirt.html#virInterfaceChangeCommit">virInterfaceChangeCommit</a>() is called when a transaction is not opened, this function will fail, and a VIR_ERR_INVALID_OPERATION will be logged.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virInterfaceChangeRollback" id="virInterfaceChangeRollback"><code>virInterfaceChangeRollback</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceChangeRollback	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This cancels changes made to interfaces settings by restoring previous state created by <a href="libvirt-libvirt.html#virInterfaceChangeBegin">virInterfaceChangeBegin</a>().</p><p>If <a href="libvirt-libvirt.html#virInterfaceChangeRollback">virInterfaceChangeRollback</a>() is called when a transaction is not opened, this function will fail, and a VIR_ERR_INVALID_OPERATION will be logged.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virInterfaceCreate" id="virInterfaceCreate"><code>virInterfaceCreate</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceCreate		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Activate an interface (i.e. call "ifup").</p><p>If there was an open network config transaction at the time this interface was defined (that is, if <a href="libvirt-libvirt.html#virInterfaceChangeBegin">virInterfaceChangeBegin</a>() had been called), the interface will be brought back down (and then undefined) if <a href="libvirt-libvirt.html#virInterfaceChangeRollback">virInterfaceChangeRollback</a>() is called.</p></div><dl class="variablelist"><dt>iface</dt><dd>pointer to a defined interface</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virInterfaceDefineXML" id="virInterfaceDefineXML"><code>virInterfaceDefineXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span>	virInterfaceDefineXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Define an interface (or modify existing interface configuration).</p><p>Normally this change in the interface configuration is immediately permanent/persistent, but if <a href="libvirt-libvirt.html#virInterfaceChangeBegin">virInterfaceChangeBegin</a>() has been previously called (i.e. if an interface config transaction is open), the new interface definition will only become permanent if <a href="libvirt-libvirt.html#virInterfaceChangeCommit">virInterfaceChangeCommit</a>() is called prior to the next reboot of the system running libvirtd. Prior to that time, it can be explicitly removed using <a href="libvirt-libvirt.html#virInterfaceChangeRollback">virInterfaceChangeRollback</a>(), or will be automatically removed during the next reboot of the system running libvirtd.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xml</dt><dd>the XML description for the interface, preferably in UTF-8</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>NULL in case of error, a pointer to the interface otherwise</dd></dl><div class="acl"></div><h3><a name="virInterfaceDestroy" id="virInterfaceDestroy"><code>virInterfaceDestroy</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceDestroy		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>deactivate an interface (ie call "ifdown") This does not remove the interface from the config, and does not free the associated <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> object.</p><p>If there is an open network config transaction at the time this interface is destroyed (that is, if <a href="libvirt-libvirt.html#virInterfaceChangeBegin">virInterfaceChangeBegin</a>() had been called), and if the interface is later undefined and then <a href="libvirt-libvirt.html#virInterfaceChangeRollback">virInterfaceChangeRollback</a>() is called, the restoral of the interface definition will also bring the interface back up.</p></div><dl class="variablelist"><dt>iface</dt><dd>an interface object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virInterfaceFree" id="virInterfaceFree"><code>virInterfaceFree</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceFree		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)</pre><div class="description"><p>Free the interface object. The interface itself is unaltered. The data structure is freed and should not be used thereafter.</p></div><dl class="variablelist"><dt>iface</dt><dd>an interface object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virInterfaceGetConnect" id="virInterfaceGetConnect"><code>virInterfaceGetConnect</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virInterfaceGetConnect	(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)</pre><div class="description"><p>Provides the connection pointer associated with an interface. The reference counter on the connection is not increased by this call.</p><p>WARNING: When writing libvirt bindings in other languages, do not use this function. Instead, store the connection and the interface object together.</p></div><dl class="variablelist"><dt>iface</dt><dd>pointer to an interface</dd><dt>Returns</dt><dd>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</dd></dl><div class="acl"></div><h3><a name="virInterfaceGetMACString" id="virInterfaceGetMACString"><code>virInterfaceGetMACString</code></a></h3><pre class="api"><span class="type">const char *</span>	virInterfaceGetMACString	(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)</pre><div class="description"><p>Get the MAC for an interface as string. For more information about MAC see RFC4122.</p></div><dl class="variablelist"><dt>iface</dt><dd>an interface object</dd><dt>Returns</dt><dd>a pointer to the MAC address (in null-terminated ASCII format) or NULL, the string need not be deallocated its lifetime will be the same as the interface object.</dd></dl><div class="acl"></div><h3><a name="virInterfaceGetName" id="virInterfaceGetName"><code>virInterfaceGetName</code></a></h3><pre class="api"><span class="type">const char *</span>	virInterfaceGetName	(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)</pre><div class="description"><p>Get the public name for that interface</p></div><dl class="variablelist"><dt>iface</dt><dd>an interface object</dd><dt>Returns</dt><dd>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the interface object.</dd></dl><div class="acl"></div><h3><a name="virInterfaceGetXMLDesc" id="virInterfaceGetXMLDesc"><code>virInterfaceGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virInterfaceGetXMLDesc		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p><a href="libvirt-libvirt.html#VIR_INTERFACE_XML_INACTIVE">VIR_INTERFACE_XML_INACTIVE</a> - return the static configuration, suitable for use redefining the interface via <a href="libvirt-libvirt.html#virInterfaceDefineXML">virInterfaceDefineXML</a>()</p><p>Provide an XML description of the interface. If <a href="libvirt-libvirt.html#VIR_INTERFACE_XML_INACTIVE">VIR_INTERFACE_XML_INACTIVE</a> is set, the description may be reused later to redefine the interface with <a href="libvirt-libvirt.html#virInterfaceDefineXML">virInterfaceDefineXML</a>(). If it is not set, the ip address and netmask will be the current live setting of the interface, not the settings from the config files.</p></div><dl class="variablelist"><dt>iface</dt><dd>an interface object</dd><dt>flags</dt><dd>bitwise-OR of extraction flags. Current valid bits:</dd><dt>Returns</dt><dd>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virInterfaceIsActive" id="virInterfaceIsActive"><code>virInterfaceIsActive</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceIsActive		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)</pre><div class="description"><p>Determine if the interface is currently running</p></div><dl class="variablelist"><dt>iface</dt><dd>pointer to the interface object</dd><dt>Returns</dt><dd>1 if running, 0 if inactive, -1 on error</dd></dl><div class="acl"></div><h3><a name="virInterfaceLookupByMACString" id="virInterfaceLookupByMACString"><code>virInterfaceLookupByMACString</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span>	virInterfaceLookupByMACString	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> macstr)</pre><div class="description"><p>Try to lookup an interface on the given hypervisor based on its MAC.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>macstr</dt><dd>the MAC for the interface (null-terminated ASCII format)</dd><dt>Returns</dt><dd>a new interface object or NULL in case of failure. If the interface cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_INTERFACE">VIR_ERR_NO_INTERFACE</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virInterfaceLookupByName" id="virInterfaceLookupByName"><code>virInterfaceLookupByName</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span>	virInterfaceLookupByName	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> name)</pre><div class="description"><p>Try to lookup an interface on the given hypervisor based on its name.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>name</dt><dd>name for the interface</dd><dt>Returns</dt><dd>a new interface object or NULL in case of failure. If the interface cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_INTERFACE">VIR_ERR_NO_INTERFACE</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virInterfaceRef" id="virInterfaceRef"><code>virInterfaceRef</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceRef			(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)</pre><div class="description"><p>Increment the reference count on the interface. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virInterfaceFree">virInterfaceFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using an interface would increment the reference count.</p></div><dl class="variablelist"><dt>iface</dt><dd>the interface to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virInterfaceUndefine" id="virInterfaceUndefine"><code>virInterfaceUndefine</code></a></h3><pre class="api"><span class="type">int</span>	virInterfaceUndefine		(<span class="type"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a></span> iface)</pre><div class="description"><p>Undefine an interface, ie remove it from the config. This does not free the associated <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> object.</p><p>Normally this change in the interface configuration is permanent/persistent, but if <a href="libvirt-libvirt.html#virInterfaceChangeBegin">virInterfaceChangeBegin</a>() has been previously called (i.e. if an interface config transaction is open), the removal of the interface definition will only become permanent if <a href="libvirt-libvirt.html#virInterfaceChangeCommit">virInterfaceChangeCommit</a>() is called prior to the next reboot of the system running libvirtd. Prior to that time, the definition can be explicitly restored using <a href="libvirt-libvirt.html#virInterfaceChangeRollback">virInterfaceChangeRollback</a>(), or will be automatically restored during the next reboot of the system running libvirtd.</p></div><dl class="variablelist"><dt>iface</dt><dd>pointer to a defined interface</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virNWFilterDefineXML" id="virNWFilterDefineXML"><code>virNWFilterDefineXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span>	virNWFilterDefineXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xmlDesc)</pre><div class="description"><p>Define a new network filter, based on an XML description similar to the one returned by <a href="libvirt-libvirt.html#virNWFilterGetXMLDesc">virNWFilterGetXMLDesc</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xmlDesc</dt><dd>an XML description of the nwfilter</dd><dt>Returns</dt><dd>a new nwfilter object or NULL in case of failure</dd></dl><div class="acl"></div><h3><a name="virNWFilterFree" id="virNWFilterFree"><code>virNWFilterFree</code></a></h3><pre class="api"><span class="type">int</span>	virNWFilterFree			(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter)</pre><div class="description"><p>Free the nwfilter object. The running instance is kept alive. The data structure is freed and should not be used thereafter.</p></div><dl class="variablelist"><dt>nwfilter</dt><dd>a nwfilter object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNWFilterGetName" id="virNWFilterGetName"><code>virNWFilterGetName</code></a></h3><pre class="api"><span class="type">const char *</span>	virNWFilterGetName	(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter)</pre><div class="description"><p>Get the public name for the network filter</p></div><dl class="variablelist"><dt>nwfilter</dt><dd>a nwfilter object</dd><dt>Returns</dt><dd>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the nwfilter object.</dd></dl><div class="acl"></div><h3><a name="virNWFilterGetUUID" id="virNWFilterGetUUID"><code>virNWFilterGetUUID</code></a></h3><pre class="api"><span class="type">int</span>	virNWFilterGetUUID		(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter,
					 <span class="type">unsigned char *</span> uuid)</pre><div class="description"><p>Get the UUID for a network filter</p></div><dl class="variablelist"><dt>nwfilter</dt><dd>a nwfilter object</dd><dt>uuid</dt><dd>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virNWFilterGetUUIDString" id="virNWFilterGetUUIDString"><code>virNWFilterGetUUIDString</code></a></h3><pre class="api"><span class="type">int</span>	virNWFilterGetUUIDString	(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter,
					 <span class="type">char *</span> buf)</pre><div class="description"><p>Get the UUID for a network filter as string. For more information about UUID see RFC4122.</p></div><dl class="variablelist"><dt>nwfilter</dt><dd>a nwfilter object</dd><dt>buf</dt><dd>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virNWFilterGetXMLDesc" id="virNWFilterGetXMLDesc"><code>virNWFilterGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virNWFilterGetXMLDesc		(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Provide an XML description of the network filter. The description may be reused later to redefine the network filter with virNWFilterCreateXML().</p></div><dl class="variablelist"><dt>nwfilter</dt><dd>a nwfilter object</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virNWFilterLookupByName" id="virNWFilterLookupByName"><code>virNWFilterLookupByName</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span>	virNWFilterLookupByName	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> name)</pre><div class="description"><p>Try to lookup a network filter on the given hypervisor based on its name.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>name</dt><dd>name for the network filter</dd><dt>Returns</dt><dd>a new nwfilter object or NULL in case of failure. If the network filter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virNWFilterLookupByUUID" id="virNWFilterLookupByUUID"><code>virNWFilterLookupByUUID</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span>	virNWFilterLookupByUUID	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const unsigned char *</span> uuid)</pre><div class="description"><p>Try to lookup a network filter on the given hypervisor based on its UUID.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>uuid</dt><dd>the raw UUID for the network filter</dd><dt>Returns</dt><dd>a new nwfilter object or NULL in case of failure. If the nwfdilter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virNWFilterLookupByUUIDString" id="virNWFilterLookupByUUIDString"><code>virNWFilterLookupByUUIDString</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span>	virNWFilterLookupByUUIDString	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> uuidstr)</pre><div class="description"><p>Try to lookup an nwfilter on the given hypervisor based on its UUID.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>uuidstr</dt><dd>the string UUID for the nwfilter</dd><dt>Returns</dt><dd>a new nwfilter object or NULL in case of failure. If the nwfilter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virNWFilterRef" id="virNWFilterRef"><code>virNWFilterRef</code></a></h3><pre class="api"><span class="type">int</span>	virNWFilterRef			(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter)</pre><div class="description"><p>Increment the reference count on the nwfilter. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virNWFilterFree">virNWFilterFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using an nwfilter would increment the reference count.</p></div><dl class="variablelist"><dt>nwfilter</dt><dd>the nwfilter to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNWFilterUndefine" id="virNWFilterUndefine"><code>virNWFilterUndefine</code></a></h3><pre class="api"><span class="type">int</span>	virNWFilterUndefine		(<span class="type"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a></span> nwfilter)</pre><div class="description"><p>Undefine the nwfilter object. This call will not succeed if a running VM is referencing the filter. This does not free the associated <a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> object.</p></div><dl class="variablelist"><dt>nwfilter</dt><dd>a nwfilter object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNetworkCreate" id="virNetworkCreate"><code>virNetworkCreate</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkCreate		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)</pre><div class="description"><p>Create and start a defined network. If the call succeed the network moves from the defined to the running networks pools.</p></div><dl class="variablelist"><dt>network</dt><dd>pointer to a defined network</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virNetworkCreateXML" id="virNetworkCreateXML"><code>virNetworkCreateXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	virNetworkCreateXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xmlDesc)</pre><div class="description"><p>Create and start a new virtual network, based on an XML description similar to the one returned by <a href="libvirt-libvirt.html#virNetworkGetXMLDesc">virNetworkGetXMLDesc</a>()</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xmlDesc</dt><dd>an XML description of the network</dd><dt>Returns</dt><dd>a new network object or NULL in case of failure</dd></dl><div class="acl"></div><h3><a name="virNetworkDefineXML" id="virNetworkDefineXML"><code>virNetworkDefineXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	virNetworkDefineXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xml)</pre><div class="description"><p>Define a network, but does not create it</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xml</dt><dd>the XML description for the network, preferably in UTF-8</dd><dt>Returns</dt><dd>NULL in case of error, a pointer to the network otherwise</dd></dl><div class="acl"></div><h3><a name="virNetworkDestroy" id="virNetworkDestroy"><code>virNetworkDestroy</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkDestroy		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)</pre><div class="description"><p>Destroy the network object. The running instance is shutdown if not down already and all resources used by it are given back to the hypervisor. This does not free the associated <a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> object. This function may require privileged access</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNetworkFree" id="virNetworkFree"><code>virNetworkFree</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkFree			(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)</pre><div class="description"><p>Free the network object. The running instance is kept alive. The data structure is freed and should not be used thereafter.</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNetworkGetAutostart" id="virNetworkGetAutostart"><code>virNetworkGetAutostart</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkGetAutostart		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network,
					 <span class="type">int *</span> autostart)</pre><div class="description"><p>Provides a boolean value indicating whether the network configured to be automatically started when the host machine boots.</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>autostart</dt><dd>the value returned</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virNetworkGetBridgeName" id="virNetworkGetBridgeName"><code>virNetworkGetBridgeName</code></a></h3><pre class="api"><span class="type">char *</span>	virNetworkGetBridgeName		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)</pre><div class="description"><p>Provides a bridge interface name to which a domain may connect a network interface in order to join the network.</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>Returns</dt><dd>a 0 terminated interface name, or NULL in case of error. the caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virNetworkGetConnect" id="virNetworkGetConnect"><code>virNetworkGetConnect</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virNetworkGetConnect	(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> net)</pre><div class="description"><p>Provides the connection pointer associated with a network. The reference counter on the connection is not increased by this call.</p><p>WARNING: When writing libvirt bindings in other languages, do not use this function. Instead, store the connection and the network object together.</p></div><dl class="variablelist"><dt>net</dt><dd>pointer to a network</dd><dt>Returns</dt><dd>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNetworkGetName" id="virNetworkGetName"><code>virNetworkGetName</code></a></h3><pre class="api"><span class="type">const char *</span>	virNetworkGetName	(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)</pre><div class="description"><p>Get the public name for that network</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>Returns</dt><dd>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the network object.</dd></dl><div class="acl"></div><h3><a name="virNetworkGetUUID" id="virNetworkGetUUID"><code>virNetworkGetUUID</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkGetUUID		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network,
					 <span class="type">unsigned char *</span> uuid)</pre><div class="description"><p>Get the UUID for a network</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>uuid</dt><dd>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virNetworkGetUUIDString" id="virNetworkGetUUIDString"><code>virNetworkGetUUIDString</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkGetUUIDString		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network,
					 <span class="type">char *</span> buf)</pre><div class="description"><p>Get the UUID for a network as string. For more information about UUID see RFC4122.</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>buf</dt><dd>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virNetworkGetXMLDesc" id="virNetworkGetXMLDesc"><code>virNetworkGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virNetworkGetXMLDesc		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Provide an XML description of the network. The description may be reused later to relaunch the network with <a href="libvirt-libvirt.html#virNetworkCreateXML">virNetworkCreateXML</a>().</p><p>Normally, if a network included a physical function, the output includes all virtual functions tied to that physical interface. If @flags includes <a href="libvirt-libvirt.html#VIR_NETWORK_XML_INACTIVE">VIR_NETWORK_XML_INACTIVE</a>, then the expansion of virtual interfaces is not performed.</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virNetworkXMLFlags">virNetworkXMLFlags</a></dd><dt>Returns</dt><dd>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</dd></dl><div class="acl"></div><h3><a name="virNetworkIsActive" id="virNetworkIsActive"><code>virNetworkIsActive</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkIsActive		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> net)</pre><div class="description"><p>Determine if the network is currently running</p></div><dl class="variablelist"><dt>net</dt><dd>pointer to the network object</dd><dt>Returns</dt><dd>1 if running, 0 if inactive, -1 on error</dd></dl><div class="acl"></div><h3><a name="virNetworkIsPersistent" id="virNetworkIsPersistent"><code>virNetworkIsPersistent</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkIsPersistent		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> net)</pre><div class="description"><p>Determine if the network has a persistent configuration which means it will still exist after shutting down</p></div><dl class="variablelist"><dt>net</dt><dd>pointer to the network object</dd><dt>Returns</dt><dd>1 if persistent, 0 if transient, -1 on error</dd></dl><div class="acl"></div><h3><a name="virNetworkLookupByName" id="virNetworkLookupByName"><code>virNetworkLookupByName</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	virNetworkLookupByName	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> name)</pre><div class="description"><p>Try to lookup a network on the given hypervisor based on its name.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>name</dt><dd>name for the network</dd><dt>Returns</dt><dd>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virNetworkLookupByUUID" id="virNetworkLookupByUUID"><code>virNetworkLookupByUUID</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	virNetworkLookupByUUID	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const unsigned char *</span> uuid)</pre><div class="description"><p>Try to lookup a network on the given hypervisor based on its UUID.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>uuid</dt><dd>the raw UUID for the network</dd><dt>Returns</dt><dd>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virNetworkLookupByUUIDString" id="virNetworkLookupByUUIDString"><code>virNetworkLookupByUUIDString</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span>	virNetworkLookupByUUIDString	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> uuidstr)</pre><div class="description"><p>Try to lookup a network on the given hypervisor based on its UUID.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>uuidstr</dt><dd>the string UUID for the network</dd><dt>Returns</dt><dd>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virNetworkRef" id="virNetworkRef"><code>virNetworkRef</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkRef			(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)</pre><div class="description"><p>Increment the reference count on the network. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virNetworkFree">virNetworkFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using a network would increment the reference count.</p></div><dl class="variablelist"><dt>network</dt><dd>the network to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNetworkSetAutostart" id="virNetworkSetAutostart"><code>virNetworkSetAutostart</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkSetAutostart		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network,
					 <span class="type">int</span> autostart)</pre><div class="description"><p>Configure the network to be automatically started when the host machine boots.</p></div><dl class="variablelist"><dt>network</dt><dd>a network object</dd><dt>autostart</dt><dd>whether the network should be automatically started 0 or 1</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virNetworkUndefine" id="virNetworkUndefine"><code>virNetworkUndefine</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkUndefine		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network)</pre><div class="description"><p>Undefine a network but does not stop it if it is running</p></div><dl class="variablelist"><dt>network</dt><dd>pointer to a defined network</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virNetworkUpdate" id="virNetworkUpdate"><code>virNetworkUpdate</code></a></h3><pre class="api"><span class="type">int</span>	virNetworkUpdate		(<span class="type"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a></span> network,
					 <span class="type">unsigned int</span> command,
					 <span class="type">unsigned int</span> section,
					 <span class="type">int</span> parentIndex,
					 <span class="type">const char *</span> xml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Update the definition of an existing network, either its live running state, its persistent configuration, or both.</p></div><dl class="variablelist"><dt>network</dt><dd>pointer to a defined network</dd><dt>command</dt><dd>what action to perform (add/delete/modify) (see <a href="libvirt-libvirt.html#virNetworkUpdateCommand">virNetworkUpdateCommand</a> for descriptions)</dd><dt>section</dt><dd>which section of the network to update (see <a href="libvirt-libvirt.html#virNetworkUpdateSection">virNetworkUpdateSection</a> for descriptions)</dd><dt>parentIndex</dt><dd>which parent element, if there are multiple parents of the same type (e.g. which &lt;ip&gt; element when modifying a &lt;dhcp&gt;/&lt;host&gt; element), or "-1" for "don't care" or "automatically find appropriate one".</dd><dt>xml</dt><dd>the XML description for the network, preferably in UTF-8</dd><dt>flags</dt><dd>bitwise OR of <a href="libvirt-libvirt.html#virNetworkUpdateFlags">virNetworkUpdateFlags</a>.</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of error <a href="libvirt-libvirt.html#virNetworkUpdateCommand">virNetworkUpdateCommand</a> <a href="libvirt-libvirt.html#virNetworkUpdateSection">virNetworkUpdateSection</a></dd></dl><div class="acl"></div><h3><a name="virNodeDeviceCreateXML" id="virNodeDeviceCreateXML"><code>virNodeDeviceCreateXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span>	virNodeDeviceCreateXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> xmlDesc,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Create a new device on the VM host machine, for example, virtual HBAs created using vport_create.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>xmlDesc</dt><dd>string containing an XML description of the device to be created</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a node device object if successful, NULL in case of failure</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceDestroy" id="virNodeDeviceDestroy"><code>virNodeDeviceDestroy</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceDestroy		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Destroy the device object. The virtual device is removed from the host operating system. This function may require privileged access</p></div><dl class="variablelist"><dt>dev</dt><dd>a device object</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceDetachFlags" id="virNodeDeviceDetachFlags"><code>virNodeDeviceDetachFlags</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceDetachFlags	(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev,
					 <span class="type">const char *</span> driverName,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Detach the node device from the node itself so that it may be assigned to a guest domain.</p><p>Depending on the hypervisor, this may involve operations such as unbinding any device drivers from the device, binding the device to a dummy device driver and resetting the device. Different backend drivers expect the device to be bound to different dummy devices. For example, QEMU's "kvm" backend driver (the default) expects the device to be bound to "pci-stub", but its "vfio" backend driver expects the device to be bound to "vfio-pci".</p><p>If the device is currently in use by the node, this method may fail.</p><p>Once the device is not assigned to any guest, it may be re-attached to the node using the <a href="libvirt-libvirt.html#virNodeDeviceReAttach">virNodeDeviceReAttach</a>() method.</p></div><dl class="variablelist"><dt>dev</dt><dd>pointer to the node device</dd><dt>driverName</dt><dd>name of backend driver that will be used for later device assignment to a domain. NULL means "use the hypervisor default driver"</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceDettach" id="virNodeDeviceDettach"><code>virNodeDeviceDettach</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceDettach		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Dettach the node device from the node itself so that it may be assigned to a guest domain.</p><p>Depending on the hypervisor, this may involve operations such as unbinding any device drivers from the device, binding the device to a dummy device driver and resetting the device.</p><p>If the device is currently in use by the node, this method may fail.</p><p>Once the device is not assigned to any guest, it may be re-attached to the node using the virNodeDeviceReattach() method.</p><p>If the caller needs control over which backend driver will be used during PCI device assignment (to use something other than the default, for example VFIO), the newer <a href="libvirt-libvirt.html#virNodeDeviceDetachFlags">virNodeDeviceDetachFlags</a>() API should be used instead.</p></div><dl class="variablelist"><dt>dev</dt><dd>pointer to the node device</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceFree" id="virNodeDeviceFree"><code>virNodeDeviceFree</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceFree		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Drops a reference to the node device, freeing it if this was the last reference.</p></div><dl class="variablelist"><dt>dev</dt><dd>pointer to the node device</dd><dt>Returns</dt><dd>the 0 for success, -1 for error.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceGetName" id="virNodeDeviceGetName"><code>virNodeDeviceGetName</code></a></h3><pre class="api"><span class="type">const char *</span>	virNodeDeviceGetName	(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Just return the device name</p></div><dl class="variablelist"><dt>dev</dt><dd>the device</dd><dt>Returns</dt><dd>the device name or NULL in case of error</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceGetParent" id="virNodeDeviceGetParent"><code>virNodeDeviceGetParent</code></a></h3><pre class="api"><span class="type">const char *</span>	virNodeDeviceGetParent	(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Accessor for the parent of the device</p></div><dl class="variablelist"><dt>dev</dt><dd>the device</dd><dt>Returns</dt><dd>the name of the device's parent, or NULL if the device has no parent.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceGetXMLDesc" id="virNodeDeviceGetXMLDesc"><code>virNodeDeviceGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virNodeDeviceGetXMLDesc		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Fetch an XML document describing all aspects of the device.</p></div><dl class="variablelist"><dt>dev</dt><dd>pointer to the node device</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the XML document, or NULL on error</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceListCaps" id="virNodeDeviceListCaps"><code>virNodeDeviceListCaps</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceListCaps		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>Lists the names of the capabilities supported by the device.</p></div><dl class="variablelist"><dt>dev</dt><dd>the device</dd><dt>names</dt><dd>array to collect the list of capability names</dd><dt>maxnames</dt><dd>size of @names</dd><dt>Returns</dt><dd>the number of capability names listed in @names.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceLookupByName" id="virNodeDeviceLookupByName"><code>virNodeDeviceLookupByName</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span>	virNodeDeviceLookupByName	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type">const char *</span> name)</pre><div class="description"><p>Lookup a node device by its name.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>name</dt><dd>unique device name</dd><dt>Returns</dt><dd>a <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> if found, NULL otherwise.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceLookupSCSIHostByWWN" id="virNodeDeviceLookupSCSIHostByWWN"><code>virNodeDeviceLookupSCSIHostByWWN</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span>	virNodeDeviceLookupSCSIHostByWWN	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type">const char *</span> wwnn,
							 <span class="type">const char *</span> wwpn,
							 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Lookup SCSI Host which is capable with 'fc_host' by its WWNN and WWPN.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>wwnn</dt><dd>WWNN of the SCSI Host.</dd><dt>wwpn</dt><dd>WWPN of the SCSI Host.</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> if found, NULL otherwise.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceNumOfCaps" id="virNodeDeviceNumOfCaps"><code>virNodeDeviceNumOfCaps</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceNumOfCaps		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Accessor for the number of capabilities supported by the device.</p></div><dl class="variablelist"><dt>dev</dt><dd>the device</dd><dt>Returns</dt><dd>the number of capabilities supported by the device.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceReAttach" id="virNodeDeviceReAttach"><code>virNodeDeviceReAttach</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceReAttach		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Re-attach a previously dettached node device to the node so that it may be used by the node again.</p><p>Depending on the hypervisor, this may involve operations such as resetting the device, unbinding it from a dummy device driver and binding it to its appropriate driver.</p><p>If the device is currently in use by a guest, this method may fail.</p></div><dl class="variablelist"><dt>dev</dt><dd>pointer to the node device</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceRef" id="virNodeDeviceRef"><code>virNodeDeviceRef</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceRef		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Increment the reference count on the dev. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virNodeDeviceFree">virNodeDeviceFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using a dev would increment the reference count.</p></div><dl class="variablelist"><dt>dev</dt><dd>the dev to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeDeviceReset" id="virNodeDeviceReset"><code>virNodeDeviceReset</code></a></h3><pre class="api"><span class="type">int</span>	virNodeDeviceReset		(<span class="type"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a></span> dev)</pre><div class="description"><p>Reset a previously dettached node device to the node before or after assigning it to a guest.</p><p>The exact reset semantics depends on the hypervisor and device type but, for example, KVM will attempt to reset PCI devices with a Function Level Reset, Secondary Bus Reset or a Power Management D-State reset.</p><p>If the reset will affect other devices which are currently in use, this function may fail.</p></div><dl class="variablelist"><dt>dev</dt><dd>pointer to the node device</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeGetCPUMap" id="virNodeGetCPUMap"><code>virNodeGetCPUMap</code></a></h3><pre class="api"><span class="type">int</span>	virNodeGetCPUMap		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned char **</span> cpumap,
					 <span class="type">unsigned int *</span> online,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get CPU map of host node CPUs.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>cpumap</dt><dd>optional pointer to a bit map of real CPUs on the host node (in 8-bit bytes) (OUT) In case of success each bit set to 1 means that corresponding CPU is online. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit. The bit map is allocated by <a href="libvirt-libvirt.html#virNodeGetCPUMap">virNodeGetCPUMap</a> and needs to be released using free() by the caller.</dd><dt>online</dt><dd>optional number of online CPUs in cpumap (OUT) Contains the number of online CPUs if the call was successful.</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>number of CPUs present on the host node, or -1 if there was an error.</dd></dl><div class="acl"></div><h3><a name="virNodeGetCPUStats" id="virNodeGetCPUStats"><code>virNodeGetCPUStats</code></a></h3><pre class="api"><span class="type">int</span>	virNodeGetCPUStats		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">int</span> cpuNum,
					 <span class="type"><a href="libvirt-libvirt.html#virNodeCPUStatsPtr">virNodeCPUStatsPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This function provides individual cpu statistics of the node. If you want to get total cpu statistics of the node, you must specify <a href="libvirt-libvirt.html#VIR_NODE_CPU_STATS_ALL_CPUS">VIR_NODE_CPU_STATS_ALL_CPUS</a> to @cpuNum. The @params array will be filled with the values equal to the number of parameters suggested by @nparams</p><p>As the value of @nparams is dynamic, call the API setting @nparams to 0 and @params as NULL, the API returns the number of parameters supported by the HV by updating @nparams on SUCCESS. The caller should then allocate @params array, i.e. (sizeof(@virNodeCPUStats) * @nparams) bytes and call the API again.</p><p>Here is a sample code snippet:</p><p>if ((virNodeGetCPUStats(conn, cpuNum, NULL, &amp;nparams, 0) == 0) &amp;&amp; (nparams != 0)) { if ((params = malloc(sizeof(virNodeCPUStats) * nparams)) == NULL) goto error; memset(params, 0, sizeof(virNodeCPUStats) * nparams); if (virNodeGetCPUStats(conn, cpuNum, params, &amp;nparams, 0)) goto error; }</p><p>This function doesn't require privileged access to the hypervisor. This function expects the caller to allocate the @params.</p><p>CPU time Statistics:</p><p><a href="libvirt-libvirt.html#VIR_NODE_CPU_STATS_KERNEL">VIR_NODE_CPU_STATS_KERNEL</a>: The cumulative CPU time which spends by kernel, when the node booting up.(nanoseconds) <a href="libvirt-libvirt.html#VIR_NODE_CPU_STATS_USER">VIR_NODE_CPU_STATS_USER</a>: The cumulative CPU time which spends by user processes, when the node booting up.(nanoseconds) <a href="libvirt-libvirt.html#VIR_NODE_CPU_STATS_IDLE">VIR_NODE_CPU_STATS_IDLE</a>: The cumulative idle CPU time, when the node booting up.(nanoseconds) <a href="libvirt-libvirt.html#VIR_NODE_CPU_STATS_IOWAIT">VIR_NODE_CPU_STATS_IOWAIT</a>: The cumulative I/O wait CPU time, when the node booting up.(nanoseconds) <a href="libvirt-libvirt.html#VIR_NODE_CPU_STATS_UTILIZATION">VIR_NODE_CPU_STATS_UTILIZATION</a>: The CPU utilization. The usage value is in percent and 100% represents all CPUs on the server.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection.</dd><dt>cpuNum</dt><dd>number of node cpu. (<a href="libvirt-libvirt.html#VIR_NODE_CPU_STATS_ALL_CPUS">VIR_NODE_CPU_STATS_ALL_CPUS</a> means total cpu statistics)</dd><dt>params</dt><dd>pointer to node cpu time parameter objects</dd><dt>nparams</dt><dd>number of node cpu time parameter (this value should be same or less than the number of parameters supported)</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virNodeGetCellsFreeMemory" id="virNodeGetCellsFreeMemory"><code>virNodeGetCellsFreeMemory</code></a></h3><pre class="api"><span class="type">int</span>	virNodeGetCellsFreeMemory	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned long long *</span> freeMems,
					 <span class="type">int</span> startCell,
					 <span class="type">int</span> maxCells)</pre><div class="description"><p>This call returns the amount of free memory in one or more NUMA cells. The @freeMems array must be allocated by the caller and will be filled with the amount of free memory in bytes for each cell requested, starting with startCell (in freeMems[0]), up to either (startCell + maxCells), or the number of additional cells in the node, whichever is smaller.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>freeMems</dt><dd>pointer to the array of unsigned long long</dd><dt>startCell</dt><dd>index of first cell to return freeMems info on.</dd><dt>maxCells</dt><dd>Maximum number of cells for which freeMems information can be returned.</dd><dt>Returns</dt><dd>the number of entries filled in freeMems, or -1 in case of error.</dd></dl><div class="acl"></div><h3><a name="virNodeGetFreeMemory" id="virNodeGetFreeMemory"><code>virNodeGetFreeMemory</code></a></h3><pre class="api"><span class="type">unsigned long long</span>	virNodeGetFreeMemory	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn)</pre><div class="description"><p>provides the free memory available on the Node Note: most libvirt APIs provide memory sizes in kibibytes, but in this function the returned value is in bytes. Divide by 1024 as necessary.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>Returns</dt><dd>the available free memory in bytes or 0 in case of error</dd></dl><div class="acl"></div><h3><a name="virNodeGetInfo" id="virNodeGetInfo"><code>virNodeGetInfo</code></a></h3><pre class="api"><span class="type">int</span>	virNodeGetInfo			(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virNodeInfoPtr">virNodeInfoPtr</a></span> info)</pre><div class="description"><p>Extract hardware information about the node.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>info</dt><dd>pointer to a <a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> structure allocated by the user</dd><dt>Returns</dt><dd>0 in case of success and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeGetMemoryParameters" id="virNodeGetMemoryParameters"><code>virNodeGetMemoryParameters</code></a></h3><pre class="api"><span class="type">int</span>	virNodeGetMemoryParameters	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Get all node memory parameters (parameters unsupported by OS will be omitted). On input, @nparams gives the size of the @params array; on output, @nparams gives how many slots were filled with parameter information, which might be less but will not exceed the input value.</p><p>As a special case, calling with @params as NULL and @nparams as 0 on input will cause @nparams on output to contain the number of parameters supported by the hypervisor. The caller should then allocate @params array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API again. See <a href="libvirt-libvirt.html#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>() for an equivalent usage example.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>params</dt><dd>pointer to memory parameter object (return value, allocated by the caller)</dd><dt>nparams</dt><dd>pointer to number of memory parameters; input and output</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, and -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeGetMemoryStats" id="virNodeGetMemoryStats"><code>virNodeGetMemoryStats</code></a></h3><pre class="api"><span class="type">int</span>	virNodeGetMemoryStats		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">int</span> cellNum,
					 <span class="type"><a href="libvirt-libvirt.html#virNodeMemoryStatsPtr">virNodeMemoryStatsPtr</a></span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>This function provides memory stats of the node. If you want to get total memory statistics of the node, you must specify <a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_ALL_CELLS">VIR_NODE_MEMORY_STATS_ALL_CELLS</a> to @cellNum. The @params array will be filled with the values equal to the number of stats suggested by @nparams</p><p>As the value of @nparams is dynamic, call the API setting @nparams to 0 and @params as NULL, the API returns the number of parameters supported by the HV by updating @nparams on SUCCESS. The caller should then allocate @params array, i.e. (sizeof(@virNodeMemoryStats) * @nparams) bytes and call the API again.</p><p>Here is the sample code snippet:</p><p>if ((virNodeGetMemoryStats(conn, cellNum, NULL, &amp;nparams, 0) == 0) &amp;&amp; (nparams != 0)) { if ((params = malloc(sizeof(virNodeMemoryStats) * nparams)) == NULL) goto error; memset(params, cellNum, 0, sizeof(virNodeMemoryStats) * nparams); if (virNodeGetMemoryStats(conn, params, &amp;nparams, 0)) goto error; }</p><p>This function doesn't require privileged access to the hypervisor. This function expects the caller to allocate the @params.</p><p>Memory Stats:</p><p><a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_TOTAL">VIR_NODE_MEMORY_STATS_TOTAL</a>: The total memory usage.(KB) <a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_FREE">VIR_NODE_MEMORY_STATS_FREE</a>: The free memory usage.(KB) On linux, this usage includes buffers and cached. <a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_BUFFERS">VIR_NODE_MEMORY_STATS_BUFFERS</a>: The buffers memory usage.(KB) <a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_CACHED">VIR_NODE_MEMORY_STATS_CACHED</a>: The cached memory usage.(KB)</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection.</dd><dt>cellNum</dt><dd>number of node cell. (<a href="libvirt-libvirt.html#VIR_NODE_MEMORY_STATS_ALL_CELLS">VIR_NODE_MEMORY_STATS_ALL_CELLS</a> means total cell statistics)</dd><dt>params</dt><dd>pointer to node memory stats objects</dd><dt>nparams</dt><dd>number of node memory stats (this value should be same or less than the number of stats supported)</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success.</dd></dl><div class="acl"></div><h3><a name="virNodeGetSecurityModel" id="virNodeGetSecurityModel"><code>virNodeGetSecurityModel</code></a></h3><pre class="api"><span class="type">int</span>	virNodeGetSecurityModel		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virSecurityModelPtr">virSecurityModelPtr</a></span> secmodel)</pre><div class="description"><p>Extract the security model of a hypervisor. The 'model' field in the @secmodel argument may be initialized to the empty string if the driver has not activated a security model.</p></div><dl class="variablelist"><dt>conn</dt><dd>a connection object</dd><dt>secmodel</dt><dd>pointer to a <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> structure</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure</dd></dl><div class="acl"></div><h3><a name="virNodeListDevices" id="virNodeListDevices"><code>virNodeListDevices</code></a></h3><pre class="api"><span class="type">int</span>	virNodeListDevices		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> cap,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of node devices, and store their names in @names</p><p>For more control over the results, see <a href="libvirt-libvirt.html#virConnectListAllNodeDevices">virConnectListAllNodeDevices</a>().</p><p>If the optional 'cap' argument is non-NULL, then the count will be restricted to devices with the specified capability</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>cap</dt><dd>capability name</dd><dt>names</dt><dd>array to collect the list of node device names</dd><dt>maxnames</dt><dd>size of @names</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the number of node devices found or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virNodeNumOfDevices" id="virNodeNumOfDevices"><code>virNodeNumOfDevices</code></a></h3><pre class="api"><span class="type">int</span>	virNodeNumOfDevices		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> cap,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Provides the number of node devices.</p><p>If the optional 'cap' argument is non-NULL, then the count will be restricted to devices with the specified capability</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>cap</dt><dd>capability name</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the number of node devices or -1 in case of error</dd></dl><div class="acl"></div><h3><a name="virNodeSetMemoryParameters" id="virNodeSetMemoryParameters"><code>virNodeSetMemoryParameters</code></a></h3><pre class="api"><span class="type">int</span>	virNodeSetMemoryParameters	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Change all or a subset of the node memory tunables. The function fails if not all of the tunables are supported.</p><p>Note that it's not recommended to use this function while the outside tuning program is running (such as ksmtuned under Linux), as they could change the tunables in parallel, which could cause conflicts.</p><p>This function may require privileged access to the hypervisor.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>params</dt><dd>pointer to scheduler parameter objects</dd><dt>nparams</dt><dd>number of scheduler parameter objects (this value can be the same or less than the returned value nparams of <a href="libvirt-libvirt.html#virDomainGetSchedulerType">virDomainGetSchedulerType</a>)</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virNodeSuspendForDuration" id="virNodeSuspendForDuration"><code>virNodeSuspendForDuration</code></a></h3><pre class="api"><span class="type">int</span>	virNodeSuspendForDuration	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned int</span> target,
					 <span class="type">unsigned long long</span> duration,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Attempt to suspend the node (host machine) for the given duration of time in the specified state (Suspend-to-RAM, Suspend-to-Disk or Hybrid-Suspend). Schedule the node's Real-Time-Clock interrupt to resume the node after the duration is complete.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>target</dt><dd>the state to which the host must be suspended to, such as: <a href="libvirt-libvirt.html#VIR_NODE_SUSPEND_TARGET_MEM">VIR_NODE_SUSPEND_TARGET_MEM</a> (Suspend-to-RAM) <a href="libvirt-libvirt.html#VIR_NODE_SUSPEND_TARGET_DISK">VIR_NODE_SUSPEND_TARGET_DISK</a> (Suspend-to-Disk) <a href="libvirt-libvirt.html#VIR_NODE_SUSPEND_TARGET_HYBRID">VIR_NODE_SUSPEND_TARGET_HYBRID</a> (Hybrid-Suspend, which is a combination of the former modes).</dd><dt>duration</dt><dd>the time duration in seconds for which the host has to be suspended</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 on success (i.e., the node will be suspended after a short delay), -1 on failure (the operation is not supported, or an attempted suspend is already underway).</dd></dl><div class="acl"></div><h3><a name="virSecretDefineXML" id="virSecretDefineXML"><code>virSecretDefineXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span>	virSecretDefineXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const char *</span> xml,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>If XML specifies a UUID, locates the specified secret and replaces all attributes of the secret specified by UUID by attributes specified in xml (any attributes not specified in xml are discarded).</p><p>Otherwise, creates a new secret with an automatically chosen UUID, and initializes its attributes from xml.</p></div><dl class="variablelist"><dt>conn</dt><dd><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</dd><dt>xml</dt><dd>XML describing the secret.</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a the secret on success, NULL on failure.</dd></dl><div class="acl"></div><h3><a name="virSecretFree" id="virSecretFree"><code>virSecretFree</code></a></h3><pre class="api"><span class="type">int</span>	virSecretFree			(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)</pre><div class="description"><p>Release the secret handle. The underlying secret continues to exist.</p></div><dl class="variablelist"><dt>secret</dt><dd>pointer to a secret</dd><dt>Returns</dt><dd>0 on success, or -1 on error</dd></dl><div class="acl"></div><h3><a name="virSecretGetConnect" id="virSecretGetConnect"><code>virSecretGetConnect</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virSecretGetConnect	(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)</pre><div class="description"><p>Provides the connection pointer associated with a secret. The reference counter on the connection is not increased by this call.</p><p>WARNING: When writing libvirt bindings in other languages, do not use this function. Instead, store the connection and the secret object together.</p></div><dl class="variablelist"><dt>secret</dt><dd>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</dd><dt>Returns</dt><dd>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</dd></dl><div class="acl"></div><h3><a name="virSecretGetUUID" id="virSecretGetUUID"><code>virSecretGetUUID</code></a></h3><pre class="api"><span class="type">int</span>	virSecretGetUUID		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret,
					 <span class="type">unsigned char *</span> uuid)</pre><div class="description"><p>Fetches the UUID of the secret.</p></div><dl class="variablelist"><dt>secret</dt><dd>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</dd><dt>uuid</dt><dd>buffer of <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes in size</dd><dt>Returns</dt><dd>0 on success with the uuid buffer being filled, or -1 upon failure.</dd></dl><div class="acl"></div><h3><a name="virSecretGetUUIDString" id="virSecretGetUUIDString"><code>virSecretGetUUIDString</code></a></h3><pre class="api"><span class="type">int</span>	virSecretGetUUIDString		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret,
					 <span class="type">char *</span> buf)</pre><div class="description"><p>Get the UUID for a secret as string. For more information about UUID see RFC4122.</p></div><dl class="variablelist"><dt>secret</dt><dd>a secret object</dd><dt>buf</dt><dd>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</dd><dt>Returns</dt><dd>-1 in case of error, 0 in case of success</dd></dl><div class="acl"></div><h3><a name="virSecretGetUsageID" id="virSecretGetUsageID"><code>virSecretGetUsageID</code></a></h3><pre class="api"><span class="type">const char *</span>	virSecretGetUsageID	(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)</pre><div class="description"><p>Get the unique identifier of the object with which this secret is to be used. The format of the identifier is dependant on the usage type of the secret. For a secret with a usage type of <a href="libvirt-libvirt.html#VIR_SECRET_USAGE_TYPE_VOLUME">VIR_SECRET_USAGE_TYPE_VOLUME</a> the identifier will be a fully qualfied path name. The identifiers are intended to be unique within the set of all secrets sharing the same usage type. ie, there shall only ever be one secret for each volume path.</p></div><dl class="variablelist"><dt>secret</dt><dd>a secret object</dd><dt>Returns</dt><dd>a string identifying the object using the secret, or NULL upon error</dd></dl><div class="acl"></div><h3><a name="virSecretGetUsageType" id="virSecretGetUsageType"><code>virSecretGetUsageType</code></a></h3><pre class="api"><span class="type">int</span>	virSecretGetUsageType		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)</pre><div class="description"><p>Get the type of object which uses this secret. The returned value is one of the constants defined in the <a href="libvirt-libvirt.html#virSecretUsageType">virSecretUsageType</a> enumeration. More values may be added to this enumeration in the future, so callers should expect to see usage types they do not explicitly know about.</p></div><dl class="variablelist"><dt>secret</dt><dd>a secret object</dd><dt>Returns</dt><dd>a positive integer identifying the type of object, or -1 upon error.</dd></dl><div class="acl"></div><h3><a name="virSecretGetValue" id="virSecretGetValue"><code>virSecretGetValue</code></a></h3><pre class="api"><span class="type">unsigned char *</span>	virSecretGetValue	(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret,
					 <span class="type">size_t *</span> value_size,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Fetches the value of a secret.</p></div><dl class="variablelist"><dt>secret</dt><dd>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> connection</dd><dt>value_size</dt><dd>Place for storing size of the secret value</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the secret value on success, NULL on failure. The caller must free() the secret value.</dd></dl><div class="acl"></div><h3><a name="virSecretGetXMLDesc" id="virSecretGetXMLDesc"><code>virSecretGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virSecretGetXMLDesc		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Fetches an XML document describing attributes of the secret.</p></div><dl class="variablelist"><dt>secret</dt><dd>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the XML document on success, NULL on failure. The caller must free() the XML.</dd></dl><div class="acl"></div><h3><a name="virSecretLookupByUUID" id="virSecretLookupByUUID"><code>virSecretLookupByUUID</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span>	virSecretLookupByUUID	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">const unsigned char *</span> uuid)</pre><div class="description"><p>Try to lookup a secret on the given hypervisor based on its UUID. Uses the 16 bytes of raw data to describe the UUID</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>uuid</dt><dd>the raw UUID for the secret</dd><dt>Returns</dt><dd>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virSecretLookupByUUIDString" id="virSecretLookupByUUIDString"><code>virSecretLookupByUUIDString</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span>	virSecretLookupByUUIDString	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> uuidstr)</pre><div class="description"><p>Try to lookup a secret on the given hypervisor based on its UUID. Uses the printable string value to describe the UUID</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>uuidstr</dt><dd>the string UUID for the secret</dd><dt>Returns</dt><dd>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virSecretLookupByUsage" id="virSecretLookupByUsage"><code>virSecretLookupByUsage</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span>	virSecretLookupByUsage	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">int</span> usageType,
					 <span class="type">const char *</span> usageID)</pre><div class="description"><p>Try to lookup a secret on the given hypervisor based on its usage The usageID is unique within the set of secrets sharing the same usageType value.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the hypervisor connection</dd><dt>usageType</dt><dd>the type of secret usage</dd><dt>usageID</dt><dd>identifier of the object using the secret</dd><dt>Returns</dt><dd>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</dd></dl><div class="acl"></div><h3><a name="virSecretRef" id="virSecretRef"><code>virSecretRef</code></a></h3><pre class="api"><span class="type">int</span>	virSecretRef			(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)</pre><div class="description"><p>Increment the reference count on the secret. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virSecretFree">virSecretFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using a secret would increment the reference count.</p></div><dl class="variablelist"><dt>secret</dt><dd>the secret to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virSecretSetValue" id="virSecretSetValue"><code>virSecretSetValue</code></a></h3><pre class="api"><span class="type">int</span>	virSecretSetValue		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret,
					 <span class="type">const unsigned char *</span> value,
					 <span class="type">size_t</span> value_size,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Sets the value of a secret.</p></div><dl class="variablelist"><dt>secret</dt><dd>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</dd><dt>value</dt><dd>Value of the secret</dd><dt>value_size</dt><dd>Size of the value</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 on success, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virSecretUndefine" id="virSecretUndefine"><code>virSecretUndefine</code></a></h3><pre class="api"><span class="type">int</span>	virSecretUndefine		(<span class="type"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a></span> secret)</pre><div class="description"><p>Deletes the specified secret. This does not free the associated <a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> object.</p></div><dl class="variablelist"><dt>secret</dt><dd>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</dd><dt>Returns</dt><dd>0 on success, -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virStoragePoolBuild" id="virStoragePoolBuild"><code>virStoragePoolBuild</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolBuild		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Currently only filesystem pool accepts flags <a href="libvirt-libvirt.html#VIR_STORAGE_POOL_BUILD_OVERWRITE">VIR_STORAGE_POOL_BUILD_OVERWRITE</a> and <a href="libvirt-libvirt.html#VIR_STORAGE_POOL_BUILD_NO_OVERWRITE">VIR_STORAGE_POOL_BUILD_NO_OVERWRITE</a>.</p><p>Build the underlying storage pool</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virStoragePoolBuildFlags">virStoragePoolBuildFlags</a></dd><dt>Returns</dt><dd>0 on success, or -1 upon failure</dd></dl><div class="acl"></div><h3><a name="virStoragePoolCreate" id="virStoragePoolCreate"><code>virStoragePoolCreate</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolCreate		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Starts an inactive storage pool</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 on success, or -1 if it could not be started</dd></dl><div class="acl"></div><h3><a name="virStoragePoolCreateXML" id="virStoragePoolCreateXML"><code>virStoragePoolCreateXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	virStoragePoolCreateXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> xmlDesc,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Create a new storage based on its XML description. The pool is not persistent, so its definition will disappear when it is destroyed, or if the host is restarted</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>xmlDesc</dt><dd>XML description for new pool</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if creation failed</dd></dl><div class="acl"></div><h3><a name="virStoragePoolDefineXML" id="virStoragePoolDefineXML"><code>virStoragePoolDefineXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	virStoragePoolDefineXML	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
						 <span class="type">const char *</span> xml,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Define a new inactive storage pool based on its XML description. The pool is persistent, until explicitly undefined.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>xml</dt><dd>XML description for new pool</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if creation failed</dd></dl><div class="acl"></div><h3><a name="virStoragePoolDelete" id="virStoragePoolDelete"><code>virStoragePoolDelete</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolDelete		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Delete the underlying pool resources. This is a non-recoverable operation. The <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object itself is not free'd.</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virStoragePoolDeleteFlags">virStoragePoolDeleteFlags</a></dd><dt>Returns</dt><dd>0 on success, or -1 if it could not be obliterate</dd></dl><div class="acl"></div><h3><a name="virStoragePoolDestroy" id="virStoragePoolDestroy"><code>virStoragePoolDestroy</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolDestroy		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Destroy an active storage pool. This will deactivate the pool on the host, but keep any persistent config associated with it. If it has a persistent config it can later be restarted with <a href="libvirt-libvirt.html#virStoragePoolCreate">virStoragePoolCreate</a>(). This does not free the associated <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object.</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>Returns</dt><dd>0 on success, or -1 if it could not be destroyed</dd></dl><div class="acl"></div><h3><a name="virStoragePoolFree" id="virStoragePoolFree"><code>virStoragePoolFree</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolFree		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Free a storage pool object, releasing all memory associated with it. Does not change the state of the pool on the host.</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>Returns</dt><dd>0 on success, or -1 if it could not be free'd.</dd></dl><div class="acl"></div><h3><a name="virStoragePoolGetAutostart" id="virStoragePoolGetAutostart"><code>virStoragePoolGetAutostart</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolGetAutostart	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">int *</span> autostart)</pre><div class="description"><p>Fetches the value of the autostart flag, which determines whether the pool is automatically started at boot time</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>autostart</dt><dd>location in which to store autostart flag</dd><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virStoragePoolGetConnect" id="virStoragePoolGetConnect"><code>virStoragePoolGetConnect</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virStoragePoolGetConnect	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Provides the connection pointer associated with a storage pool. The reference counter on the connection is not increased by this call.</p><p>WARNING: When writing libvirt bindings in other languages, do not use this function. Instead, store the connection and the pool object together.</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to a pool</dd><dt>Returns</dt><dd>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</dd></dl><div class="acl"></div><h3><a name="virStoragePoolGetInfo" id="virStoragePoolGetInfo"><code>virStoragePoolGetInfo</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolGetInfo		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type"><a href="libvirt-libvirt.html#virStoragePoolInfoPtr">virStoragePoolInfoPtr</a></span> info)</pre><div class="description"><p>Get volatile information about the storage pool such as free space / usage summary</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>info</dt><dd>pointer at which to store info</dd><dt>Returns</dt><dd>0 on success, or -1 on failure.</dd></dl><div class="acl"></div><h3><a name="virStoragePoolGetName" id="virStoragePoolGetName"><code>virStoragePoolGetName</code></a></h3><pre class="api"><span class="type">const char *</span>	virStoragePoolGetName	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Fetch the locally unique name of the storage pool</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>Returns</dt><dd>the name of the pool, or NULL on error</dd></dl><div class="acl"></div><h3><a name="virStoragePoolGetUUID" id="virStoragePoolGetUUID"><code>virStoragePoolGetUUID</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolGetUUID		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">unsigned char *</span> uuid)</pre><div class="description"><p>Fetch the globally unique ID of the storage pool</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>uuid</dt><dd>buffer of <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes in size</dd><dt>Returns</dt><dd>0 on success, or -1 on error;</dd></dl><div class="acl"></div><h3><a name="virStoragePoolGetUUIDString" id="virStoragePoolGetUUIDString"><code>virStoragePoolGetUUIDString</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolGetUUIDString	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">char *</span> buf)</pre><div class="description"><p>Fetch the globally unique ID of the storage pool as a string</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>buf</dt><dd>buffer of <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes in size</dd><dt>Returns</dt><dd>0 on success, or -1 on error;</dd></dl><div class="acl"></div><h3><a name="virStoragePoolGetXMLDesc" id="virStoragePoolGetXMLDesc"><code>virStoragePoolGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virStoragePoolGetXMLDesc	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Fetch an XML document describing all aspects of the storage pool. This is suitable for later feeding back into the <a href="libvirt-libvirt.html#virStoragePoolCreateXML">virStoragePoolCreateXML</a> method.</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virStorageXMLFlags">virStorageXMLFlags</a></dd><dt>Returns</dt><dd>a XML document, or NULL on error</dd></dl><div class="acl"></div><h3><a name="virStoragePoolIsActive" id="virStoragePoolIsActive"><code>virStoragePoolIsActive</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolIsActive		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Determine if the storage pool is currently running</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to the storage pool object</dd><dt>Returns</dt><dd>1 if running, 0 if inactive, -1 on error</dd></dl><div class="acl"></div><h3><a name="virStoragePoolIsPersistent" id="virStoragePoolIsPersistent"><code>virStoragePoolIsPersistent</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolIsPersistent	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Determine if the storage pool has a persistent configuration which means it will still exist after shutting down</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to the storage pool object</dd><dt>Returns</dt><dd>1 if persistent, 0 if transient, -1 on error</dd></dl><div class="acl"></div><h3><a name="virStoragePoolListAllVolumes" id="virStoragePoolListAllVolumes"><code>virStoragePoolListAllVolumes</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolListAllVolumes	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> **</span> vols,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Collect the list of storage volumes, and allocate an array to store those objects.</p></div><dl class="variablelist"><dt>pool</dt><dd>Pointer to storage pool</dd><dt>vols</dt><dd>Pointer to a variable to store the array containing storage volume objects or NULL if the list is not required (just returns number of volumes).</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the number of storage volumes found or -1 and sets @vols to NULL in case of error. On success, the array stored into @vols is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling <a href="libvirt-libvirt.html#virStorageVolFree">virStorageVolFree</a>() on each array element, then calling free() on @vols.</dd></dl><div class="acl"></div><h3><a name="virStoragePoolListVolumes" id="virStoragePoolListVolumes"><code>virStoragePoolListVolumes</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolListVolumes	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">char ** const</span> names,
					 <span class="type">int</span> maxnames)</pre><div class="description"><p>Fetch list of storage volume names, limiting to at most maxnames.</p><p>To list the volume objects directly, see <a href="libvirt-libvirt.html#virStoragePoolListAllVolumes">virStoragePoolListAllVolumes</a>().</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>names</dt><dd>array in which to storage volume names</dd><dt>maxnames</dt><dd>size of names array</dd><dt>Returns</dt><dd>the number of names fetched, or -1 on error</dd></dl><div class="acl"></div><h3><a name="virStoragePoolLookupByName" id="virStoragePoolLookupByName"><code>virStoragePoolLookupByName</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	virStoragePoolLookupByName	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type">const char *</span> name)</pre><div class="description"><p>Fetch a storage pool based on its unique name</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>name</dt><dd>name of pool to fetch</dd><dt>Returns</dt><dd>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</dd></dl><div class="acl"></div><h3><a name="virStoragePoolLookupByUUID" id="virStoragePoolLookupByUUID"><code>virStoragePoolLookupByUUID</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	virStoragePoolLookupByUUID	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type">const unsigned char *</span> uuid)</pre><div class="description"><p>Fetch a storage pool based on its globally unique id</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>uuid</dt><dd>globally unique id of pool to fetch</dd><dt>Returns</dt><dd>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</dd></dl><div class="acl"></div><h3><a name="virStoragePoolLookupByUUIDString" id="virStoragePoolLookupByUUIDString"><code>virStoragePoolLookupByUUIDString</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	virStoragePoolLookupByUUIDString	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type">const char *</span> uuidstr)</pre><div class="description"><p>Fetch a storage pool based on its globally unique id</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>uuidstr</dt><dd>globally unique id of pool to fetch</dd><dt>Returns</dt><dd>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</dd></dl><div class="acl"></div><h3><a name="virStoragePoolLookupByVolume" id="virStoragePoolLookupByVolume"><code>virStoragePoolLookupByVolume</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span>	virStoragePoolLookupByVolume	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)</pre><div class="description"><p>Fetch a storage pool which contains a particular volume</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>Returns</dt><dd>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</dd></dl><div class="acl"></div><h3><a name="virStoragePoolNumOfVolumes" id="virStoragePoolNumOfVolumes"><code>virStoragePoolNumOfVolumes</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolNumOfVolumes	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Fetch the number of storage volumes within a pool</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>Returns</dt><dd>the number of storage pools, or -1 on failure</dd></dl><div class="acl"></div><h3><a name="virStoragePoolRef" id="virStoragePoolRef"><code>virStoragePoolRef</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolRef		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Increment the reference count on the pool. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virStoragePoolFree">virStoragePoolFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using a pool would increment the reference count.</p></div><dl class="variablelist"><dt>pool</dt><dd>the pool to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virStoragePoolRefresh" id="virStoragePoolRefresh"><code>virStoragePoolRefresh</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolRefresh		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Request that the pool refresh its list of volumes. This may involve communicating with a remote server, and/or initializing new devices at the OS layer</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 if the volume list was refreshed, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virStoragePoolSetAutostart" id="virStoragePoolSetAutostart"><code>virStoragePoolSetAutostart</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolSetAutostart	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
					 <span class="type">int</span> autostart)</pre><div class="description"><p>Sets the autostart flag</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>autostart</dt><dd>new flag setting</dd><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virStoragePoolUndefine" id="virStoragePoolUndefine"><code>virStoragePoolUndefine</code></a></h3><pre class="api"><span class="type">int</span>	virStoragePoolUndefine		(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool)</pre><div class="description"><p>Undefine an inactive storage pool</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl><div class="acl"></div><h3><a name="virStorageVolCreateXML" id="virStorageVolCreateXML"><code>virStorageVolCreateXML</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	virStorageVolCreateXML	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
						 <span class="type">const char *</span> xmlDesc,
						 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Create a storage volume within a pool based on an XML description. Not all pools support creation of volumes.</p><p>Since 1.0.1 <a href="libvirt-libvirt.html#VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA">VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA</a> in flags can be used to get higher performance with qcow2 image files which don't support full preallocation, by creating a sparse image file with metadata.</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>xmlDesc</dt><dd>description of volume to create</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virStorageVolCreateFlags">virStorageVolCreateFlags</a></dd><dt>Returns</dt><dd>the storage volume, or NULL on error</dd></dl><div class="acl"></div><h3><a name="virStorageVolCreateXMLFrom" id="virStorageVolCreateXMLFrom"><code>virStorageVolCreateXMLFrom</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	virStorageVolCreateXMLFrom	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
							 <span class="type">const char *</span> xmlDesc,
							 <span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> clonevol,
							 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Create a storage volume in the parent pool, using the 'clonevol' volume as input. Information for the new volume (name, perms) are passed via a typical volume XML description.</p><p>Since 1.0.1 <a href="libvirt-libvirt.html#VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA">VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA</a> in flags can be used to get higher performance with qcow2 image files which don't support full preallocation, by creating a sparse image file with metadata.</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to parent pool for the new volume</dd><dt>xmlDesc</dt><dd>description of volume to create</dd><dt>clonevol</dt><dd>storage volume to use as input</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virStorageVolCreateFlags">virStorageVolCreateFlags</a></dd><dt>Returns</dt><dd>the storage volume, or NULL on error</dd></dl><div class="acl"></div><h3><a name="virStorageVolDelete" id="virStorageVolDelete"><code>virStorageVolDelete</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolDelete		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Delete the storage volume from the pool</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 on success, or -1 on error</dd></dl><div class="acl"></div><h3><a name="virStorageVolDownload" id="virStorageVolDownload"><code>virStorageVolDownload</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolDownload		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol,
					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">unsigned long long</span> offset,
					 <span class="type">unsigned long long</span> length,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Download the content of the volume as a stream. If @length is zero, then the remaining contents of the volume after @offset will be downloaded.</p><p>This call sets up an asynchronous stream; subsequent use of stream APIs is necessary to transfer the actual data, determine how much data is successfully transferred, and detect any errors. The results will be unpredictable if another active stream is writing to the storage volume.</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to volume to download from</dd><dt>stream</dt><dd>stream to use as output</dd><dt>offset</dt><dd>position in @vol to start reading from</dd><dt>length</dt><dd>limit on amount of data to download</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0, or -1 upon error.</dd></dl><div class="acl"></div><h3><a name="virStorageVolFree" id="virStorageVolFree"><code>virStorageVolFree</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolFree		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)</pre><div class="description"><p>Release the storage volume handle. The underlying storage volume continues to exist.</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>Returns</dt><dd>0 on success, or -1 on error</dd></dl><div class="acl"></div><h3><a name="virStorageVolGetConnect" id="virStorageVolGetConnect"><code>virStorageVolGetConnect</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span>	virStorageVolGetConnect	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)</pre><div class="description"><p>Provides the connection pointer associated with a storage volume. The reference counter on the connection is not increased by this call.</p><p>WARNING: When writing libvirt bindings in other languages, do not use this function. Instead, store the connection and the volume object together.</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to a pool</dd><dt>Returns</dt><dd>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</dd></dl><div class="acl"></div><h3><a name="virStorageVolGetInfo" id="virStorageVolGetInfo"><code>virStorageVolGetInfo</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolGetInfo		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol,
					 <span class="type"><a href="libvirt-libvirt.html#virStorageVolInfoPtr">virStorageVolInfoPtr</a></span> info)</pre><div class="description"><p>Fetches volatile information about the storage volume such as its current allocation</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>info</dt><dd>pointer at which to store info</dd><dt>Returns</dt><dd>0 on success, or -1 on failure</dd></dl><div class="acl"></div><h3><a name="virStorageVolGetKey" id="virStorageVolGetKey"><code>virStorageVolGetKey</code></a></h3><pre class="api"><span class="type">const char *</span>	virStorageVolGetKey	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)</pre><div class="description"><p>Fetch the storage volume key. This is globally unique, so the same volume will have the same key no matter what host it is accessed from</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>Returns</dt><dd>the volume key, or NULL on error</dd></dl><div class="acl"></div><h3><a name="virStorageVolGetName" id="virStorageVolGetName"><code>virStorageVolGetName</code></a></h3><pre class="api"><span class="type">const char *</span>	virStorageVolGetName	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)</pre><div class="description"><p>Fetch the storage volume name. This is unique within the scope of a pool</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>Returns</dt><dd>the volume name, or NULL on error</dd></dl><div class="acl"></div><h3><a name="virStorageVolGetPath" id="virStorageVolGetPath"><code>virStorageVolGetPath</code></a></h3><pre class="api"><span class="type">char *</span>	virStorageVolGetPath		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)</pre><div class="description"><p>Fetch the storage volume path. Depending on the pool configuration this is either persistent across hosts, or dynamically assigned at pool startup. Consult pool documentation for information on getting the persistent naming</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>Returns</dt><dd>the storage volume path, or NULL on error. The caller must free() the returned path after use.</dd></dl><div class="acl"></div><h3><a name="virStorageVolGetXMLDesc" id="virStorageVolGetXMLDesc"><code>virStorageVolGetXMLDesc</code></a></h3><pre class="api"><span class="type">char *</span>	virStorageVolGetXMLDesc		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Fetch an XML document describing all aspects of the storage volume</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>the XML document, or NULL on error</dd></dl><div class="acl"></div><h3><a name="virStorageVolLookupByKey" id="virStorageVolLookupByKey"><code>virStorageVolLookupByKey</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	virStorageVolLookupByKey	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type">const char *</span> key)</pre><div class="description"><p>Fetch a pointer to a storage volume based on its globally unique key</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>key</dt><dd>globally unique key</dd><dt>Returns</dt><dd>a storage volume, or NULL if not found / error</dd></dl><div class="acl"></div><h3><a name="virStorageVolLookupByName" id="virStorageVolLookupByName"><code>virStorageVolLookupByName</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	virStorageVolLookupByName	(<span class="type"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a></span> pool,
							 <span class="type">const char *</span> name)</pre><div class="description"><p>Fetch a pointer to a storage volume based on its name within a pool</p></div><dl class="variablelist"><dt>pool</dt><dd>pointer to storage pool</dd><dt>name</dt><dd>name of storage volume</dd><dt>Returns</dt><dd>a storage volume, or NULL if not found / error</dd></dl><div class="acl"></div><h3><a name="virStorageVolLookupByPath" id="virStorageVolLookupByPath"><code>virStorageVolLookupByPath</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span>	virStorageVolLookupByPath	(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
							 <span class="type">const char *</span> path)</pre><div class="description"><p>Fetch a pointer to a storage volume based on its locally (host) unique path</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to hypervisor connection</dd><dt>path</dt><dd>locally unique path</dd><dt>Returns</dt><dd>a storage volume, or NULL if not found / error</dd></dl><div class="acl"></div><h3><a name="virStorageVolRef" id="virStorageVolRef"><code>virStorageVolRef</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolRef		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol)</pre><div class="description"><p>Increment the reference count on the vol. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virStorageVolFree">virStorageVolFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p><p>This method is typically useful for applications where multiple threads are using a connection, and it is required that the connection remain open until all threads have finished using it. ie, each new thread using a vol would increment the reference count.</p></div><dl class="variablelist"><dt>vol</dt><dd>the vol to hold a reference on</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure.</dd></dl><div class="acl"></div><h3><a name="virStorageVolResize" id="virStorageVolResize"><code>virStorageVolResize</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolResize		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol,
					 <span class="type">unsigned long long</span> capacity,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Changes the capacity of the storage volume @vol to @capacity. The operation will fail if the new capacity requires allocation that would exceed the remaining free space in the parent pool. The contents of the new capacity will appear as all zero bytes. The capacity value will be rounded to the granularity supported by the hypervisor.</p><p>Normally, the operation will attempt to affect capacity with a minimum impact on allocation (that is, the default operation favors a sparse resize). If @flags contains <a href="libvirt-libvirt.html#VIR_STORAGE_VOL_RESIZE_ALLOCATE">VIR_STORAGE_VOL_RESIZE_ALLOCATE</a>, then the operation will ensure that allocation is sufficient for the new capacity; this may make the operation take noticeably longer.</p><p>Normally, the operation treats @capacity as the new size in bytes; but if @flags contains <a href="libvirt-libvirt.html#VIR_STORAGE_VOL_RESIZE_DELTA">VIR_STORAGE_VOL_RESIZE_DELTA</a>, then @capacity represents the size difference to add to the current size. It is up to the storage pool implementation whether unaligned requests are rounded up to the next valid boundary, or rejected.</p><p>Normally, this operation should only be used to enlarge capacity; but if @flags contains <a href="libvirt-libvirt.html#VIR_STORAGE_VOL_RESIZE_SHRINK">VIR_STORAGE_VOL_RESIZE_SHRINK</a>, it is possible to attempt a reduction in capacity even though it might cause data loss. If <a href="libvirt-libvirt.html#VIR_STORAGE_VOL_RESIZE_DELTA">VIR_STORAGE_VOL_RESIZE_DELTA</a> is also present, then @capacity is subtracted from the current size; without it, @capacity represents the absolute new size regardless of whether it is larger or smaller than the current size.</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>capacity</dt><dd>new capacity, in bytes</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virStorageVolResizeFlags">virStorageVolResizeFlags</a></dd><dt>Returns</dt><dd>0 on success, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virStorageVolUpload" id="virStorageVolUpload"><code>virStorageVolUpload</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolUpload		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol,
					 <span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">unsigned long long</span> offset,
					 <span class="type">unsigned long long</span> length,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Upload new content to the volume from a stream. This call will fail if @offset + @length exceeds the size of the volume. Otherwise, if @length is non-zero, an error will be raised if an attempt is made to upload greater than @length bytes of data.</p><p>This call sets up an asynchronous stream; subsequent use of stream APIs is necessary to transfer the actual data, determine how much data is successfully transferred, and detect any errors. The results will be unpredictable if another active stream is writing to the storage volume.</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to volume to upload</dd><dt>stream</dt><dd>stream to use as input</dd><dt>offset</dt><dd>position to start writing to</dd><dt>length</dt><dd>limit on amount of data to upload</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0, or -1 upon error.</dd></dl><div class="acl"></div><h3><a name="virStorageVolWipe" id="virStorageVolWipe"><code>virStorageVolWipe</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolWipe		(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Ensure data previously on a volume is not accessible to future reads</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>flags</dt><dd>extra flags; not used yet, so callers should always pass 0</dd><dt>Returns</dt><dd>0 on success, or -1 on error</dd></dl><div class="acl"></div><h3><a name="virStorageVolWipePattern" id="virStorageVolWipePattern"><code>virStorageVolWipePattern</code></a></h3><pre class="api"><span class="type">int</span>	virStorageVolWipePattern	(<span class="type"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a></span> vol,
					 <span class="type">unsigned int</span> algorithm,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Similar to <a href="libvirt-libvirt.html#virStorageVolWipe">virStorageVolWipe</a>, but one can choose between different wiping algorithms.</p></div><dl class="variablelist"><dt>vol</dt><dd>pointer to storage volume</dd><dt>algorithm</dt><dd>one of <a href="libvirt-libvirt.html#virStorageVolWipeAlgorithm">virStorageVolWipeAlgorithm</a></dd><dt>flags</dt><dd>future flags, use 0 for now</dd><dt>Returns</dt><dd>0 on success, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virStreamAbort" id="virStreamAbort"><code>virStreamAbort</code></a></h3><pre class="api"><span class="type">int</span>	virStreamAbort			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)</pre><div class="description"><p>Request that the in progress data transfer be cancelled abnormally before the end of the stream has been reached. For output streams this can be used to inform the driver that the stream is being terminated early. For input streams this can be used to inform the driver that it should stop sending data.</p></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>Returns</dt><dd>0 on success, -1 upon error</dd></dl><div class="acl"></div><h3><a name="virStreamEventAddCallback" id="virStreamEventAddCallback"><code>virStreamEventAddCallback</code></a></h3><pre class="api"><span class="type">int</span>	virStreamEventAddCallback	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">int</span> events,
					 <span class="type"><a href="libvirt-libvirt.html#virStreamEventCallback">virStreamEventCallback</a></span> cb,
					 <span class="type">void *</span> opaque,
					 <span class="type"><a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a></span> ff)</pre><div class="description"><p>Register a callback to be notified when a stream becomes writable, or readable. This is most commonly used in conjunction with non-blocking data streams to integrate into an event loop</p></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>events</dt><dd>set of events to monitor</dd><dt>cb</dt><dd>callback to invoke when an event occurs</dd><dt>opaque</dt><dd>application defined data</dd><dt>ff</dt><dd>callback to free @opaque data</dd><dt>Returns</dt><dd>0 on success, -1 upon error</dd></dl><div class="acl"></div><h3><a name="virStreamEventCallback" id="virStreamEventCallback"><code>virStreamEventCallback</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virStreamEventCallback	)	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">int</span> events,
					 <span class="type">void *</span> opaque)
</pre><div class="description"><p>Callback for receiving stream events. The callback will be invoked once for each event which is pending.</p></div><dl class="variablelist"><dt>stream</dt><dd>stream on which the event occurred</dd><dt>events</dt><dd>bitset of events from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</dd><dt>opaque</dt><dd>user data registered with handle</dd></dl><br /><h3><a name="virStreamEventRemoveCallback" id="virStreamEventRemoveCallback"><code>virStreamEventRemoveCallback</code></a></h3><pre class="api"><span class="type">int</span>	virStreamEventRemoveCallback	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)</pre><div class="description"><p>Remove an event callback from the stream</p></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>Returns</dt><dd>0 on success, -1 on error</dd></dl><div class="acl"></div><h3><a name="virStreamEventUpdateCallback" id="virStreamEventUpdateCallback"><code>virStreamEventUpdateCallback</code></a></h3><pre class="api"><span class="type">int</span>	virStreamEventUpdateCallback	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">int</span> events)</pre><div class="description"><p>Changes the set of events to monitor for a stream. This allows for event notification to be changed without having to unregister &amp; register the callback completely. This method is guaranteed to succeed if a callback is already registered</p></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>events</dt><dd>set of events to monitor</dd><dt>Returns</dt><dd>0 on success, -1 if no callback is registered</dd></dl><div class="acl"></div><h3><a name="virStreamFinish" id="virStreamFinish"><code>virStreamFinish</code></a></h3><pre class="api"><span class="type">int</span>	virStreamFinish			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)</pre><div class="description"><p>Indicate that there is no further data is to be transmitted on the stream. For output streams this should be called once all data has been written. For input streams this should be called once <a href="libvirt-libvirt.html#virStreamRecv">virStreamRecv</a> returns end-of-file.</p><p>This method is a synchronization point for all asynchronous errors, so if this returns a success code the application can be sure that all data has been successfully processed.</p></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>Returns</dt><dd>0 on success, -1 upon error</dd></dl><div class="acl"></div><h3><a name="virStreamFree" id="virStreamFree"><code>virStreamFree</code></a></h3><pre class="api"><span class="type">int</span>	virStreamFree			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)</pre><div class="description"><p>Decrement the reference count on a stream, releasing the stream object if the reference count has hit zero.</p><p>There must not be an active data transfer in progress when releasing the stream. If a stream needs to be disposed of prior to end of stream being reached, then the <a href="libvirt-libvirt.html#virStreamAbort">virStreamAbort</a> function should be called first.</p></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>Returns</dt><dd>0 upon success, or -1 on error</dd></dl><div class="acl"></div><h3><a name="virStreamNew" id="virStreamNew"><code>virStreamNew</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span>	virStreamNew		(<span class="type"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned int</span> flags)</pre><div class="description"><p>Creates a new stream object which can be used to perform streamed I/O with other public API function.</p><p>When no longer needed, a stream object must be released with <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a>. If a data stream has been used, then the application must call <a href="libvirt-libvirt.html#virStreamFinish">virStreamFinish</a> or <a href="libvirt-libvirt.html#virStreamAbort">virStreamAbort</a> before free'ing to, in order to notify the driver of termination.</p><p>If a non-blocking data stream is required passed <a href="libvirt-libvirt.html#VIR_STREAM_NONBLOCK">VIR_STREAM_NONBLOCK</a> for flags, otherwise pass 0.</p></div><dl class="variablelist"><dt>conn</dt><dd>pointer to the connection</dd><dt>flags</dt><dd>bitwise-OR of <a href="libvirt-libvirt.html#virStreamFlags">virStreamFlags</a></dd><dt>Returns</dt><dd>the new stream, or NULL upon error</dd></dl><div class="acl"></div><h3><a name="virStreamRecv" id="virStreamRecv"><code>virStreamRecv</code></a></h3><pre class="api"><span class="type">int</span>	virStreamRecv			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">char *</span> data,
					 <span class="type">size_t</span> nbytes)</pre><div class="description"><p>Reads a series of bytes from the stream. This method may block the calling application for an arbitrary amount of time.</p><p>Errors are not guaranteed to be reported synchronously with the call, but may instead be delayed until a subsequent call.</p><p>An example using this with a hypothetical file download API looks like</p><pre class="code">  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_WRONLY, 0600)

  virConnectDownloadFile(conn, "demo.iso", st);

  while (1) {
      char buf[1024];
      int got = virStreamRecv(st, buf, 1024);
      if (got &lt; 0)
         break;
      if (got == 0) {
         virStreamFinish(st);
         break;
      }
      int offset = 0;
      while (offset &lt; got) {
         int sent = write(fd, buf+offset, got-offset)
         if (sent &lt; 0) {
            virStreamAbort(st);
            goto done;
         }
         offset += sent;
      }
  }
  if (virStreamFinish(st) &lt; 0)
     ... report an error ....
done:
  virStreamFree(st);
  close(fd);</pre></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>data</dt><dd>buffer to read into from stream</dd><dt>nbytes</dt><dd>size of @data buffer</dd><dt>Returns</dt><dd>the number of bytes read, which may be less than requested. Returns 0 when the end of the stream is reached, at which time the caller should invoke <a href="libvirt-libvirt.html#virStreamFinish">virStreamFinish</a>() to get confirmation of stream completion. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a>. Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking.</dd></dl><div class="acl"></div><h3><a name="virStreamRecvAll" id="virStreamRecvAll"><code>virStreamRecvAll</code></a></h3><pre class="api"><span class="type">int</span>	virStreamRecvAll		(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type"><a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a></span> handler,
					 <span class="type">void *</span> opaque)</pre><div class="description"><p>Receive the entire data stream, sending the data to the requested data sink. This is simply a convenient alternative to <a href="libvirt-libvirt.html#virStreamRecv">virStreamRecv</a>, for apps that do blocking-I/o.</p><p>An example using this with a hypothetical file download API looks like</p><pre class="code">int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
    int *fd = opaque;

    return write(*fd, buf, nbytes);
}

virStreamPtr st = virStreamNew(conn, 0);
int fd = open("demo.iso", O_WRONLY)

virConnectUploadFile(conn, st);
if (virStreamRecvAll(st, mysink, &amp;fd) &lt; 0) {
   ...report an error ...
   goto done;
}
if (virStreamFinish(st) &lt; 0)
   ...report an error...
virStreamFree(st);
close(fd);</pre></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>handler</dt><dd>sink callback for writing data to application</dd><dt>opaque</dt><dd>application defined data</dd><dt>Returns</dt><dd>0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with <a href="libvirt-libvirt.html#virStreamAbort">virStreamAbort</a>() already having been called, so the caller need only call <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a>()</dd></dl><div class="acl"></div><h3><a name="virStreamRef" id="virStreamRef"><code>virStreamRef</code></a></h3><pre class="api"><span class="type">int</span>	virStreamRef			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream)</pre><div class="description"><p>Increment the reference count on the stream. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream</dd><dt>Returns</dt><dd>0 in case of success, -1 in case of failure</dd></dl><div class="acl"></div><h3><a name="virStreamSend" id="virStreamSend"><code>virStreamSend</code></a></h3><pre class="api"><span class="type">int</span>	virStreamSend			(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">const char *</span> data,
					 <span class="type">size_t</span> nbytes)</pre><div class="description"><p>Write a series of bytes to the stream. This method may block the calling application for an arbitrary amount of time. Once an application has finished sending data it should call <a href="libvirt-libvirt.html#virStreamFinish">virStreamFinish</a> to wait for successful confirmation from the driver, or detect any error.</p><p>This method may not be used if a stream source has been registered.</p><p>Errors are not guaranteed to be reported synchronously with the call, but may instead be delayed until a subsequent call.</p><p>An example using this with a hypothetical file upload API looks like</p><pre class="code">  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_RDONLY)

  virConnectUploadFile(conn, "demo.iso", st);

  while (1) {
       char buf[1024];
       int got = read(fd, buf, 1024);
       if (got &lt; 0) {
          virStreamAbort(st);
          break;
       }
       if (got == 0) {
          virStreamFinish(st);
          break;
       }
       int offset = 0;
       while (offset &lt; got) {
          int sent = virStreamSend(st, buf+offset, got-offset)
          if (sent &lt; 0) {
             virStreamAbort(st);
             goto done;
          }
          offset += sent;
       }
   }
   if (virStreamFinish(st) &lt; 0)
      ... report an error ....
 done:
   virStreamFree(st);
   close(fd);</pre></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>data</dt><dd>buffer to write to stream</dd><dt>nbytes</dt><dd>size of @data buffer</dd><dt>Returns</dt><dd>the number of bytes written, which may be less than requested. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a>. Returns -2 if the outgoing transmit buffers are full &amp; the stream is marked as non-blocking.</dd></dl><div class="acl"></div><h3><a name="virStreamSendAll" id="virStreamSendAll"><code>virStreamSendAll</code></a></h3><pre class="api"><span class="type">int</span>	virStreamSendAll		(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type"><a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a></span> handler,
					 <span class="type">void *</span> opaque)</pre><div class="description"><p>Send the entire data stream, reading the data from the requested data source. This is simply a convenient alternative to <a href="libvirt-libvirt.html#virStreamSend">virStreamSend</a>, for apps that do blocking-I/o.</p><p>An example using this with a hypothetical file upload API looks like</p><pre class="code">int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
    int *fd = opaque;

    return read(*fd, buf, nbytes);
}

virStreamPtr st = virStreamNew(conn, 0);
int fd = open("demo.iso", O_RDONLY)

virConnectUploadFile(conn, st);
if (virStreamSendAll(st, mysource, &amp;fd) &lt; 0) {
   ...report an error ...
   goto done;
}
if (virStreamFinish(st) &lt; 0)
   ...report an error...
virStreamFree(st);
close(fd);</pre></div><dl class="variablelist"><dt>stream</dt><dd>pointer to the stream object</dd><dt>handler</dt><dd>source callback for reading data from application</dd><dt>opaque</dt><dd>application defined data</dd><dt>Returns</dt><dd>0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with <a href="libvirt-libvirt.html#virStreamAbort">virStreamAbort</a>() already having been called, so the caller need only call <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a>()</dd></dl><div class="acl"></div><h3><a name="virStreamSinkFunc" id="virStreamSinkFunc"><code>virStreamSinkFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virStreamSinkFunc	)	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">const char *</span> data,
					 <span class="type">size_t</span> nbytes,
					 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The <a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a> callback is used together with the <a href="libvirt-libvirt.html#virStreamRecvAll">virStreamRecvAll</a> function for libvirt to provide the data that has been received.</p><p>The callback will be invoked multiple times, providing data in small chunks. The application should consume up 'nbytes' from the 'data' array of data and then return the number actual number of bytes consumed. The callback will continue to be invoked until it indicates the end of the stream has been reached. A return value of -1 at any time will abort the receive operation</p></div><dl class="variablelist"><dt>st</dt><dd>the stream object</dd><dt>data</dt><dd>preallocated array to be filled with data</dd><dt>nbytes</dt><dd>size of the data array</dd><dt>opaque</dt><dd>optional application provided data</dd><dt>Returns</dt><dd>the number of bytes consumed or -1 upon error</dd></dl><br /><h3><a name="virStreamSourceFunc" id="virStreamSourceFunc"><code>virStreamSourceFunc</code></a></h3><pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virStreamSourceFunc	)	(<span class="type"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">char *</span> data,
					 <span class="type">size_t</span> nbytes,
					 <span class="type">void *</span> opaque)
</pre><div class="description"><p>The <a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a> callback is used together with the <a href="libvirt-libvirt.html#virStreamSendAll">virStreamSendAll</a> function for libvirt to obtain the data that is to be sent.</p><p>The callback will be invoked multiple times, fetching data in small chunks. The application should fill the 'data' array with up to 'nbytes' of data and then return the number actual number of bytes. The callback will continue to be invoked until it indicates the end of the source has been reached by returning 0. A return value of -1 at any time will abort the send operation</p></div><dl class="variablelist"><dt>st</dt><dd>the stream object</dd><dt>data</dt><dd>preallocated array to be filled with data</dd><dt>nbytes</dt><dd>size of the data array</dd><dt>opaque</dt><dd>optional application provided data</dd><dt>Returns</dt><dd>the number of bytes filled, 0 upon end of file, or -1 upon error</dd></dl><br /><h3><a name="virTypedParamsAddBoolean" id="virTypedParamsAddBoolean"><code>virTypedParamsAddBoolean</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsAddBoolean	(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">int *</span> maxparams,
					 <span class="type">const char *</span> name,
					 <span class="type">int</span> value)</pre><div class="description"><p>Adds new parameter called @name with boolean type and sets its value to @value. If @params array points to NULL or to a space that is not large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the function allocates more space for it and updates @maxparams. On success, @nparams is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already exists in @params.</p></div><dl class="variablelist"><dt>params</dt><dd>pointer to the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>maxparams</dt><dd>maximum number of parameters that can be stored in @params array without allocating more memory</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>the value to store into the new parameter</dd><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsAddDouble" id="virTypedParamsAddDouble"><code>virTypedParamsAddDouble</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsAddDouble		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">int *</span> maxparams,
					 <span class="type">const char *</span> name,
					 <span class="type">double</span> value)</pre><div class="description"><p>Adds new parameter called @name with double type and sets its value to @value. If @params array points to NULL or to a space that is not large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the function allocates more space for it and updates @maxparams. On success, @nparams is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already exists in @params.</p></div><dl class="variablelist"><dt>params</dt><dd>pointer to the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>maxparams</dt><dd>maximum number of parameters that can be stored in @params array without allocating more memory</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>the value to store into the new parameter</dd><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsAddFromString" id="virTypedParamsAddFromString"><code>virTypedParamsAddFromString</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsAddFromString	(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">int *</span> maxparams,
					 <span class="type">const char *</span> name,
					 <span class="type">int</span> type,
					 <span class="type">const char *</span> value)</pre><div class="description"><p>Adds new parameter called @name with the requested @type and parses its value from the @value string. If the requested type is string, the function creates its own copy of the @value string, which needs to be freed using <a href="libvirt-libvirt.html#virTypedParamsFree">virTypedParamsFree</a> or <a href="libvirt-libvirt.html#virTypedParamsClear">virTypedParamsClear</a>. If @params array points to NULL or to a space that is not large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the function allocates more space for it and updates @maxparams. On success, @nparams is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already exists in @params.</p></div><dl class="variablelist"><dt>params</dt><dd>pointer to the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>maxparams</dt><dd>maximum number of parameters that can be stored in @params array without allocating more memory</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>type</dt><dd>type of the parameter</dd><dt>value</dt><dd>the value to store into the new parameter encoded as a string</dd><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsAddInt" id="virTypedParamsAddInt"><code>virTypedParamsAddInt</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsAddInt		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">int *</span> maxparams,
					 <span class="type">const char *</span> name,
					 <span class="type">int</span> value)</pre><div class="description"><p>Adds new parameter called @name with int type and sets its value to @value. If @params array points to NULL or to a space that is not large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the function allocates more space for it and updates @maxparams. On success, @nparams is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already exists in @params.</p></div><dl class="variablelist"><dt>params</dt><dd>pointer to the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>maxparams</dt><dd>maximum number of parameters that can be stored in @params array without allocating more memory</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>the value to store into the new parameter</dd><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsAddLLong" id="virTypedParamsAddLLong"><code>virTypedParamsAddLLong</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsAddLLong		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">int *</span> maxparams,
					 <span class="type">const char *</span> name,
					 <span class="type">long long</span> value)</pre><div class="description"><p>Adds new parameter called @name with long long int type and sets its value to @value. If @params array points to NULL or to a space that is not large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the function allocates more space for it and updates @maxparams. On success, @nparams is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already exists in @params.</p></div><dl class="variablelist"><dt>params</dt><dd>pointer to the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>maxparams</dt><dd>maximum number of parameters that can be stored in @params array without allocating more memory</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>the value to store into the new parameter</dd><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsAddString" id="virTypedParamsAddString"><code>virTypedParamsAddString</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsAddString		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">int *</span> maxparams,
					 <span class="type">const char *</span> name,
					 <span class="type">const char *</span> value)</pre><div class="description"><p>Adds new parameter called @name with char * type and sets its value to @value. The function creates its own copy of @value string, which needs to be freed using <a href="libvirt-libvirt.html#virTypedParamsFree">virTypedParamsFree</a> or <a href="libvirt-libvirt.html#virTypedParamsClear">virTypedParamsClear</a>. If @params array points to NULL or to a space that is not large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the function allocates more space for it and updates @maxparams. On success, @nparams is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already exists in @params.</p></div><dl class="variablelist"><dt>params</dt><dd>pointer to the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>maxparams</dt><dd>maximum number of parameters that can be stored in @params array without allocating more memory</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>the value to store into the new parameter</dd><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsAddUInt" id="virTypedParamsAddUInt"><code>virTypedParamsAddUInt</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsAddUInt		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">int *</span> maxparams,
					 <span class="type">const char *</span> name,
					 <span class="type">unsigned int</span> value)</pre><div class="description"><p>Adds new parameter called @name with unsigned int type and sets its value to @value. If @params array points to NULL or to a space that is not large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the function allocates more space for it and updates @maxparams. On success, @nparams is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already exists in @params.</p></div><dl class="variablelist"><dt>params</dt><dd>pointer to the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>maxparams</dt><dd>maximum number of parameters that can be stored in @params array without allocating more memory</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>the value to store into the new parameter</dd><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsAddULLong" id="virTypedParamsAddULLong"><code>virTypedParamsAddULLong</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsAddULLong		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a> *</span> params,
					 <span class="type">int *</span> nparams,
					 <span class="type">int *</span> maxparams,
					 <span class="type">const char *</span> name,
					 <span class="type">unsigned long long</span> value)</pre><div class="description"><p>Adds new parameter called @name with unsigned long long type and sets its value to @value. If @params array points to NULL or to a space that is not large enough to accommodate the new parameter (@maxparams &lt; @nparams + 1), the function allocates more space for it and updates @maxparams. On success, @nparams is incremented by one. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter already exists in @params.</p></div><dl class="variablelist"><dt>params</dt><dd>pointer to the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>maxparams</dt><dd>maximum number of parameters that can be stored in @params array without allocating more memory</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>the value to store into the new parameter</dd><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsClear" id="virTypedParamsClear"><code>virTypedParamsClear</code></a></h3><pre class="api"><span class="type">void</span>	virTypedParamsClear		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams)</pre><div class="description"><p>Frees all memory used by string parameters. The memory occupied by @params is not freed; use <a href="libvirt-libvirt.html#virTypedParamsFree">virTypedParamsFree</a> if you want it to be freed too.</p></div><dl class="variablelist"><dt>params</dt><dd>the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd></dl><div class="acl"></div><h3><a name="virTypedParamsFree" id="virTypedParamsFree"><code>virTypedParamsFree</code></a></h3><pre class="api"><span class="type">void</span>	virTypedParamsFree		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams)</pre><div class="description"><p>Frees all memory used by string parameters and the memory occupied by @params.</p></div><dl class="variablelist"><dt>params</dt><dd>the array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd></dl><div class="acl"></div><h3><a name="virTypedParamsGet" id="virTypedParamsGet"><code>virTypedParamsGet</code></a></h3><pre class="api"><span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span>	virTypedParamsGet	(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
						 <span class="type">int</span> nparams,
						 <span class="type">const char *</span> name)</pre><div class="description"><p>Finds typed parameter called @name.</p></div><dl class="variablelist"><dt>params</dt><dd>array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>Returns</dt><dd>pointer to the parameter or NULL if it does not exist in @params.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsGetBoolean" id="virTypedParamsGetBoolean"><code>virTypedParamsGetBoolean</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsGetBoolean	(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">const char *</span> name,
					 <span class="type">int *</span> value)</pre><div class="description"><p>Finds typed parameter called @name and store its boolean value in @value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not have the expected type. By passing NULL as @value, the function may be used to check presence and type of the parameter.</p></div><dl class="variablelist"><dt>params</dt><dd>array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>where to store the parameter's value</dd><dt>Returns</dt><dd>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsGetDouble" id="virTypedParamsGetDouble"><code>virTypedParamsGetDouble</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsGetDouble		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">const char *</span> name,
					 <span class="type">double *</span> value)</pre><div class="description"><p>Finds typed parameter called @name and store its double value in @value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not have the expected type. By passing NULL as @value, the function may be used to check presence and type of the parameter.</p></div><dl class="variablelist"><dt>params</dt><dd>array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>where to store the parameter's value</dd><dt>Returns</dt><dd>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsGetInt" id="virTypedParamsGetInt"><code>virTypedParamsGetInt</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsGetInt		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">const char *</span> name,
					 <span class="type">int *</span> value)</pre><div class="description"><p>Finds typed parameter called @name and store its int value in @value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not have the expected type. By passing NULL as @value, the function may be used to check presence and type of the parameter.</p></div><dl class="variablelist"><dt>params</dt><dd>array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>where to store the parameter's value</dd><dt>Returns</dt><dd>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsGetLLong" id="virTypedParamsGetLLong"><code>virTypedParamsGetLLong</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsGetLLong		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">const char *</span> name,
					 <span class="type">long long *</span> value)</pre><div class="description"><p>Finds typed parameter called @name and store its long long int value in @value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not have the expected type. By passing NULL as @value, the function may be used to check presence and type of the parameter.</p></div><dl class="variablelist"><dt>params</dt><dd>array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>where to store the parameter's value</dd><dt>Returns</dt><dd>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsGetString" id="virTypedParamsGetString"><code>virTypedParamsGetString</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsGetString		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">const char *</span> name,
					 <span class="type">const char **</span> value)</pre><div class="description"><p>Finds typed parameter called @name and store its char * value in @value. The function does not create a copy of the string and the caller must not free the string @value points to. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not have the expected type. By passing NULL as @value, the function may be used to check presence and type of the parameter.</p></div><dl class="variablelist"><dt>params</dt><dd>array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>where to store the parameter's value</dd><dt>Returns</dt><dd>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsGetUInt" id="virTypedParamsGetUInt"><code>virTypedParamsGetUInt</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsGetUInt		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">const char *</span> name,
					 <span class="type">unsigned int *</span> value)</pre><div class="description"><p>Finds typed parameter called @name and store its unsigned int value in @value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not have the expected type. By passing NULL as @value, the function may be used to check presence and type of the parameter.</p></div><dl class="variablelist"><dt>params</dt><dd>array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>where to store the parameter's value</dd><dt>Returns</dt><dd>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</dd></dl><div class="acl"></div><h3><a name="virTypedParamsGetULLong" id="virTypedParamsGetULLong"><code>virTypedParamsGetULLong</code></a></h3><pre class="api"><span class="type">int</span>	virTypedParamsGetULLong		(<span class="type"><a href="libvirt-libvirt.html#virTypedParameterPtr">virTypedParameterPtr</a></span> params,
					 <span class="type">int</span> nparams,
					 <span class="type">const char *</span> name,
					 <span class="type">unsigned long long *</span> value)</pre><div class="description"><p>Finds typed parameter called @name and store its unsigned long long int value in @value. The function fails with <a href="libvirt-virterror.html#VIR_ERR_INVALID_ARG">VIR_ERR_INVALID_ARG</a> error if the parameter does not have the expected type. By passing NULL as @value, the function may be used to check presence and type of the parameter.</p></div><dl class="variablelist"><dt>params</dt><dd>array of typed parameters</dd><dt>nparams</dt><dd>number of parameters in the @params array</dd><dt>name</dt><dd>name of the parameter to find</dd><dt>value</dt><dd>where to store the parameter's value</dd><dt>Returns</dt><dd>1 on success, 0 when the parameter does not exist in @params, or -1 on error.</dd></dl><div class="acl"></div></div></div><div id="footer"><p id="sponsor">
	    Sponsored by:<br /><a href="http://et.redhat.com/"><img src="../et.png" alt="Project sponsored by Red Hat Emerging Technology" /></a></p></div></body></html>
